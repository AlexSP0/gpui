// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from targetingschema.xsd.
 */

#ifndef CXX_HOME_AUGUST_DEVELOP_POLICY_PREFERENCES_EDITOR_SRC_APPS_GPUI_SCHEMAS_TARGETINGSCHEMA_H
#define CXX_HOME_AUGUST_DEVELOP_POLICY_PREFERENCES_EDITOR_SRC_APPS_GPUI_SCHEMAS_TARGETINGSCHEMA_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4009911L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Exception indicating that the type information
   * is not available for a type.
   */
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;

  /**
   * @brief Exception indicating that the types are not
   * related by inheritance.
   */
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class EnumFilterTerminalOption;
class EnumFilterTerminalType;
class EnumFilterRegistryHive;
class EnumFilterRegistryValueType;
class EnumFilterRegistrySubType;
class EnumFilterRegistryType;
class EnumFilterOsSp;
class EnumFilterOsEdition;
class EnumFilterOsType;
class EnumFilterOsVersion;
class EnumFilterOsClass;
class EnumFilterMsiSubType;
class EnumFilterMsiType;
class EnumFilterFileType;
class EnumFilterDunType;
class EnumFilterDateDow;
class EnumFilterDatePeriod;
class EnumFilterComputerNameType;
class EnumFilterBool;
class EnumTrueFalse;
class IFilter;
class Filters_t;
class FilterSite;
class FilterGroup;
class FilterRunOnce;
class FilterLdap;
class FilterBattery;
class FilterComputer;
class FilterCpu;
class FilterDate;
class FilterDun;
class FilterDisk;
class FilterDomain;
class FilterVariable;
class FilterFile;
class FilterIpRange;
class FilterLanguage;
class FilterMacRange;
class FilterMsi;
class FilterOs;
class FilterOrgUnit;
class FilterPcmcia;
class FilterPortable;
class FilterProcMode;
class FilterRam;
class FilterRegistry;
class FilterTerminal;
class FilterTime;
class FilterUser;
class FilterWmi;
class FilterCollection;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

/**
 * @brief Enumeration class corresponding to the %enumFilterTerminalOption
 * schema type.
 */
class EnumFilterTerminalOption: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    APPLICATION,
    PROGRAM,
    CLIENT,
    SESSION,
    DIRECTORY,
    IP,
    NE
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterTerminalOption (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterTerminalOption (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterTerminalOption (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterTerminalOption (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterTerminalOption (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterTerminalOption (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterTerminalOption (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterTerminalOption (const EnumFilterTerminalOption& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterTerminalOption*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterTerminalOption&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterTerminalOption_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterTerminalOption_convert () const;

  public:
  static const char* const _xsd_EnumFilterTerminalOption_literals_[7];
  static const Value _xsd_EnumFilterTerminalOption_indexes_[7];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterTerminalType
 * schema type.
 */
class EnumFilterTerminalType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    NE,
    TS,
    CONSOLE
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterTerminalType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterTerminalType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterTerminalType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterTerminalType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterTerminalType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterTerminalType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterTerminalType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterTerminalType (const EnumFilterTerminalType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterTerminalType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterTerminalType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterTerminalType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterTerminalType_convert () const;

  public:
  static const char* const _xsd_EnumFilterTerminalType_literals_[3];
  static const Value _xsd_EnumFilterTerminalType_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterRegistryHive
 * schema type.
 */
class EnumFilterRegistryHive: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    HKEY_LOCAL_MACHINE,
    HKEY_CLASSES_ROOT,
    HKEY_CURRENT_USER,
    HKEY_CURRENT_CONFIG,
    HKEY_USERS
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterRegistryHive (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterRegistryHive (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterRegistryHive (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterRegistryHive (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryHive (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryHive (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryHive (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterRegistryHive (const EnumFilterRegistryHive& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterRegistryHive*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterRegistryHive&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterRegistryHive_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterRegistryHive_convert () const;

  public:
  static const char* const _xsd_EnumFilterRegistryHive_literals_[5];
  static const Value _xsd_EnumFilterRegistryHive_indexes_[5];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterRegistryValueType
 * schema type.
 */
class EnumFilterRegistryValueType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    REG_SZ,
    REG_EXPAND_SZ,
    REG_MULTI_SZ,
    REG_DWORD,
    REG_BINARY,
    empty
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterRegistryValueType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterRegistryValueType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterRegistryValueType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterRegistryValueType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryValueType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryValueType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryValueType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterRegistryValueType (const EnumFilterRegistryValueType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterRegistryValueType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterRegistryValueType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterRegistryValueType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterRegistryValueType_convert () const;

  public:
  static const char* const _xsd_EnumFilterRegistryValueType_literals_[6];
  static const Value _xsd_EnumFilterRegistryValueType_indexes_[6];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterRegistrySubType
 * schema type.
 */
class EnumFilterRegistrySubType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    EQUALHEX,
    EQUALDEC,
    SUBSTRING,
    VERSION
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterRegistrySubType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterRegistrySubType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterRegistrySubType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterRegistrySubType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistrySubType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistrySubType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistrySubType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterRegistrySubType (const EnumFilterRegistrySubType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterRegistrySubType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterRegistrySubType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterRegistrySubType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterRegistrySubType_convert () const;

  public:
  static const char* const _xsd_EnumFilterRegistrySubType_literals_[4];
  static const Value _xsd_EnumFilterRegistrySubType_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterRegistryType
 * schema type.
 */
class EnumFilterRegistryType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    VALUEEXISTS,
    KEYEXISTS,
    MATCHVALUE,
    GETVALUE
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterRegistryType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterRegistryType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterRegistryType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterRegistryType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterRegistryType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterRegistryType (const EnumFilterRegistryType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterRegistryType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterRegistryType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterRegistryType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterRegistryType_convert () const;

  public:
  static const char* const _xsd_EnumFilterRegistryType_literals_[4];
  static const Value _xsd_EnumFilterRegistryType_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterOsSp
 * schema type.
 */
class EnumFilterOsSp: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    NE,
    Gold,
    Service_Pack_1,
    Service_Pack_2,
    Service_Pack_3,
    Service_Pack_4,
    Service_Pack_5,
    Service_Pack_6
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterOsSp (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterOsSp (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterOsSp (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterOsSp (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsSp (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsSp (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsSp (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterOsSp (const EnumFilterOsSp& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterOsSp*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterOsSp&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterOsSp_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterOsSp_convert () const;

  public:
  static const char* const _xsd_EnumFilterOsSp_literals_[8];
  static const Value _xsd_EnumFilterOsSp_indexes_[8];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterOsEdition
 * schema type.
 */
class EnumFilterOsEdition: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    NE,
    cxx_64EP,
    cxx_64DC,
    AS,
    DTC,
    EP,
    WEB,
    cxx_64,
    HM,
    MC,
    TPC,
    SRV,
    STD,
    TSE,
    SBS,
    PRO
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterOsEdition (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterOsEdition (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterOsEdition (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterOsEdition (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsEdition (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsEdition (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsEdition (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterOsEdition (const EnumFilterOsEdition& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterOsEdition*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterOsEdition&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterOsEdition_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterOsEdition_convert () const;

  public:
  static const char* const _xsd_EnumFilterOsEdition_literals_[16];
  static const Value _xsd_EnumFilterOsEdition_indexes_[16];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterOsType
 * schema type.
 */
class EnumFilterOsType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    NE,
    R2,
    SE,
    WS,
    SV,
    DC,
    PRO,
    PR
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterOsType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterOsType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterOsType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterOsType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterOsType (const EnumFilterOsType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterOsType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterOsType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterOsType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterOsType_convert () const;

  public:
  static const char* const _xsd_EnumFilterOsType_literals_[8];
  static const Value _xsd_EnumFilterOsType_indexes_[8];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterOsVersion
 * schema type.
 */
class EnumFilterOsVersion: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    NE,
    cxx_95,
    cxx_98,
    ME,
    NT,
    cxx_2K,
    XP,
    cxx_2K3,
    cxx_2K3R2,
    VISTA,
    cxx_2K8,
    WIN7,
    cxx_2K8R2,
    WIN8,
    WIN8S,
    WINBLUE,
    WINBLUESRV,
    WINTHRESHOLD,
    WINTHRESHOLDSRV
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterOsVersion (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterOsVersion (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterOsVersion (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterOsVersion (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsVersion (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsVersion (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsVersion (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterOsVersion (const EnumFilterOsVersion& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterOsVersion*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterOsVersion&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterOsVersion_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterOsVersion_convert () const;

  public:
  static const char* const _xsd_EnumFilterOsVersion_literals_[19];
  static const Value _xsd_EnumFilterOsVersion_indexes_[19];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterOsClass
 * schema type.
 */
class EnumFilterOsClass: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    NE,
    cxx_9X,
    NT
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterOsClass (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterOsClass (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterOsClass (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterOsClass (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsClass (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsClass (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterOsClass (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterOsClass (const EnumFilterOsClass& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterOsClass*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterOsClass&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterOsClass_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterOsClass_convert () const;

  public:
  static const char* const _xsd_EnumFilterOsClass_literals_[3];
  static const Value _xsd_EnumFilterOsClass_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterMsiSubType
 * schema type.
 */
class EnumFilterMsiSubType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    EXISTS,
    VERSION,
    GET_PROPERTY,
    GET_INFORMATION,
    MATCH_PROPERTY,
    MATCH_INFORMATION
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterMsiSubType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterMsiSubType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterMsiSubType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterMsiSubType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterMsiSubType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterMsiSubType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterMsiSubType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterMsiSubType (const EnumFilterMsiSubType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterMsiSubType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterMsiSubType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterMsiSubType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterMsiSubType_convert () const;

  public:
  static const char* const _xsd_EnumFilterMsiSubType_literals_[6];
  static const Value _xsd_EnumFilterMsiSubType_indexes_[6];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterMsiType
 * schema type.
 */
class EnumFilterMsiType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    PRODUCT,
    PATCH,
    FILECOMPONENT
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterMsiType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterMsiType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterMsiType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterMsiType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterMsiType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterMsiType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterMsiType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterMsiType (const EnumFilterMsiType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterMsiType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterMsiType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterMsiType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterMsiType_convert () const;

  public:
  static const char* const _xsd_EnumFilterMsiType_literals_[3];
  static const Value _xsd_EnumFilterMsiType_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterFileType
 * schema type.
 */
class EnumFilterFileType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    EXISTS,
    VERSION
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterFileType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterFileType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterFileType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterFileType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterFileType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterFileType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterFileType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterFileType (const EnumFilterFileType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterFileType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterFileType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterFileType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterFileType_convert () const;

  public:
  static const char* const _xsd_EnumFilterFileType_literals_[2];
  static const Value _xsd_EnumFilterFileType_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterDunType
 * schema type.
 */
class EnumFilterDunType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    empty,
    modem,
    isdn,
    x25,
    vpn,
    pad,
    GENERIC,
    SERIAL,
    FRAMERELAY,
    ATM,
    SONET,
    SW56,
    IRDA,
    PARALLEL,
    PPPoE
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterDunType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterDunType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterDunType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterDunType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDunType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDunType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDunType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterDunType (const EnumFilterDunType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterDunType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterDunType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterDunType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterDunType_convert () const;

  public:
  static const char* const _xsd_EnumFilterDunType_literals_[15];
  static const Value _xsd_EnumFilterDunType_indexes_[15];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterDateDow
 * schema type.
 */
class EnumFilterDateDow: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    SUN,
    MON,
    TUE,
    WED,
    THU,
    FRI,
    SAT
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterDateDow (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterDateDow (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterDateDow (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterDateDow (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDateDow (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDateDow (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDateDow (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterDateDow (const EnumFilterDateDow& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterDateDow*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterDateDow&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterDateDow_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterDateDow_convert () const;

  public:
  static const char* const _xsd_EnumFilterDateDow_literals_[7];
  static const Value _xsd_EnumFilterDateDow_indexes_[7];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterDatePeriod
 * schema type.
 */
class EnumFilterDatePeriod: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    MONTHLY,
    WEEKLY,
    YEARLY
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterDatePeriod (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterDatePeriod (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterDatePeriod (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterDatePeriod (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDatePeriod (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDatePeriod (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterDatePeriod (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterDatePeriod (const EnumFilterDatePeriod& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterDatePeriod*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterDatePeriod&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterDatePeriod_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterDatePeriod_convert () const;

  public:
  static const char* const _xsd_EnumFilterDatePeriod_literals_[3];
  static const Value _xsd_EnumFilterDatePeriod_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterComputerNameType
 * schema type.
 */
class EnumFilterComputerNameType: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    DNS,
    NETBIOS
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterComputerNameType (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterComputerNameType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterComputerNameType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterComputerNameType (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterComputerNameType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterComputerNameType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterComputerNameType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterComputerNameType (const EnumFilterComputerNameType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterComputerNameType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterComputerNameType&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterComputerNameType_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterComputerNameType_convert () const;

  public:
  static const char* const _xsd_EnumFilterComputerNameType_literals_[2];
  static const Value _xsd_EnumFilterComputerNameType_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumFilterBool
 * schema type.
 */
class EnumFilterBool: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    AND,
    OR
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumFilterBool (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumFilterBool (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumFilterBool (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumFilterBool (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterBool (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterBool (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumFilterBool (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumFilterBool (const EnumFilterBool& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumFilterBool*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumFilterBool&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumFilterBool_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumFilterBool_convert () const;

  public:
  static const char* const _xsd_EnumFilterBool_literals_[2];
  static const Value _xsd_EnumFilterBool_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %enumTrueFalse
 * schema type.
 */
class EnumTrueFalse: public ::xml_schema::String
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum Value
  {
    cxx_0,
    cxx_1
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  EnumTrueFalse (Value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  EnumTrueFalse (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  EnumTrueFalse (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  EnumTrueFalse (const ::xml_schema::String& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumTrueFalse (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumTrueFalse (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnumTrueFalse (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnumTrueFalse (const EnumTrueFalse& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnumTrueFalse*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  EnumTrueFalse&
  operator= (Value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator Value () const
  {
    return _xsd_EnumTrueFalse_convert ();
  }

  //@cond

  protected:
  Value
  _xsd_EnumTrueFalse_convert () const;

  public:
  static const char* const _xsd_EnumTrueFalse_literals_[2];
  static const Value _xsd_EnumTrueFalse_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %IFilter schema type.
 *
 * @nosubgrouping
 */
class IFilter: public ::xml_schema::Type
{
  public:
  /**
   * @name bool
   *
   * @brief Accessor and modifier functions for the %bool
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterBool BoolType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< BoolType, char > BoolTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const BoolType&
  bool_ () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  BoolType&
  bool_ ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  bool_ (const BoolType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  bool_ (::std::unique_ptr< BoolType > p);

  //@}

  /**
   * @name not
   *
   * @brief Accessor and modifier functions for the %not
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse NotType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NotType, char > NotTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NotType&
  not_ () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NotType&
  not_ ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  not_ (const NotType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  not_ (::std::unique_ptr< NotType > p);

  //@}

  /**
   * @name hidden
   *
   * @brief Accessor and modifier functions for the %hidden
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse HiddenType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< HiddenType > HiddenOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< HiddenType, char > HiddenTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const HiddenOptional&
  hidden () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  HiddenOptional&
  hidden ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  hidden (const HiddenType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  hidden (const HiddenOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  hidden (::std::unique_ptr< HiddenType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  IFilter (const BoolType&,
           const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  IFilter (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  IFilter (const IFilter& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual IFilter*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const = 0;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  IFilter&
  operator= (const IFilter& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~IFilter ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< BoolType > bool__;
  ::xsd::cxx::tree::one< NotType > not__;
  HiddenOptional hidden_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Filters_t schema type.
 *
 * @nosubgrouping
 */
class Filters_t: public ::xml_schema::Type
{
  public:
  /**
   * @name FilterSite
   *
   * @brief Accessor and modifier functions for the %FilterSite
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterSite FilterSiteType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterSiteType > FilterSiteSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterSiteSequence::iterator FilterSiteIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterSiteSequence::const_iterator FilterSiteConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterSiteType, char > FilterSiteTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterSiteSequence&
  FilterSite () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterSiteSequence&
  FilterSite ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterSite (const FilterSiteSequence& s);

  //@}

  /**
   * @name FilterGroup
   *
   * @brief Accessor and modifier functions for the %FilterGroup
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterGroup FilterGroupType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterGroupType > FilterGroupSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterGroupSequence::iterator FilterGroupIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterGroupSequence::const_iterator FilterGroupConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterGroupType, char > FilterGroupTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterGroupSequence&
  FilterGroup () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterGroupSequence&
  FilterGroup ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterGroup (const FilterGroupSequence& s);

  //@}

  /**
   * @name FilterRunOnce
   *
   * @brief Accessor and modifier functions for the %FilterRunOnce
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterRunOnce FilterRunOnceType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterRunOnceType > FilterRunOnceSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterRunOnceSequence::iterator FilterRunOnceIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterRunOnceSequence::const_iterator FilterRunOnceConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterRunOnceType, char > FilterRunOnceTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterRunOnceSequence&
  FilterRunOnce () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterRunOnceSequence&
  FilterRunOnce ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterRunOnce (const FilterRunOnceSequence& s);

  //@}

  /**
   * @name FilterLdap
   *
   * @brief Accessor and modifier functions for the %FilterLdap
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterLdap FilterLdapType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterLdapType > FilterLdapSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterLdapSequence::iterator FilterLdapIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterLdapSequence::const_iterator FilterLdapConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterLdapType, char > FilterLdapTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterLdapSequence&
  FilterLdap () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterLdapSequence&
  FilterLdap ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterLdap (const FilterLdapSequence& s);

  //@}

  /**
   * @name FilterBattery
   *
   * @brief Accessor and modifier functions for the %FilterBattery
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterBattery FilterBatteryType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterBatteryType > FilterBatterySequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterBatterySequence::iterator FilterBatteryIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterBatterySequence::const_iterator FilterBatteryConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterBatteryType, char > FilterBatteryTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterBatterySequence&
  FilterBattery () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterBatterySequence&
  FilterBattery ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterBattery (const FilterBatterySequence& s);

  //@}

  /**
   * @name FilterComputer
   *
   * @brief Accessor and modifier functions for the %FilterComputer
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterComputer FilterComputerType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterComputerType > FilterComputerSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterComputerSequence::iterator FilterComputerIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterComputerSequence::const_iterator FilterComputerConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterComputerType, char > FilterComputerTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterComputerSequence&
  FilterComputer () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterComputerSequence&
  FilterComputer ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterComputer (const FilterComputerSequence& s);

  //@}

  /**
   * @name FilterCpu
   *
   * @brief Accessor and modifier functions for the %FilterCpu
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterCpu FilterCpuType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterCpuType > FilterCpuSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterCpuSequence::iterator FilterCpuIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterCpuSequence::const_iterator FilterCpuConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterCpuType, char > FilterCpuTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterCpuSequence&
  FilterCpu () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterCpuSequence&
  FilterCpu ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterCpu (const FilterCpuSequence& s);

  //@}

  /**
   * @name FilterDate
   *
   * @brief Accessor and modifier functions for the %FilterDate
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterDate FilterDateType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterDateType > FilterDateSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterDateSequence::iterator FilterDateIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterDateSequence::const_iterator FilterDateConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterDateType, char > FilterDateTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterDateSequence&
  FilterDate () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterDateSequence&
  FilterDate ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterDate (const FilterDateSequence& s);

  //@}

  /**
   * @name FilterDun
   *
   * @brief Accessor and modifier functions for the %FilterDun
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterDun FilterDunType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterDunType > FilterDunSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterDunSequence::iterator FilterDunIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterDunSequence::const_iterator FilterDunConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterDunType, char > FilterDunTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterDunSequence&
  FilterDun () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterDunSequence&
  FilterDun ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterDun (const FilterDunSequence& s);

  //@}

  /**
   * @name FilterDisk
   *
   * @brief Accessor and modifier functions for the %FilterDisk
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterDisk FilterDiskType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterDiskType > FilterDiskSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterDiskSequence::iterator FilterDiskIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterDiskSequence::const_iterator FilterDiskConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterDiskType, char > FilterDiskTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterDiskSequence&
  FilterDisk () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterDiskSequence&
  FilterDisk ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterDisk (const FilterDiskSequence& s);

  //@}

  /**
   * @name FilterDomain
   *
   * @brief Accessor and modifier functions for the %FilterDomain
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterDomain FilterDomainType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterDomainType > FilterDomainSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterDomainSequence::iterator FilterDomainIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterDomainSequence::const_iterator FilterDomainConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterDomainType, char > FilterDomainTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterDomainSequence&
  FilterDomain () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterDomainSequence&
  FilterDomain ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterDomain (const FilterDomainSequence& s);

  //@}

  /**
   * @name FilterVariable
   *
   * @brief Accessor and modifier functions for the %FilterVariable
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterVariable FilterVariableType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterVariableType > FilterVariableSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterVariableSequence::iterator FilterVariableIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterVariableSequence::const_iterator FilterVariableConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterVariableType, char > FilterVariableTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterVariableSequence&
  FilterVariable () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterVariableSequence&
  FilterVariable ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterVariable (const FilterVariableSequence& s);

  //@}

  /**
   * @name FilterFile
   *
   * @brief Accessor and modifier functions for the %FilterFile
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterFile FilterFileType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterFileType > FilterFileSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterFileSequence::iterator FilterFileIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterFileSequence::const_iterator FilterFileConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterFileType, char > FilterFileTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterFileSequence&
  FilterFile () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterFileSequence&
  FilterFile ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterFile (const FilterFileSequence& s);

  //@}

  /**
   * @name FilterIpRange
   *
   * @brief Accessor and modifier functions for the %FilterIpRange
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterIpRange FilterIpRangeType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterIpRangeType > FilterIpRangeSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterIpRangeSequence::iterator FilterIpRangeIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterIpRangeSequence::const_iterator FilterIpRangeConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterIpRangeType, char > FilterIpRangeTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterIpRangeSequence&
  FilterIpRange () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterIpRangeSequence&
  FilterIpRange ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterIpRange (const FilterIpRangeSequence& s);

  //@}

  /**
   * @name FilterLanguage
   *
   * @brief Accessor and modifier functions for the %FilterLanguage
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterLanguage FilterLanguageType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterLanguageType > FilterLanguageSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterLanguageSequence::iterator FilterLanguageIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterLanguageSequence::const_iterator FilterLanguageConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterLanguageType, char > FilterLanguageTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterLanguageSequence&
  FilterLanguage () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterLanguageSequence&
  FilterLanguage ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterLanguage (const FilterLanguageSequence& s);

  //@}

  /**
   * @name FilterMacRange
   *
   * @brief Accessor and modifier functions for the %FilterMacRange
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterMacRange FilterMacRangeType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterMacRangeType > FilterMacRangeSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterMacRangeSequence::iterator FilterMacRangeIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterMacRangeSequence::const_iterator FilterMacRangeConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterMacRangeType, char > FilterMacRangeTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterMacRangeSequence&
  FilterMacRange () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterMacRangeSequence&
  FilterMacRange ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterMacRange (const FilterMacRangeSequence& s);

  //@}

  /**
   * @name FilterMsi
   *
   * @brief Accessor and modifier functions for the %FilterMsi
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterMsi FilterMsiType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterMsiType > FilterMsiSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterMsiSequence::iterator FilterMsiIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterMsiSequence::const_iterator FilterMsiConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterMsiType, char > FilterMsiTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterMsiSequence&
  FilterMsi () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterMsiSequence&
  FilterMsi ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterMsi (const FilterMsiSequence& s);

  //@}

  /**
   * @name FilterOs
   *
   * @brief Accessor and modifier functions for the %FilterOs
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterOs FilterOsType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterOsType > FilterOsSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterOsSequence::iterator FilterOsIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterOsSequence::const_iterator FilterOsConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterOsType, char > FilterOsTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterOsSequence&
  FilterOs () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterOsSequence&
  FilterOs ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterOs (const FilterOsSequence& s);

  //@}

  /**
   * @name FilterOrgUnit
   *
   * @brief Accessor and modifier functions for the %FilterOrgUnit
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterOrgUnit FilterOrgUnitType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterOrgUnitType > FilterOrgUnitSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterOrgUnitSequence::iterator FilterOrgUnitIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterOrgUnitSequence::const_iterator FilterOrgUnitConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterOrgUnitType, char > FilterOrgUnitTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterOrgUnitSequence&
  FilterOrgUnit () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterOrgUnitSequence&
  FilterOrgUnit ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterOrgUnit (const FilterOrgUnitSequence& s);

  //@}

  /**
   * @name FilterPcmcia
   *
   * @brief Accessor and modifier functions for the %FilterPcmcia
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterPcmcia FilterPcmciaType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterPcmciaType > FilterPcmciaSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterPcmciaSequence::iterator FilterPcmciaIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterPcmciaSequence::const_iterator FilterPcmciaConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterPcmciaType, char > FilterPcmciaTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterPcmciaSequence&
  FilterPcmcia () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterPcmciaSequence&
  FilterPcmcia ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterPcmcia (const FilterPcmciaSequence& s);

  //@}

  /**
   * @name FilterPortable
   *
   * @brief Accessor and modifier functions for the %FilterPortable
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterPortable FilterPortableType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterPortableType > FilterPortableSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterPortableSequence::iterator FilterPortableIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterPortableSequence::const_iterator FilterPortableConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterPortableType, char > FilterPortableTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterPortableSequence&
  FilterPortable () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterPortableSequence&
  FilterPortable ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterPortable (const FilterPortableSequence& s);

  //@}

  /**
   * @name FilterProcMode
   *
   * @brief Accessor and modifier functions for the %FilterProcMode
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterProcMode FilterProcModeType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterProcModeType > FilterProcModeSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterProcModeSequence::iterator FilterProcModeIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterProcModeSequence::const_iterator FilterProcModeConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterProcModeType, char > FilterProcModeTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterProcModeSequence&
  FilterProcMode () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterProcModeSequence&
  FilterProcMode ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterProcMode (const FilterProcModeSequence& s);

  //@}

  /**
   * @name FilterRam
   *
   * @brief Accessor and modifier functions for the %FilterRam
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterRam FilterRamType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterRamType > FilterRamSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterRamSequence::iterator FilterRamIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterRamSequence::const_iterator FilterRamConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterRamType, char > FilterRamTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterRamSequence&
  FilterRam () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterRamSequence&
  FilterRam ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterRam (const FilterRamSequence& s);

  //@}

  /**
   * @name FilterRegistry
   *
   * @brief Accessor and modifier functions for the %FilterRegistry
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterRegistry FilterRegistryType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterRegistryType > FilterRegistrySequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterRegistrySequence::iterator FilterRegistryIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterRegistrySequence::const_iterator FilterRegistryConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterRegistryType, char > FilterRegistryTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterRegistrySequence&
  FilterRegistry () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterRegistrySequence&
  FilterRegistry ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterRegistry (const FilterRegistrySequence& s);

  //@}

  /**
   * @name FilterTerminal
   *
   * @brief Accessor and modifier functions for the %FilterTerminal
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterTerminal FilterTerminalType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterTerminalType > FilterTerminalSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterTerminalSequence::iterator FilterTerminalIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterTerminalSequence::const_iterator FilterTerminalConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterTerminalType, char > FilterTerminalTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterTerminalSequence&
  FilterTerminal () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterTerminalSequence&
  FilterTerminal ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterTerminal (const FilterTerminalSequence& s);

  //@}

  /**
   * @name FilterTime
   *
   * @brief Accessor and modifier functions for the %FilterTime
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterTime FilterTimeType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterTimeType > FilterTimeSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterTimeSequence::iterator FilterTimeIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterTimeSequence::const_iterator FilterTimeConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterTimeType, char > FilterTimeTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterTimeSequence&
  FilterTime () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterTimeSequence&
  FilterTime ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterTime (const FilterTimeSequence& s);

  //@}

  /**
   * @name FilterUser
   *
   * @brief Accessor and modifier functions for the %FilterUser
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterUser FilterUserType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterUserType > FilterUserSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterUserSequence::iterator FilterUserIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterUserSequence::const_iterator FilterUserConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterUserType, char > FilterUserTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterUserSequence&
  FilterUser () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterUserSequence&
  FilterUser ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterUser (const FilterUserSequence& s);

  //@}

  /**
   * @name FilterWmi
   *
   * @brief Accessor and modifier functions for the %FilterWmi
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterWmi FilterWmiType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterWmiType > FilterWmiSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterWmiSequence::iterator FilterWmiIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterWmiSequence::const_iterator FilterWmiConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterWmiType, char > FilterWmiTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterWmiSequence&
  FilterWmi () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterWmiSequence&
  FilterWmi ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterWmi (const FilterWmiSequence& s);

  //@}

  /**
   * @name FilterCollection
   *
   * @brief Accessor and modifier functions for the %FilterCollection
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterCollection FilterCollectionType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterCollectionType > FilterCollectionSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterCollectionSequence::iterator FilterCollectionIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterCollectionSequence::const_iterator FilterCollectionConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterCollectionType, char > FilterCollectionTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterCollectionSequence&
  FilterCollection () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterCollectionSequence&
  FilterCollection ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterCollection (const FilterCollectionSequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Filters_t ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Filters_t (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Filters_t (const Filters_t& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Filters_t*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Filters_t&
  operator= (const Filters_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Filters_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  FilterSiteSequence FilterSite_;
  FilterGroupSequence FilterGroup_;
  FilterRunOnceSequence FilterRunOnce_;
  FilterLdapSequence FilterLdap_;
  FilterBatterySequence FilterBattery_;
  FilterComputerSequence FilterComputer_;
  FilterCpuSequence FilterCpu_;
  FilterDateSequence FilterDate_;
  FilterDunSequence FilterDun_;
  FilterDiskSequence FilterDisk_;
  FilterDomainSequence FilterDomain_;
  FilterVariableSequence FilterVariable_;
  FilterFileSequence FilterFile_;
  FilterIpRangeSequence FilterIpRange_;
  FilterLanguageSequence FilterLanguage_;
  FilterMacRangeSequence FilterMacRange_;
  FilterMsiSequence FilterMsi_;
  FilterOsSequence FilterOs_;
  FilterOrgUnitSequence FilterOrgUnit_;
  FilterPcmciaSequence FilterPcmcia_;
  FilterPortableSequence FilterPortable_;
  FilterProcModeSequence FilterProcMode_;
  FilterRamSequence FilterRam_;
  FilterRegistrySequence FilterRegistry_;
  FilterTerminalSequence FilterTerminal_;
  FilterTimeSequence FilterTime_;
  FilterUserSequence FilterUser_;
  FilterWmiSequence FilterWmi_;
  FilterCollectionSequence FilterCollection_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterSite schema type.
 *
 * @nosubgrouping
 */
class FilterSite: public ::IFilter
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String NameType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NameType&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NameType&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const NameType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< NameType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterSite (const BoolType&,
              const NotType&,
              const NameType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterSite (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterSite (const FilterSite& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterSite*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterSite&
  operator= (const FilterSite& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterSite ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< NameType > name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterGroup schema type.
 *
 * @nosubgrouping
 */
class FilterGroup: public ::IFilter
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String NameType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NameType&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NameType&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const NameType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< NameType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const NameType&
  name_default_value ();

  //@}

  /**
   * @name sid
   *
   * @brief Accessor and modifier functions for the %sid
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String SidType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SidType, char > SidTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SidType&
  sid () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SidType&
  sid ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  sid (const SidType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  sid (::std::unique_ptr< SidType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const SidType&
  sid_default_value ();

  //@}

  /**
   * @name userContext
   *
   * @brief Accessor and modifier functions for the %userContext
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse UserContextType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< UserContextType, char > UserContextTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const UserContextType&
  userContext () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  UserContextType&
  userContext ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  userContext (const UserContextType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  userContext (::std::unique_ptr< UserContextType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const UserContextType&
  userContext_default_value ();

  //@}

  /**
   * @name primaryGroup
   *
   * @brief Accessor and modifier functions for the %primaryGroup
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse PrimaryGroupType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< PrimaryGroupType, char > PrimaryGroupTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const PrimaryGroupType&
  primaryGroup () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  PrimaryGroupType&
  primaryGroup ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  primaryGroup (const PrimaryGroupType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  primaryGroup (::std::unique_ptr< PrimaryGroupType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const PrimaryGroupType&
  primaryGroup_default_value ();

  //@}

  /**
   * @name localGroup
   *
   * @brief Accessor and modifier functions for the %localGroup
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse LocalGroupType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< LocalGroupType, char > LocalGroupTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const LocalGroupType&
  localGroup () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  LocalGroupType&
  localGroup ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  localGroup (const LocalGroupType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  localGroup (::std::unique_ptr< LocalGroupType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const LocalGroupType&
  localGroup_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterGroup (const BoolType&,
               const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterGroup (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterGroup (const FilterGroup& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterGroup*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterGroup&
  operator= (const FilterGroup& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterGroup ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< NameType > name_;
  static const NameType name_default_value_;
  ::xsd::cxx::tree::one< SidType > sid_;
  static const SidType sid_default_value_;
  ::xsd::cxx::tree::one< UserContextType > userContext_;
  static const UserContextType userContext_default_value_;
  ::xsd::cxx::tree::one< PrimaryGroupType > primaryGroup_;
  static const PrimaryGroupType primaryGroup_default_value_;
  ::xsd::cxx::tree::one< LocalGroupType > localGroup_;
  static const LocalGroupType localGroup_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterRunOnce schema type.
 *
 * @nosubgrouping
 */
class FilterRunOnce: public ::IFilter
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String IdType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const IdType&
  id () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  IdType&
  id ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  id (const IdType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  id (::std::unique_ptr< IdType > p);

  //@}

  /**
   * @name userContext
   *
   * @brief Accessor and modifier functions for the %userContext
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse UserContextType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< UserContextType, char > UserContextTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const UserContextType&
  userContext () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  UserContextType&
  userContext ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  userContext (const UserContextType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  userContext (::std::unique_ptr< UserContextType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const UserContextType&
  userContext_default_value ();

  //@}

  /**
   * @name comments
   *
   * @brief Accessor and modifier functions for the %comments
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String CommentsType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< CommentsType, char > CommentsTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const CommentsType&
  comments () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  CommentsType&
  comments ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  comments (const CommentsType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  comments (::std::unique_ptr< CommentsType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const CommentsType&
  comments_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterRunOnce (const BoolType&,
                 const NotType&,
                 const IdType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterRunOnce (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterRunOnce (const FilterRunOnce& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterRunOnce*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterRunOnce&
  operator= (const FilterRunOnce& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterRunOnce ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< IdType > id_;
  ::xsd::cxx::tree::one< UserContextType > userContext_;
  static const UserContextType userContext_default_value_;
  ::xsd::cxx::tree::one< CommentsType > comments_;
  static const CommentsType comments_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterLdap schema type.
 *
 * @nosubgrouping
 */
class FilterLdap: public ::IFilter
{
  public:
  /**
   * @name searchFilter
   *
   * @brief Accessor and modifier functions for the %searchFilter
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String SearchFilterType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< SearchFilterType > SearchFilterOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SearchFilterType, char > SearchFilterTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const SearchFilterOptional&
  searchFilter () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  SearchFilterOptional&
  searchFilter ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  searchFilter (const SearchFilterType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  searchFilter (const SearchFilterOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  searchFilter (::std::unique_ptr< SearchFilterType > p);

  //@}

  /**
   * @name binding
   *
   * @brief Accessor and modifier functions for the %binding
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String BindingType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< BindingType, char > BindingTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const BindingType&
  binding () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  BindingType&
  binding ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  binding (const BindingType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  binding (::std::unique_ptr< BindingType > p);

  //@}

  /**
   * @name variableName
   *
   * @brief Accessor and modifier functions for the %variableName
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String VariableNameType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< VariableNameType > VariableNameOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< VariableNameType, char > VariableNameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const VariableNameOptional&
  variableName () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  VariableNameOptional&
  variableName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  variableName (const VariableNameType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  variableName (const VariableNameOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  variableName (::std::unique_ptr< VariableNameType > p);

  //@}

  /**
   * @name attribute
   *
   * @brief Accessor and modifier functions for the %attribute
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String AttributeType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< AttributeType > AttributeOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< AttributeType, char > AttributeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const AttributeOptional&
  attribute () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  AttributeOptional&
  attribute ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  attribute (const AttributeType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  attribute (const AttributeOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  attribute (::std::unique_ptr< AttributeType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterLdap (const BoolType&,
              const NotType&,
              const BindingType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterLdap (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterLdap (const FilterLdap& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterLdap*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterLdap&
  operator= (const FilterLdap& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterLdap ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  SearchFilterOptional searchFilter_;
  ::xsd::cxx::tree::one< BindingType > binding_;
  VariableNameOptional variableName_;
  AttributeOptional attribute_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterBattery schema type.
 *
 * @nosubgrouping
 */
class FilterBattery: public ::IFilter
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterBattery (const BoolType&,
                 const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterBattery (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterBattery (const FilterBattery& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterBattery*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterBattery ();
};

/**
 * @brief Class corresponding to the %FilterComputer schema type.
 *
 * @nosubgrouping
 */
class FilterComputer: public ::IFilter
{
  public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterComputerNameType TypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const TypeType&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  TypeType&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const TypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< TypeType > p);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String NameType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NameType&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NameType&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const NameType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< NameType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterComputer (const BoolType&,
                  const NotType&,
                  const TypeType&,
                  const NameType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterComputer (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterComputer (const FilterComputer& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterComputer*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterComputer&
  operator= (const FilterComputer& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterComputer ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< TypeType > type_;
  ::xsd::cxx::tree::one< NameType > name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterCpu schema type.
 *
 * @nosubgrouping
 */
class FilterCpu: public ::IFilter
{
  public:
  /**
   * @name speedMHz
   *
   * @brief Accessor and modifier functions for the %speedMHz
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::UnsignedShort SpeedMHzType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SpeedMHzType, char > SpeedMHzTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SpeedMHzType&
  speedMHz () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SpeedMHzType&
  speedMHz ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  speedMHz (const SpeedMHzType& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterCpu (const BoolType&,
             const NotType&,
             const SpeedMHzType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterCpu (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterCpu (const FilterCpu& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterCpu*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterCpu&
  operator= (const FilterCpu& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterCpu ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< SpeedMHzType > speedMHz_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterDate schema type.
 *
 * @nosubgrouping
 */
class FilterDate: public ::IFilter
{
  public:
  /**
   * @name period
   *
   * @brief Accessor and modifier functions for the %period
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterDatePeriod PeriodType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const PeriodType&
  period () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  PeriodType&
  period ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  period (const PeriodType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  period (::std::unique_ptr< PeriodType > p);

  //@}

  /**
   * @name dow
   *
   * @brief Accessor and modifier functions for the %dow
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterDateDow DowType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DowType > DowOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< DowType, char > DowTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DowOptional&
  dow () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  DowOptional&
  dow ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  dow (const DowType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  dow (const DowOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  dow (::std::unique_ptr< DowType > p);

  //@}

  /**
   * @name day
   *
   * @brief Accessor and modifier functions for the %day
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::UnsignedByte DayType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DayType > DayOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< DayType, char > DayTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DayOptional&
  day () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  DayOptional&
  day ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  day (const DayType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  day (const DayOptional& x);

  //@}

  /**
   * @name month
   *
   * @brief Accessor and modifier functions for the %month
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::UnsignedByte MonthType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MonthType > MonthOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MonthType, char > MonthTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MonthOptional&
  month () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  MonthOptional&
  month ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  month (const MonthType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  month (const MonthOptional& x);

  //@}

  /**
   * @name year
   *
   * @brief Accessor and modifier functions for the %year
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::UnsignedShort YearType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< YearType > YearOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< YearType, char > YearTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const YearOptional&
  year () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  YearOptional&
  year ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  year (const YearType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  year (const YearOptional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterDate (const BoolType&,
              const NotType&,
              const PeriodType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterDate (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterDate (const FilterDate& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterDate*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterDate&
  operator= (const FilterDate& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterDate ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< PeriodType > period_;
  DowOptional dow_;
  DayOptional day_;
  MonthOptional month_;
  YearOptional year_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterDun schema type.
 *
 * @nosubgrouping
 */
class FilterDun: public ::IFilter
{
  public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterDunType TypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const TypeType&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  TypeType&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const TypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< TypeType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterDun (const BoolType&,
             const NotType&,
             const TypeType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterDun (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterDun (const FilterDun& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterDun*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterDun&
  operator= (const FilterDun& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterDun ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< TypeType > type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterDisk schema type.
 *
 * @nosubgrouping
 */
class FilterDisk: public ::IFilter
{
  public:
  /**
   * @name freeSpace
   *
   * @brief Accessor and modifier functions for the %freeSpace
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::UnsignedByte FreeSpaceType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< FreeSpaceType, char > FreeSpaceTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const FreeSpaceType&
  freeSpace () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  FreeSpaceType&
  freeSpace ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  freeSpace (const FreeSpaceType& x);

  //@}

  /**
   * @name drive
   *
   * @brief Accessor and modifier functions for the %drive
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String DriveType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< DriveType, char > DriveTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const DriveType&
  drive () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  DriveType&
  drive ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  drive (const DriveType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  drive (::std::unique_ptr< DriveType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterDisk (const BoolType&,
              const NotType&,
              const FreeSpaceType&,
              const DriveType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterDisk (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterDisk (const FilterDisk& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterDisk*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterDisk&
  operator= (const FilterDisk& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterDisk ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< FreeSpaceType > freeSpace_;
  ::xsd::cxx::tree::one< DriveType > drive_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterDomain schema type.
 *
 * @nosubgrouping
 */
class FilterDomain: public ::IFilter
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String NameType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NameType&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NameType&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const NameType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< NameType > p);

  //@}

  /**
   * @name userContext
   *
   * @brief Accessor and modifier functions for the %userContext
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse UserContextType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< UserContextType, char > UserContextTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const UserContextType&
  userContext () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  UserContextType&
  userContext ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  userContext (const UserContextType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  userContext (::std::unique_ptr< UserContextType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const UserContextType&
  userContext_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterDomain (const BoolType&,
                const NotType&,
                const NameType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterDomain (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterDomain (const FilterDomain& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterDomain*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterDomain&
  operator= (const FilterDomain& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterDomain ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< NameType > name_;
  ::xsd::cxx::tree::one< UserContextType > userContext_;
  static const UserContextType userContext_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterVariable schema type.
 *
 * @nosubgrouping
 */
class FilterVariable: public ::IFilter
{
  public:
  /**
   * @name variableName
   *
   * @brief Accessor and modifier functions for the %variableName
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String VariableNameType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< VariableNameType, char > VariableNameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const VariableNameType&
  variableName () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  VariableNameType&
  variableName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  variableName (const VariableNameType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  variableName (::std::unique_ptr< VariableNameType > p);

  //@}

  /**
   * @name value
   *
   * @brief Accessor and modifier functions for the %value
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String ValueType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const ValueType&
  value () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  ValueType&
  value ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  value (const ValueType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  value (::std::unique_ptr< ValueType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const ValueType&
  value_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterVariable (const BoolType&,
                  const NotType&,
                  const VariableNameType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterVariable (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterVariable (const FilterVariable& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterVariable*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterVariable&
  operator= (const FilterVariable& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterVariable ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< VariableNameType > variableName_;
  ::xsd::cxx::tree::one< ValueType > value_;
  static const ValueType value_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterFile schema type.
 *
 * @nosubgrouping
 */
class FilterFile: public ::IFilter
{
  public:
  /**
   * @name gte
   *
   * @brief Accessor and modifier functions for the %gte
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse GteType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< GteType, char > GteTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const GteType&
  gte () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  GteType&
  gte ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  gte (const GteType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  gte (::std::unique_ptr< GteType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const GteType&
  gte_default_value ();

  //@}

  /**
   * @name lte
   *
   * @brief Accessor and modifier functions for the %lte
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse LteType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< LteType, char > LteTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const LteType&
  lte () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  LteType&
  lte ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  lte (const LteType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  lte (::std::unique_ptr< LteType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const LteType&
  lte_default_value ();

  //@}

  /**
   * @name min
   *
   * @brief Accessor and modifier functions for the %min
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MinType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MinType > MinOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MinType, char > MinTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MinOptional&
  min () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  MinOptional&
  min ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  min (const MinType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  min (const MinOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  min (::std::unique_ptr< MinType > p);

  //@}

  /**
   * @name max
   *
   * @brief Accessor and modifier functions for the %max
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MaxType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MaxType > MaxOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MaxOptional&
  max () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  MaxOptional&
  max ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  max (const MaxType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  max (const MaxOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  max (::std::unique_ptr< MaxType > p);

  //@}

  /**
   * @name path
   *
   * @brief Accessor and modifier functions for the %path
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String PathType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< PathType, char > PathTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const PathType&
  path () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  PathType&
  path ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  path (const PathType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  path (::std::unique_ptr< PathType > p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterFileType TypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const TypeType&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  TypeType&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const TypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< TypeType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const TypeType&
  type_default_value ();

  //@}

  /**
   * @name folder
   *
   * @brief Accessor and modifier functions for the %folder
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse FolderType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< FolderType, char > FolderTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const FolderType&
  folder () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  FolderType&
  folder ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  folder (const FolderType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  folder (::std::unique_ptr< FolderType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const FolderType&
  folder_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterFile (const BoolType&,
              const NotType&,
              const PathType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterFile (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterFile (const FilterFile& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterFile*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterFile&
  operator= (const FilterFile& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterFile ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< GteType > gte_;
  static const GteType gte_default_value_;
  ::xsd::cxx::tree::one< LteType > lte_;
  static const LteType lte_default_value_;
  MinOptional min_;
  MaxOptional max_;
  ::xsd::cxx::tree::one< PathType > path_;
  ::xsd::cxx::tree::one< TypeType > type_;
  static const TypeType type_default_value_;
  ::xsd::cxx::tree::one< FolderType > folder_;
  static const FolderType folder_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterIpRange schema type.
 *
 * @nosubgrouping
 */
class FilterIpRange: public ::IFilter
{
  public:
  /**
   * @name min
   *
   * @brief Accessor and modifier functions for the %min
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MinType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MinType, char > MinTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const MinType&
  min () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  MinType&
  min ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  min (const MinType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  min (::std::unique_ptr< MinType > p);

  //@}

  /**
   * @name max
   *
   * @brief Accessor and modifier functions for the %max
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MaxType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const MaxType&
  max () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  MaxType&
  max ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  max (const MaxType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  max (::std::unique_ptr< MaxType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterIpRange (const BoolType&,
                 const NotType&,
                 const MinType&,
                 const MaxType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterIpRange (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterIpRange (const FilterIpRange& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterIpRange*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterIpRange&
  operator= (const FilterIpRange& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterIpRange ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< MinType > min_;
  ::xsd::cxx::tree::one< MaxType > max_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterLanguage schema type.
 *
 * @nosubgrouping
 */
class FilterLanguage: public ::IFilter
{
  public:
  /**
   * @name default
   *
   * @brief Accessor and modifier functions for the %default
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse DefaultType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< DefaultType, char > DefaultTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const DefaultType&
  default_ () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  DefaultType&
  default_ ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  default_ (const DefaultType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  default_ (::std::unique_ptr< DefaultType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const DefaultType&
  default_default_value ();

  //@}

  /**
   * @name system
   *
   * @brief Accessor and modifier functions for the %system
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse SystemType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SystemType, char > SystemTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SystemType&
  system () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SystemType&
  system ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  system (const SystemType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  system (::std::unique_ptr< SystemType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const SystemType&
  system_default_value ();

  //@}

  /**
   * @name native
   *
   * @brief Accessor and modifier functions for the %native
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse NativeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NativeType, char > NativeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NativeType&
  native () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NativeType&
  native ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  native (const NativeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  native (::std::unique_ptr< NativeType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const NativeType&
  native_default_value ();

  //@}

  /**
   * @name displayName
   *
   * @brief Accessor and modifier functions for the %displayName
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String DisplayNameType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DisplayNameType > DisplayNameOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< DisplayNameType, char > DisplayNameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DisplayNameOptional&
  displayName () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  DisplayNameOptional&
  displayName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  displayName (const DisplayNameType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  displayName (const DisplayNameOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  displayName (::std::unique_ptr< DisplayNameType > p);

  //@}

  /**
   * @name language
   *
   * @brief Accessor and modifier functions for the %language
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::UnsignedByte LanguageType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< LanguageType, char > LanguageTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const LanguageType&
  language () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  LanguageType&
  language ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  language (const LanguageType& x);

  //@}

  /**
   * @name locale
   *
   * @brief Accessor and modifier functions for the %locale
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::UnsignedByte LocaleType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< LocaleType, char > LocaleTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const LocaleType&
  locale () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  LocaleType&
  locale ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  locale (const LocaleType& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterLanguage (const BoolType&,
                  const NotType&,
                  const LanguageType&,
                  const LocaleType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterLanguage (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterLanguage (const FilterLanguage& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterLanguage*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterLanguage&
  operator= (const FilterLanguage& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterLanguage ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< DefaultType > default__;
  static const DefaultType default__default_value_;
  ::xsd::cxx::tree::one< SystemType > system_;
  static const SystemType system_default_value_;
  ::xsd::cxx::tree::one< NativeType > native_;
  static const NativeType native_default_value_;
  DisplayNameOptional displayName_;
  ::xsd::cxx::tree::one< LanguageType > language_;
  ::xsd::cxx::tree::one< LocaleType > locale_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterMacRange schema type.
 *
 * @nosubgrouping
 */
class FilterMacRange: public ::IFilter
{
  public:
  /**
   * @name min
   *
   * @brief Accessor and modifier functions for the %min
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MinType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MinType, char > MinTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const MinType&
  min () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  MinType&
  min ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  min (const MinType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  min (::std::unique_ptr< MinType > p);

  //@}

  /**
   * @name max
   *
   * @brief Accessor and modifier functions for the %max
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MaxType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const MaxType&
  max () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  MaxType&
  max ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  max (const MaxType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  max (::std::unique_ptr< MaxType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterMacRange (const BoolType&,
                  const NotType&,
                  const MinType&,
                  const MaxType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterMacRange (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterMacRange (const FilterMacRange& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterMacRange*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterMacRange&
  operator= (const FilterMacRange& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterMacRange ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< MinType > min_;
  ::xsd::cxx::tree::one< MaxType > max_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterMsi schema type.
 *
 * @nosubgrouping
 */
class FilterMsi: public ::IFilter
{
  public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterMsiType TypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const TypeType&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  TypeType&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const TypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< TypeType > p);

  //@}

  /**
   * @name subtype
   *
   * @brief Accessor and modifier functions for the %subtype
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterMsiSubType SubtypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SubtypeType, char > SubtypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SubtypeType&
  subtype () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SubtypeType&
  subtype ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  subtype (const SubtypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  subtype (::std::unique_ptr< SubtypeType > p);

  //@}

  /**
   * @name code
   *
   * @brief Accessor and modifier functions for the %code
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String CodeType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< CodeType > CodeOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const CodeOptional&
  code () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  CodeOptional&
  code ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  code (const CodeType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  code (const CodeOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  code (::std::unique_ptr< CodeType > p);

  //@}

  /**
   * @name item
   *
   * @brief Accessor and modifier functions for the %item
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String ItemType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< ItemType > ItemOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ItemType, char > ItemTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ItemOptional&
  item () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  ItemOptional&
  item ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  item (const ItemType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  item (const ItemOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  item (::std::unique_ptr< ItemType > p);

  //@}

  /**
   * @name value
   *
   * @brief Accessor and modifier functions for the %value
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String ValueType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ValueOptional&
  value () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  ValueOptional&
  value ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  value (const ValueType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  value (const ValueOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  value (::std::unique_ptr< ValueType > p);

  //@}

  /**
   * @name min
   *
   * @brief Accessor and modifier functions for the %min
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MinType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MinType > MinOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MinType, char > MinTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MinOptional&
  min () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  MinOptional&
  min ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  min (const MinType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  min (const MinOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  min (::std::unique_ptr< MinType > p);

  //@}

  /**
   * @name max
   *
   * @brief Accessor and modifier functions for the %max
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MaxType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MaxType > MaxOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MaxOptional&
  max () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  MaxOptional&
  max ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  max (const MaxType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  max (const MaxOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  max (::std::unique_ptr< MaxType > p);

  //@}

  /**
   * @name gte
   *
   * @brief Accessor and modifier functions for the %gte
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse GteType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< GteType, char > GteTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const GteType&
  gte () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  GteType&
  gte ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  gte (const GteType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  gte (::std::unique_ptr< GteType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const GteType&
  gte_default_value ();

  //@}

  /**
   * @name lte
   *
   * @brief Accessor and modifier functions for the %lte
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse LteType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< LteType, char > LteTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const LteType&
  lte () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  LteType&
  lte ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  lte (const LteType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  lte (::std::unique_ptr< LteType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const LteType&
  lte_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterMsi (const BoolType&,
             const NotType&,
             const TypeType&,
             const SubtypeType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterMsi (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterMsi (const FilterMsi& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterMsi*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterMsi&
  operator= (const FilterMsi& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterMsi ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< TypeType > type_;
  ::xsd::cxx::tree::one< SubtypeType > subtype_;
  CodeOptional code_;
  ItemOptional item_;
  ValueOptional value_;
  MinOptional min_;
  MaxOptional max_;
  ::xsd::cxx::tree::one< GteType > gte_;
  static const GteType gte_default_value_;
  ::xsd::cxx::tree::one< LteType > lte_;
  static const LteType lte_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterOs schema type.
 *
 * @nosubgrouping
 */
class FilterOs: public ::IFilter
{
  public:
  /**
   * @name class
   *
   * @brief Accessor and modifier functions for the %class
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterOsClass ClassType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ClassType, char > ClassTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const ClassType&
  class_ () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  ClassType&
  class_ ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  class_ (const ClassType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  class_ (::std::unique_ptr< ClassType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const ClassType&
  class_default_value ();

  //@}

  /**
   * @name version
   *
   * @brief Accessor and modifier functions for the %version
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterOsVersion VersionType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< VersionType, char > VersionTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const VersionType&
  version () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  VersionType&
  version ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  version (const VersionType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  version (::std::unique_ptr< VersionType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const VersionType&
  version_default_value ();

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterOsType TypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const TypeType&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  TypeType&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const TypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< TypeType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const TypeType&
  type_default_value ();

  //@}

  /**
   * @name edition
   *
   * @brief Accessor and modifier functions for the %edition
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterOsEdition EditionType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< EditionType, char > EditionTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const EditionType&
  edition () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  EditionType&
  edition ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  edition (const EditionType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  edition (::std::unique_ptr< EditionType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const EditionType&
  edition_default_value ();

  //@}

  /**
   * @name sp
   *
   * @brief Accessor and modifier functions for the %sp
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterOsSp SpType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SpType, char > SpTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SpType&
  sp () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SpType&
  sp ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  sp (const SpType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  sp (::std::unique_ptr< SpType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const SpType&
  sp_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterOs (const BoolType&,
            const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterOs (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterOs (const FilterOs& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterOs*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterOs&
  operator= (const FilterOs& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterOs ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< ClassType > class__;
  static const ClassType class__default_value_;
  ::xsd::cxx::tree::one< VersionType > version_;
  static const VersionType version_default_value_;
  ::xsd::cxx::tree::one< TypeType > type_;
  static const TypeType type_default_value_;
  ::xsd::cxx::tree::one< EditionType > edition_;
  static const EditionType edition_default_value_;
  ::xsd::cxx::tree::one< SpType > sp_;
  static const SpType sp_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterOrgUnit schema type.
 *
 * @nosubgrouping
 */
class FilterOrgUnit: public ::IFilter
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String NameType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NameType&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NameType&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const NameType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< NameType > p);

  //@}

  /**
   * @name userContext
   *
   * @brief Accessor and modifier functions for the %userContext
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse UserContextType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< UserContextType, char > UserContextTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const UserContextType&
  userContext () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  UserContextType&
  userContext ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  userContext (const UserContextType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  userContext (::std::unique_ptr< UserContextType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const UserContextType&
  userContext_default_value ();

  //@}

  /**
   * @name directMember
   *
   * @brief Accessor and modifier functions for the %directMember
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse DirectMemberType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< DirectMemberType, char > DirectMemberTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const DirectMemberType&
  directMember () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  DirectMemberType&
  directMember ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  directMember (const DirectMemberType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  directMember (::std::unique_ptr< DirectMemberType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const DirectMemberType&
  directMember_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterOrgUnit (const BoolType&,
                 const NotType&,
                 const NameType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterOrgUnit (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterOrgUnit (const FilterOrgUnit& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterOrgUnit*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterOrgUnit&
  operator= (const FilterOrgUnit& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterOrgUnit ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< NameType > name_;
  ::xsd::cxx::tree::one< UserContextType > userContext_;
  static const UserContextType userContext_default_value_;
  ::xsd::cxx::tree::one< DirectMemberType > directMember_;
  static const DirectMemberType directMember_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterPcmcia schema type.
 *
 * @nosubgrouping
 */
class FilterPcmcia: public ::IFilter
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterPcmcia (const BoolType&,
                const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterPcmcia (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterPcmcia (const FilterPcmcia& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterPcmcia*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterPcmcia ();
};

/**
 * @brief Class corresponding to the %FilterPortable schema type.
 *
 * @nosubgrouping
 */
class FilterPortable: public ::IFilter
{
  public:
  /**
   * @name unknown
   *
   * @brief Accessor and modifier functions for the %unknown
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse UnknownType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< UnknownType, char > UnknownTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const UnknownType&
  unknown () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  UnknownType&
  unknown ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  unknown (const UnknownType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  unknown (::std::unique_ptr< UnknownType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const UnknownType&
  unknown_default_value ();

  //@}

  /**
   * @name docked
   *
   * @brief Accessor and modifier functions for the %docked
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse DockedType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< DockedType, char > DockedTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const DockedType&
  docked () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  DockedType&
  docked ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  docked (const DockedType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  docked (::std::unique_ptr< DockedType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const DockedType&
  docked_default_value ();

  //@}

  /**
   * @name undocked
   *
   * @brief Accessor and modifier functions for the %undocked
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse UndockedType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< UndockedType, char > UndockedTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const UndockedType&
  undocked () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  UndockedType&
  undocked ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  undocked (const UndockedType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  undocked (::std::unique_ptr< UndockedType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const UndockedType&
  undocked_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterPortable (const BoolType&,
                  const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterPortable (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterPortable (const FilterPortable& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterPortable*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterPortable&
  operator= (const FilterPortable& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterPortable ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< UnknownType > unknown_;
  static const UnknownType unknown_default_value_;
  ::xsd::cxx::tree::one< DockedType > docked_;
  static const DockedType docked_default_value_;
  ::xsd::cxx::tree::one< UndockedType > undocked_;
  static const UndockedType undocked_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterProcMode schema type.
 *
 * @nosubgrouping
 */
class FilterProcMode: public ::IFilter
{
  public:
  /**
   * @name synchFore
   *
   * @brief Accessor and modifier functions for the %synchFore
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse SynchForeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SynchForeType, char > SynchForeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SynchForeType&
  synchFore () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SynchForeType&
  synchFore ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  synchFore (const SynchForeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  synchFore (::std::unique_ptr< SynchForeType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const SynchForeType&
  synchFore_default_value ();

  //@}

  /**
   * @name asynchFore
   *
   * @brief Accessor and modifier functions for the %asynchFore
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse AsynchForeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< AsynchForeType, char > AsynchForeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const AsynchForeType&
  asynchFore () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  AsynchForeType&
  asynchFore ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  asynchFore (const AsynchForeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  asynchFore (::std::unique_ptr< AsynchForeType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const AsynchForeType&
  asynchFore_default_value ();

  //@}

  /**
   * @name backRefr
   *
   * @brief Accessor and modifier functions for the %backRefr
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse BackRefrType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< BackRefrType, char > BackRefrTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const BackRefrType&
  backRefr () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  BackRefrType&
  backRefr ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  backRefr (const BackRefrType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  backRefr (::std::unique_ptr< BackRefrType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const BackRefrType&
  backRefr_default_value ();

  //@}

  /**
   * @name forceRefr
   *
   * @brief Accessor and modifier functions for the %forceRefr
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse ForceRefrType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ForceRefrType, char > ForceRefrTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const ForceRefrType&
  forceRefr () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  ForceRefrType&
  forceRefr ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  forceRefr (const ForceRefrType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  forceRefr (::std::unique_ptr< ForceRefrType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const ForceRefrType&
  forceRefr_default_value ();

  //@}

  /**
   * @name linkTrns
   *
   * @brief Accessor and modifier functions for the %linkTrns
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse LinkTrnsType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< LinkTrnsType, char > LinkTrnsTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const LinkTrnsType&
  linkTrns () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  LinkTrnsType&
  linkTrns ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  linkTrns (const LinkTrnsType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  linkTrns (::std::unique_ptr< LinkTrnsType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const LinkTrnsType&
  linkTrns_default_value ();

  //@}

  /**
   * @name noChg
   *
   * @brief Accessor and modifier functions for the %noChg
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse NoChgType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NoChgType, char > NoChgTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NoChgType&
  noChg () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NoChgType&
  noChg ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  noChg (const NoChgType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  noChg (::std::unique_ptr< NoChgType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const NoChgType&
  noChg_default_value ();

  //@}

  /**
   * @name rsopTrns
   *
   * @brief Accessor and modifier functions for the %rsopTrns
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse RsopTrnsType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< RsopTrnsType, char > RsopTrnsTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const RsopTrnsType&
  rsopTrns () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  RsopTrnsType&
  rsopTrns ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  rsopTrns (const RsopTrnsType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  rsopTrns (::std::unique_ptr< RsopTrnsType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const RsopTrnsType&
  rsopTrns_default_value ();

  //@}

  /**
   * @name safeBoot
   *
   * @brief Accessor and modifier functions for the %safeBoot
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse SafeBootType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SafeBootType, char > SafeBootTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SafeBootType&
  safeBoot () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SafeBootType&
  safeBoot ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  safeBoot (const SafeBootType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  safeBoot (::std::unique_ptr< SafeBootType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const SafeBootType&
  safeBoot_default_value ();

  //@}

  /**
   * @name slowLink
   *
   * @brief Accessor and modifier functions for the %slowLink
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse SlowLinkType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SlowLinkType, char > SlowLinkTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SlowLinkType&
  slowLink () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SlowLinkType&
  slowLink ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  slowLink (const SlowLinkType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  slowLink (::std::unique_ptr< SlowLinkType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const SlowLinkType&
  slowLink_default_value ();

  //@}

  /**
   * @name verbLog
   *
   * @brief Accessor and modifier functions for the %verbLog
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse VerbLogType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< VerbLogType, char > VerbLogTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const VerbLogType&
  verbLog () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  VerbLogType&
  verbLog ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  verbLog (const VerbLogType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  verbLog (::std::unique_ptr< VerbLogType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const VerbLogType&
  verbLog_default_value ();

  //@}

  /**
   * @name rsopEnbl
   *
   * @brief Accessor and modifier functions for the %rsopEnbl
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse RsopEnblType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< RsopEnblType, char > RsopEnblTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const RsopEnblType&
  rsopEnbl () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  RsopEnblType&
  rsopEnbl ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  rsopEnbl (const RsopEnblType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  rsopEnbl (::std::unique_ptr< RsopEnblType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const RsopEnblType&
  rsopEnbl_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterProcMode (const BoolType&,
                  const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterProcMode (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterProcMode (const FilterProcMode& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterProcMode*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterProcMode&
  operator= (const FilterProcMode& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterProcMode ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< SynchForeType > synchFore_;
  static const SynchForeType synchFore_default_value_;
  ::xsd::cxx::tree::one< AsynchForeType > asynchFore_;
  static const AsynchForeType asynchFore_default_value_;
  ::xsd::cxx::tree::one< BackRefrType > backRefr_;
  static const BackRefrType backRefr_default_value_;
  ::xsd::cxx::tree::one< ForceRefrType > forceRefr_;
  static const ForceRefrType forceRefr_default_value_;
  ::xsd::cxx::tree::one< LinkTrnsType > linkTrns_;
  static const LinkTrnsType linkTrns_default_value_;
  ::xsd::cxx::tree::one< NoChgType > noChg_;
  static const NoChgType noChg_default_value_;
  ::xsd::cxx::tree::one< RsopTrnsType > rsopTrns_;
  static const RsopTrnsType rsopTrns_default_value_;
  ::xsd::cxx::tree::one< SafeBootType > safeBoot_;
  static const SafeBootType safeBoot_default_value_;
  ::xsd::cxx::tree::one< SlowLinkType > slowLink_;
  static const SlowLinkType slowLink_default_value_;
  ::xsd::cxx::tree::one< VerbLogType > verbLog_;
  static const VerbLogType verbLog_default_value_;
  ::xsd::cxx::tree::one< RsopEnblType > rsopEnbl_;
  static const RsopEnblType rsopEnbl_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterRam schema type.
 *
 * @nosubgrouping
 */
class FilterRam: public ::IFilter
{
  public:
  /**
   * @name totalMB
   *
   * @brief Accessor and modifier functions for the %totalMB
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::UnsignedShort TotalMBType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< TotalMBType, char > TotalMBTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const TotalMBType&
  totalMB () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  TotalMBType&
  totalMB ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  totalMB (const TotalMBType& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterRam (const BoolType&,
             const NotType&,
             const TotalMBType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterRam (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterRam (const FilterRam& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterRam*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterRam&
  operator= (const FilterRam& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterRam ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< TotalMBType > totalMB_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterRegistry schema type.
 *
 * @nosubgrouping
 */
class FilterRegistry: public ::IFilter
{
  public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterRegistryType TypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const TypeType&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  TypeType&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const TypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< TypeType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const TypeType&
  type_default_value ();

  //@}

  /**
   * @name subtype
   *
   * @brief Accessor and modifier functions for the %subtype
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterRegistrySubType SubtypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SubtypeType, char > SubtypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const SubtypeType&
  subtype () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  SubtypeType&
  subtype ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  subtype (const SubtypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  subtype (::std::unique_ptr< SubtypeType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const SubtypeType&
  subtype_default_value ();

  //@}

  /**
   * @name valueName
   *
   * @brief Accessor and modifier functions for the %valueName
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String ValueNameType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< ValueNameType > ValueNameOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ValueNameOptional&
  valueName () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  ValueNameOptional&
  valueName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  valueName (const ValueNameType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  valueName (const ValueNameOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  valueName (::std::unique_ptr< ValueNameType > p);

  //@}

  /**
   * @name valueType
   *
   * @brief Accessor and modifier functions for the %valueType
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterRegistryValueType ValueTypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ValueTypeType, char > ValueTypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const ValueTypeType&
  valueType () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  ValueTypeType&
  valueType ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  valueType (const ValueTypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  valueType (::std::unique_ptr< ValueTypeType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const ValueTypeType&
  valueType_default_value ();

  //@}

  /**
   * @name valueData
   *
   * @brief Accessor and modifier functions for the %valueData
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String ValueDataType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< ValueDataType > ValueDataOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ValueDataType, char > ValueDataTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ValueDataOptional&
  valueData () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  ValueDataOptional&
  valueData ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  valueData (const ValueDataType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  valueData (const ValueDataOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  valueData (::std::unique_ptr< ValueDataType > p);

  //@}

  /**
   * @name variableName
   *
   * @brief Accessor and modifier functions for the %variableName
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String VariableNameType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< VariableNameType > VariableNameOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< VariableNameType, char > VariableNameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const VariableNameOptional&
  variableName () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  VariableNameOptional&
  variableName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  variableName (const VariableNameType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  variableName (const VariableNameOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  variableName (::std::unique_ptr< VariableNameType > p);

  //@}

  /**
   * @name key
   *
   * @brief Accessor and modifier functions for the %key
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String KeyType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const KeyType&
  key () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  KeyType&
  key ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  key (const KeyType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  key (::std::unique_ptr< KeyType > p);

  //@}

  /**
   * @name hive
   *
   * @brief Accessor and modifier functions for the %hive
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterRegistryHive HiveType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< HiveType, char > HiveTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const HiveType&
  hive () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  HiveType&
  hive ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  hive (const HiveType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  hive (::std::unique_ptr< HiveType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const HiveType&
  hive_default_value ();

  //@}

  /**
   * @name min
   *
   * @brief Accessor and modifier functions for the %min
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MinType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MinType > MinOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MinType, char > MinTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MinOptional&
  min () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  MinOptional&
  min ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  min (const MinType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  min (const MinOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  min (::std::unique_ptr< MinType > p);

  //@}

  /**
   * @name max
   *
   * @brief Accessor and modifier functions for the %max
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MaxType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MaxType > MaxOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MaxOptional&
  max () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  MaxOptional&
  max ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  max (const MaxType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  max (const MaxOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  max (::std::unique_ptr< MaxType > p);

  //@}

  /**
   * @name gte
   *
   * @brief Accessor and modifier functions for the %gte
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse GteType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< GteType, char > GteTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const GteType&
  gte () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  GteType&
  gte ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  gte (const GteType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  gte (::std::unique_ptr< GteType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const GteType&
  gte_default_value ();

  //@}

  /**
   * @name lte
   *
   * @brief Accessor and modifier functions for the %lte
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumTrueFalse LteType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< LteType, char > LteTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const LteType&
  lte () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  LteType&
  lte ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  lte (const LteType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  lte (::std::unique_ptr< LteType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const LteType&
  lte_default_value ();

  //@}

  /**
   * @name version
   *
   * @brief Accessor and modifier functions for the %version
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String VersionType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< VersionType > VersionOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< VersionType, char > VersionTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const VersionOptional&
  version () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  VersionOptional&
  version ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  version (const VersionType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  version (const VersionOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  version (::std::unique_ptr< VersionType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterRegistry (const BoolType&,
                  const NotType&,
                  const KeyType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterRegistry (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterRegistry (const FilterRegistry& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterRegistry*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterRegistry&
  operator= (const FilterRegistry& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterRegistry ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< TypeType > type_;
  static const TypeType type_default_value_;
  ::xsd::cxx::tree::one< SubtypeType > subtype_;
  static const SubtypeType subtype_default_value_;
  ValueNameOptional valueName_;
  ::xsd::cxx::tree::one< ValueTypeType > valueType_;
  static const ValueTypeType valueType_default_value_;
  ValueDataOptional valueData_;
  VariableNameOptional variableName_;
  ::xsd::cxx::tree::one< KeyType > key_;
  ::xsd::cxx::tree::one< HiveType > hive_;
  static const HiveType hive_default_value_;
  MinOptional min_;
  MaxOptional max_;
  ::xsd::cxx::tree::one< GteType > gte_;
  static const GteType gte_default_value_;
  ::xsd::cxx::tree::one< LteType > lte_;
  static const LteType lte_default_value_;
  VersionOptional version_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterTerminal schema type.
 *
 * @nosubgrouping
 */
class FilterTerminal: public ::IFilter
{
  public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterTerminalType TypeType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const TypeType&
  type () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  TypeType&
  type ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  type (const TypeType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  type (::std::unique_ptr< TypeType > p);

  //@}

  /**
   * @name option
   *
   * @brief Accessor and modifier functions for the %option
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::EnumFilterTerminalOption OptionType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< OptionType, char > OptionTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const OptionType&
  option () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  OptionType&
  option ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  option (const OptionType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  option (::std::unique_ptr< OptionType > p);

  //@}

  /**
   * @name value
   *
   * @brief Accessor and modifier functions for the %value
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String ValueType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const ValueType&
  value () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  ValueType&
  value ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  value (const ValueType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  value (::std::unique_ptr< ValueType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const ValueType&
  value_default_value ();

  //@}

  /**
   * @name min
   *
   * @brief Accessor and modifier functions for the %min
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MinType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MinType, char > MinTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const MinType&
  min () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  MinType&
  min ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  min (const MinType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  min (::std::unique_ptr< MinType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const MinType&
  min_default_value ();

  //@}

  /**
   * @name max
   *
   * @brief Accessor and modifier functions for the %max
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String MaxType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const MaxType&
  max () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  MaxType&
  max ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  max (const MaxType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  max (::std::unique_ptr< MaxType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const MaxType&
  max_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterTerminal (const BoolType&,
                  const NotType&,
                  const TypeType&,
                  const OptionType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterTerminal (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterTerminal (const FilterTerminal& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterTerminal*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterTerminal&
  operator= (const FilterTerminal& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterTerminal ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< TypeType > type_;
  ::xsd::cxx::tree::one< OptionType > option_;
  ::xsd::cxx::tree::one< ValueType > value_;
  static const ValueType value_default_value_;
  ::xsd::cxx::tree::one< MinType > min_;
  static const MinType min_default_value_;
  ::xsd::cxx::tree::one< MaxType > max_;
  static const MaxType max_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterTime schema type.
 *
 * @nosubgrouping
 */
class FilterTime: public ::IFilter
{
  public:
  /**
   * @name begin
   *
   * @brief Accessor and modifier functions for the %begin
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::Time BeginType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< BeginType, char > BeginTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const BeginType&
  begin () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  BeginType&
  begin ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  begin (const BeginType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  begin (::std::unique_ptr< BeginType > p);

  //@}

  /**
   * @name end
   *
   * @brief Accessor and modifier functions for the %end
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::Time EndType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< EndType, char > EndTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const EndType&
  end () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  EndType&
  end ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  end (const EndType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  end (::std::unique_ptr< EndType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterTime (const BoolType&,
              const NotType&,
              const BeginType&,
              const EndType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterTime (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterTime (const FilterTime& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterTime*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterTime&
  operator= (const FilterTime& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterTime ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< BeginType > begin_;
  ::xsd::cxx::tree::one< EndType > end_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterUser schema type.
 *
 * @nosubgrouping
 */
class FilterUser: public ::IFilter
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String NameType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const NameOptional&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  NameOptional&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const NameType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  name (const NameOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  name (::std::unique_ptr< NameType > p);

  //@}

  /**
   * @name sid
   *
   * @brief Accessor and modifier functions for the %sid
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String SidType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< SidType > SidOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< SidType, char > SidTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const SidOptional&
  sid () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  SidOptional&
  sid ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  sid (const SidType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  sid (const SidOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  sid (::std::unique_ptr< SidType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterUser (const BoolType&,
              const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterUser (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterUser (const FilterUser& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterUser*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterUser&
  operator= (const FilterUser& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterUser ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  NameOptional name_;
  SidOptional sid_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterWmi schema type.
 *
 * @nosubgrouping
 */
class FilterWmi: public ::IFilter
{
  public:
  /**
   * @name query
   *
   * @brief Accessor and modifier functions for the %query
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String QueryType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< QueryType, char > QueryTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const QueryType&
  query () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  QueryType&
  query ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  query (const QueryType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  query (::std::unique_ptr< QueryType > p);

  //@}

  /**
   * @name nameSpace
   *
   * @brief Accessor and modifier functions for the %nameSpace
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String NameSpaceType;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NameSpaceType, char > NameSpaceTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const NameSpaceType&
  nameSpace () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  NameSpaceType&
  nameSpace ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  nameSpace (const NameSpaceType& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  nameSpace (::std::unique_ptr< NameSpaceType > p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const NameSpaceType&
  nameSpace_default_value ();

  //@}

  /**
   * @name property
   *
   * @brief Accessor and modifier functions for the %property
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String PropertyType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< PropertyType > PropertyOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< PropertyType, char > PropertyTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const PropertyOptional&
  property () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  PropertyOptional&
  property ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  property (const PropertyType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  property (const PropertyOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  property (::std::unique_ptr< PropertyType > p);

  //@}

  /**
   * @name variableName
   *
   * @brief Accessor and modifier functions for the %variableName
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String VariableNameType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< VariableNameType > VariableNameOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< VariableNameType, char > VariableNameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const VariableNameOptional&
  variableName () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  VariableNameOptional&
  variableName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  variableName (const VariableNameType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  variableName (const VariableNameOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  variableName (::std::unique_ptr< VariableNameType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterWmi (const BoolType&,
             const NotType&,
             const QueryType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterWmi (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterWmi (const FilterWmi& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterWmi*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterWmi&
  operator= (const FilterWmi& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterWmi ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ::xsd::cxx::tree::one< QueryType > query_;
  ::xsd::cxx::tree::one< NameSpaceType > nameSpace_;
  static const NameSpaceType nameSpace_default_value_;
  PropertyOptional property_;
  VariableNameOptional variableName_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FilterCollection schema type.
 *
 * @nosubgrouping
 */
class FilterCollection: public ::IFilter
{
  public:
  /**
   * @name FilterSite
   *
   * @brief Accessor and modifier functions for the %FilterSite
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterSite FilterSiteType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterSiteType > FilterSiteSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterSiteSequence::iterator FilterSiteIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterSiteSequence::const_iterator FilterSiteConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterSiteType, char > FilterSiteTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterSiteSequence&
  FilterSite () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterSiteSequence&
  FilterSite ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterSite (const FilterSiteSequence& s);

  //@}

  /**
   * @name FilterGroup
   *
   * @brief Accessor and modifier functions for the %FilterGroup
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterGroup FilterGroupType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterGroupType > FilterGroupSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterGroupSequence::iterator FilterGroupIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterGroupSequence::const_iterator FilterGroupConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterGroupType, char > FilterGroupTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterGroupSequence&
  FilterGroup () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterGroupSequence&
  FilterGroup ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterGroup (const FilterGroupSequence& s);

  //@}

  /**
   * @name FilterRunOnce
   *
   * @brief Accessor and modifier functions for the %FilterRunOnce
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterRunOnce FilterRunOnceType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterRunOnceType > FilterRunOnceSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterRunOnceSequence::iterator FilterRunOnceIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterRunOnceSequence::const_iterator FilterRunOnceConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterRunOnceType, char > FilterRunOnceTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterRunOnceSequence&
  FilterRunOnce () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterRunOnceSequence&
  FilterRunOnce ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterRunOnce (const FilterRunOnceSequence& s);

  //@}

  /**
   * @name FilterLdap
   *
   * @brief Accessor and modifier functions for the %FilterLdap
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterLdap FilterLdapType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterLdapType > FilterLdapSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterLdapSequence::iterator FilterLdapIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterLdapSequence::const_iterator FilterLdapConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterLdapType, char > FilterLdapTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterLdapSequence&
  FilterLdap () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterLdapSequence&
  FilterLdap ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterLdap (const FilterLdapSequence& s);

  //@}

  /**
   * @name FilterBattery
   *
   * @brief Accessor and modifier functions for the %FilterBattery
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterBattery FilterBatteryType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterBatteryType > FilterBatterySequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterBatterySequence::iterator FilterBatteryIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterBatterySequence::const_iterator FilterBatteryConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterBatteryType, char > FilterBatteryTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterBatterySequence&
  FilterBattery () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterBatterySequence&
  FilterBattery ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterBattery (const FilterBatterySequence& s);

  //@}

  /**
   * @name FilterComputer
   *
   * @brief Accessor and modifier functions for the %FilterComputer
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterComputer FilterComputerType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterComputerType > FilterComputerSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterComputerSequence::iterator FilterComputerIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterComputerSequence::const_iterator FilterComputerConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterComputerType, char > FilterComputerTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterComputerSequence&
  FilterComputer () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterComputerSequence&
  FilterComputer ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterComputer (const FilterComputerSequence& s);

  //@}

  /**
   * @name FilterCpu
   *
   * @brief Accessor and modifier functions for the %FilterCpu
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterCpu FilterCpuType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterCpuType > FilterCpuSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterCpuSequence::iterator FilterCpuIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterCpuSequence::const_iterator FilterCpuConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterCpuType, char > FilterCpuTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterCpuSequence&
  FilterCpu () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterCpuSequence&
  FilterCpu ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterCpu (const FilterCpuSequence& s);

  //@}

  /**
   * @name FilterDate
   *
   * @brief Accessor and modifier functions for the %FilterDate
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterDate FilterDateType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterDateType > FilterDateSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterDateSequence::iterator FilterDateIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterDateSequence::const_iterator FilterDateConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterDateType, char > FilterDateTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterDateSequence&
  FilterDate () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterDateSequence&
  FilterDate ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterDate (const FilterDateSequence& s);

  //@}

  /**
   * @name FilterDun
   *
   * @brief Accessor and modifier functions for the %FilterDun
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterDun FilterDunType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterDunType > FilterDunSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterDunSequence::iterator FilterDunIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterDunSequence::const_iterator FilterDunConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterDunType, char > FilterDunTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterDunSequence&
  FilterDun () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterDunSequence&
  FilterDun ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterDun (const FilterDunSequence& s);

  //@}

  /**
   * @name FilterDisk
   *
   * @brief Accessor and modifier functions for the %FilterDisk
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterDisk FilterDiskType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterDiskType > FilterDiskSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterDiskSequence::iterator FilterDiskIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterDiskSequence::const_iterator FilterDiskConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterDiskType, char > FilterDiskTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterDiskSequence&
  FilterDisk () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterDiskSequence&
  FilterDisk ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterDisk (const FilterDiskSequence& s);

  //@}

  /**
   * @name FilterDomain
   *
   * @brief Accessor and modifier functions for the %FilterDomain
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterDomain FilterDomainType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterDomainType > FilterDomainSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterDomainSequence::iterator FilterDomainIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterDomainSequence::const_iterator FilterDomainConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterDomainType, char > FilterDomainTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterDomainSequence&
  FilterDomain () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterDomainSequence&
  FilterDomain ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterDomain (const FilterDomainSequence& s);

  //@}

  /**
   * @name FilterVariable
   *
   * @brief Accessor and modifier functions for the %FilterVariable
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterVariable FilterVariableType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterVariableType > FilterVariableSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterVariableSequence::iterator FilterVariableIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterVariableSequence::const_iterator FilterVariableConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterVariableType, char > FilterVariableTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterVariableSequence&
  FilterVariable () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterVariableSequence&
  FilterVariable ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterVariable (const FilterVariableSequence& s);

  //@}

  /**
   * @name FilterFile
   *
   * @brief Accessor and modifier functions for the %FilterFile
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterFile FilterFileType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterFileType > FilterFileSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterFileSequence::iterator FilterFileIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterFileSequence::const_iterator FilterFileConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterFileType, char > FilterFileTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterFileSequence&
  FilterFile () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterFileSequence&
  FilterFile ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterFile (const FilterFileSequence& s);

  //@}

  /**
   * @name FilterIpRange
   *
   * @brief Accessor and modifier functions for the %FilterIpRange
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterIpRange FilterIpRangeType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterIpRangeType > FilterIpRangeSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterIpRangeSequence::iterator FilterIpRangeIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterIpRangeSequence::const_iterator FilterIpRangeConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterIpRangeType, char > FilterIpRangeTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterIpRangeSequence&
  FilterIpRange () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterIpRangeSequence&
  FilterIpRange ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterIpRange (const FilterIpRangeSequence& s);

  //@}

  /**
   * @name FilterLanguage
   *
   * @brief Accessor and modifier functions for the %FilterLanguage
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterLanguage FilterLanguageType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterLanguageType > FilterLanguageSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterLanguageSequence::iterator FilterLanguageIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterLanguageSequence::const_iterator FilterLanguageConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterLanguageType, char > FilterLanguageTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterLanguageSequence&
  FilterLanguage () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterLanguageSequence&
  FilterLanguage ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterLanguage (const FilterLanguageSequence& s);

  //@}

  /**
   * @name FilterMacRange
   *
   * @brief Accessor and modifier functions for the %FilterMacRange
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterMacRange FilterMacRangeType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterMacRangeType > FilterMacRangeSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterMacRangeSequence::iterator FilterMacRangeIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterMacRangeSequence::const_iterator FilterMacRangeConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterMacRangeType, char > FilterMacRangeTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterMacRangeSequence&
  FilterMacRange () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterMacRangeSequence&
  FilterMacRange ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterMacRange (const FilterMacRangeSequence& s);

  //@}

  /**
   * @name FilterMsi
   *
   * @brief Accessor and modifier functions for the %FilterMsi
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterMsi FilterMsiType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterMsiType > FilterMsiSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterMsiSequence::iterator FilterMsiIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterMsiSequence::const_iterator FilterMsiConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterMsiType, char > FilterMsiTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterMsiSequence&
  FilterMsi () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterMsiSequence&
  FilterMsi ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterMsi (const FilterMsiSequence& s);

  //@}

  /**
   * @name FilterOs
   *
   * @brief Accessor and modifier functions for the %FilterOs
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterOs FilterOsType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterOsType > FilterOsSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterOsSequence::iterator FilterOsIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterOsSequence::const_iterator FilterOsConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterOsType, char > FilterOsTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterOsSequence&
  FilterOs () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterOsSequence&
  FilterOs ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterOs (const FilterOsSequence& s);

  //@}

  /**
   * @name FilterOrgUnit
   *
   * @brief Accessor and modifier functions for the %FilterOrgUnit
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterOrgUnit FilterOrgUnitType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterOrgUnitType > FilterOrgUnitSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterOrgUnitSequence::iterator FilterOrgUnitIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterOrgUnitSequence::const_iterator FilterOrgUnitConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterOrgUnitType, char > FilterOrgUnitTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterOrgUnitSequence&
  FilterOrgUnit () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterOrgUnitSequence&
  FilterOrgUnit ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterOrgUnit (const FilterOrgUnitSequence& s);

  //@}

  /**
   * @name FilterPcmcia
   *
   * @brief Accessor and modifier functions for the %FilterPcmcia
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterPcmcia FilterPcmciaType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterPcmciaType > FilterPcmciaSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterPcmciaSequence::iterator FilterPcmciaIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterPcmciaSequence::const_iterator FilterPcmciaConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterPcmciaType, char > FilterPcmciaTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterPcmciaSequence&
  FilterPcmcia () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterPcmciaSequence&
  FilterPcmcia ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterPcmcia (const FilterPcmciaSequence& s);

  //@}

  /**
   * @name FilterPortable
   *
   * @brief Accessor and modifier functions for the %FilterPortable
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterPortable FilterPortableType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterPortableType > FilterPortableSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterPortableSequence::iterator FilterPortableIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterPortableSequence::const_iterator FilterPortableConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterPortableType, char > FilterPortableTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterPortableSequence&
  FilterPortable () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterPortableSequence&
  FilterPortable ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterPortable (const FilterPortableSequence& s);

  //@}

  /**
   * @name FilterProcMode
   *
   * @brief Accessor and modifier functions for the %FilterProcMode
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterProcMode FilterProcModeType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterProcModeType > FilterProcModeSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterProcModeSequence::iterator FilterProcModeIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterProcModeSequence::const_iterator FilterProcModeConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterProcModeType, char > FilterProcModeTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterProcModeSequence&
  FilterProcMode () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterProcModeSequence&
  FilterProcMode ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterProcMode (const FilterProcModeSequence& s);

  //@}

  /**
   * @name FilterRam
   *
   * @brief Accessor and modifier functions for the %FilterRam
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterRam FilterRamType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterRamType > FilterRamSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterRamSequence::iterator FilterRamIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterRamSequence::const_iterator FilterRamConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterRamType, char > FilterRamTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterRamSequence&
  FilterRam () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterRamSequence&
  FilterRam ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterRam (const FilterRamSequence& s);

  //@}

  /**
   * @name FilterRegistry
   *
   * @brief Accessor and modifier functions for the %FilterRegistry
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterRegistry FilterRegistryType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterRegistryType > FilterRegistrySequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterRegistrySequence::iterator FilterRegistryIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterRegistrySequence::const_iterator FilterRegistryConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterRegistryType, char > FilterRegistryTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterRegistrySequence&
  FilterRegistry () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterRegistrySequence&
  FilterRegistry ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterRegistry (const FilterRegistrySequence& s);

  //@}

  /**
   * @name FilterTerminal
   *
   * @brief Accessor and modifier functions for the %FilterTerminal
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterTerminal FilterTerminalType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterTerminalType > FilterTerminalSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterTerminalSequence::iterator FilterTerminalIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterTerminalSequence::const_iterator FilterTerminalConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterTerminalType, char > FilterTerminalTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterTerminalSequence&
  FilterTerminal () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterTerminalSequence&
  FilterTerminal ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterTerminal (const FilterTerminalSequence& s);

  //@}

  /**
   * @name FilterTime
   *
   * @brief Accessor and modifier functions for the %FilterTime
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterTime FilterTimeType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterTimeType > FilterTimeSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterTimeSequence::iterator FilterTimeIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterTimeSequence::const_iterator FilterTimeConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterTimeType, char > FilterTimeTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterTimeSequence&
  FilterTime () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterTimeSequence&
  FilterTime ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterTime (const FilterTimeSequence& s);

  //@}

  /**
   * @name FilterUser
   *
   * @brief Accessor and modifier functions for the %FilterUser
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterUser FilterUserType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterUserType > FilterUserSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterUserSequence::iterator FilterUserIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterUserSequence::const_iterator FilterUserConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterUserType, char > FilterUserTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterUserSequence&
  FilterUser () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterUserSequence&
  FilterUser ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterUser (const FilterUserSequence& s);

  //@}

  /**
   * @name FilterWmi
   *
   * @brief Accessor and modifier functions for the %FilterWmi
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterWmi FilterWmiType;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterWmiType > FilterWmiSequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterWmiSequence::iterator FilterWmiIterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterWmiSequence::const_iterator FilterWmiConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterWmiType, char > FilterWmiTraits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterWmiSequence&
  FilterWmi () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterWmiSequence&
  FilterWmi ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterWmi (const FilterWmiSequence& s);

  //@}

  /**
   * @name FilterCollection
   *
   * @brief Accessor and modifier functions for the %FilterCollection
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FilterCollection FilterCollection1Type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< FilterCollection1Type > FilterCollection1Sequence;

  /**
   * @brief Element iterator type.
   */
  typedef FilterCollection1Sequence::iterator FilterCollection1Iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef FilterCollection1Sequence::const_iterator FilterCollection1ConstIterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< FilterCollection1Type, char > FilterCollection1Traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const FilterCollection1Sequence&
  FilterCollection1 () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  FilterCollection1Sequence&
  FilterCollection1 ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  FilterCollection1 (const FilterCollection1Sequence& s);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::String NameType;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const NameOptional&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  NameOptional&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const NameType& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  name (const NameOptional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  name (::std::unique_ptr< NameType > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FilterCollection (const BoolType&,
                    const NotType&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FilterCollection (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterCollection (const FilterCollection& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FilterCollection*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FilterCollection&
  operator= (const FilterCollection& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FilterCollection ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  FilterSiteSequence FilterSite_;
  FilterGroupSequence FilterGroup_;
  FilterRunOnceSequence FilterRunOnce_;
  FilterLdapSequence FilterLdap_;
  FilterBatterySequence FilterBattery_;
  FilterComputerSequence FilterComputer_;
  FilterCpuSequence FilterCpu_;
  FilterDateSequence FilterDate_;
  FilterDunSequence FilterDun_;
  FilterDiskSequence FilterDisk_;
  FilterDomainSequence FilterDomain_;
  FilterVariableSequence FilterVariable_;
  FilterFileSequence FilterFile_;
  FilterIpRangeSequence FilterIpRange_;
  FilterLanguageSequence FilterLanguage_;
  FilterMacRangeSequence FilterMacRange_;
  FilterMsiSequence FilterMsi_;
  FilterOsSequence FilterOs_;
  FilterOrgUnitSequence FilterOrgUnit_;
  FilterPcmciaSequence FilterPcmcia_;
  FilterPortableSequence FilterPortable_;
  FilterProcModeSequence FilterProcMode_;
  FilterRamSequence FilterRam_;
  FilterRegistrySequence FilterRegistry_;
  FilterTerminalSequence FilterTerminal_;
  FilterTimeSequence FilterTime_;
  FilterUserSequence FilterUser_;
  FilterWmiSequence FilterWmi_;
  FilterCollection1Sequence FilterCollection1_;
  NameOptional name_;

  //@endcond
};

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, EnumFilterTerminalOption::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterTerminalOption&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterTerminalType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterTerminalType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterRegistryHive::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterRegistryHive&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterRegistryValueType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterRegistryValueType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterRegistrySubType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterRegistrySubType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterRegistryType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterRegistryType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterOsSp::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterOsSp&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterOsEdition::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterOsEdition&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterOsType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterOsType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterOsVersion::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterOsVersion&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterOsClass::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterOsClass&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterMsiSubType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterMsiSubType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterMsiType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterMsiType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterFileType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterFileType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterDunType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterDunType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterDateDow::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterDateDow&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterDatePeriod::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterDatePeriod&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterComputerNameType::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterComputerNameType&);

::std::ostream&
operator<< (::std::ostream&, EnumFilterBool::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumFilterBool&);

::std::ostream&
operator<< (::std::ostream&, EnumTrueFalse::Value);

::std::ostream&
operator<< (::std::ostream&, const EnumTrueFalse&);

::std::ostream&
operator<< (::std::ostream&, const IFilter&);

::std::ostream&
operator<< (::std::ostream&, const Filters_t&);

::std::ostream&
operator<< (::std::ostream&, const FilterSite&);

::std::ostream&
operator<< (::std::ostream&, const FilterGroup&);

::std::ostream&
operator<< (::std::ostream&, const FilterRunOnce&);

::std::ostream&
operator<< (::std::ostream&, const FilterLdap&);

::std::ostream&
operator<< (::std::ostream&, const FilterBattery&);

::std::ostream&
operator<< (::std::ostream&, const FilterComputer&);

::std::ostream&
operator<< (::std::ostream&, const FilterCpu&);

::std::ostream&
operator<< (::std::ostream&, const FilterDate&);

::std::ostream&
operator<< (::std::ostream&, const FilterDun&);

::std::ostream&
operator<< (::std::ostream&, const FilterDisk&);

::std::ostream&
operator<< (::std::ostream&, const FilterDomain&);

::std::ostream&
operator<< (::std::ostream&, const FilterVariable&);

::std::ostream&
operator<< (::std::ostream&, const FilterFile&);

::std::ostream&
operator<< (::std::ostream&, const FilterIpRange&);

::std::ostream&
operator<< (::std::ostream&, const FilterLanguage&);

::std::ostream&
operator<< (::std::ostream&, const FilterMacRange&);

::std::ostream&
operator<< (::std::ostream&, const FilterMsi&);

::std::ostream&
operator<< (::std::ostream&, const FilterOs&);

::std::ostream&
operator<< (::std::ostream&, const FilterOrgUnit&);

::std::ostream&
operator<< (::std::ostream&, const FilterPcmcia&);

::std::ostream&
operator<< (::std::ostream&, const FilterPortable&);

::std::ostream&
operator<< (::std::ostream&, const FilterProcMode&);

::std::ostream&
operator<< (::std::ostream&, const FilterRam&);

::std::ostream&
operator<< (::std::ostream&, const FilterRegistry&);

::std::ostream&
operator<< (::std::ostream&, const FilterTerminal&);

::std::ostream&
operator<< (::std::ostream&, const FilterTime&);

::std::ostream&
operator<< (::std::ostream&, const FilterUser&);

::std::ostream&
operator<< (::std::ostream&, const FilterWmi&);

::std::ostream&
operator<< (::std::ostream&, const FilterCollection&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %Filters document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Filters_t >
Filters (const ::std::string& uri,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Filters_t >
Filters (const ::std::string& uri,
         ::xml_schema::ErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Filters_t >
Filters (const ::std::string& uri,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         ::xml_schema::ErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::ErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         const ::std::string& id,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Filters_t >
Filters (::xercesc::InputSource& is,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Filters_t >
Filters (::xercesc::InputSource& is,
         ::xml_schema::ErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Filters_t >
Filters (::xercesc::InputSource& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr< ::Filters_t >
Filters (const ::xercesc::DOMDocument& d,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr< ::Filters_t >
Filters (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const EnumFilterTerminalOption&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterTerminalOption&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterTerminalOption&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterTerminalType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterTerminalType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterTerminalType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterRegistryHive&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterRegistryHive&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterRegistryHive&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterRegistryValueType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterRegistryValueType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterRegistryValueType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterRegistrySubType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterRegistrySubType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterRegistrySubType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterRegistryType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterRegistryType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterRegistryType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterOsSp&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterOsSp&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterOsSp&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterOsEdition&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterOsEdition&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterOsEdition&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterOsType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterOsType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterOsType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterOsVersion&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterOsVersion&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterOsVersion&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterOsClass&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterOsClass&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterOsClass&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterMsiSubType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterMsiSubType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterMsiSubType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterMsiType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterMsiType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterMsiType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterFileType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterFileType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterFileType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterDunType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterDunType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterDunType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterDateDow&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterDateDow&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterDateDow&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterDatePeriod&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterDatePeriod&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterDatePeriod&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterComputerNameType&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterComputerNameType&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterComputerNameType&);

void
operator<< (::xercesc::DOMElement&, const EnumFilterBool&);

void
operator<< (::xercesc::DOMAttr&, const EnumFilterBool&);

void
operator<< (::xml_schema::ListStream&,
            const EnumFilterBool&);

void
operator<< (::xercesc::DOMElement&, const EnumTrueFalse&);

void
operator<< (::xercesc::DOMAttr&, const EnumTrueFalse&);

void
operator<< (::xml_schema::ListStream&,
            const EnumTrueFalse&);

void
operator<< (::xercesc::DOMElement&, const IFilter&);

void
operator<< (::xercesc::DOMElement&, const Filters_t&);

/**
 * @name Serialization functions for the %Filters document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
Filters (::std::ostream& os,
         const ::Filters_t& x, 
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Filters (::std::ostream& os,
         const ::Filters_t& x, 
         ::xml_schema::ErrorHandler& eh,
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Filters (::std::ostream& os,
         const ::Filters_t& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
Filters (::xercesc::XMLFormatTarget& ft,
         const ::Filters_t& x, 
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Filters (::xercesc::XMLFormatTarget& ft,
         const ::Filters_t& x, 
         ::xml_schema::ErrorHandler& eh,
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Filters (::xercesc::XMLFormatTarget& ft,
         const ::Filters_t& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void
Filters (::xercesc::DOMDocument& d,
         const ::Filters_t& x,
         ::xml_schema::Flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
Filters (const ::Filters_t& x, 
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         ::xml_schema::Flags f = 0);

//@}

void
operator<< (::xercesc::DOMElement&, const FilterSite&);

void
operator<< (::xercesc::DOMElement&, const FilterGroup&);

void
operator<< (::xercesc::DOMElement&, const FilterRunOnce&);

void
operator<< (::xercesc::DOMElement&, const FilterLdap&);

void
operator<< (::xercesc::DOMElement&, const FilterBattery&);

void
operator<< (::xercesc::DOMElement&, const FilterComputer&);

void
operator<< (::xercesc::DOMElement&, const FilterCpu&);

void
operator<< (::xercesc::DOMElement&, const FilterDate&);

void
operator<< (::xercesc::DOMElement&, const FilterDun&);

void
operator<< (::xercesc::DOMElement&, const FilterDisk&);

void
operator<< (::xercesc::DOMElement&, const FilterDomain&);

void
operator<< (::xercesc::DOMElement&, const FilterVariable&);

void
operator<< (::xercesc::DOMElement&, const FilterFile&);

void
operator<< (::xercesc::DOMElement&, const FilterIpRange&);

void
operator<< (::xercesc::DOMElement&, const FilterLanguage&);

void
operator<< (::xercesc::DOMElement&, const FilterMacRange&);

void
operator<< (::xercesc::DOMElement&, const FilterMsi&);

void
operator<< (::xercesc::DOMElement&, const FilterOs&);

void
operator<< (::xercesc::DOMElement&, const FilterOrgUnit&);

void
operator<< (::xercesc::DOMElement&, const FilterPcmcia&);

void
operator<< (::xercesc::DOMElement&, const FilterPortable&);

void
operator<< (::xercesc::DOMElement&, const FilterProcMode&);

void
operator<< (::xercesc::DOMElement&, const FilterRam&);

void
operator<< (::xercesc::DOMElement&, const FilterRegistry&);

void
operator<< (::xercesc::DOMElement&, const FilterTerminal&);

void
operator<< (::xercesc::DOMElement&, const FilterTime&);

void
operator<< (::xercesc::DOMElement&, const FilterUser&);

void
operator<< (::xercesc::DOMElement&, const FilterWmi&);

void
operator<< (::xercesc::DOMElement&, const FilterCollection&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_HOME_AUGUST_DEVELOP_POLICY_PREFERENCES_EDITOR_SRC_APPS_GPUI_SCHEMAS_TARGETINGSCHEMA_H
