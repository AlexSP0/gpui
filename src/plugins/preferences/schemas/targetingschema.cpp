// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "targetingschema.h"

// EnumFilterTerminalOption
// 

EnumFilterTerminalOption::
EnumFilterTerminalOption (Value v)
: ::xml_schema::String (_xsd_EnumFilterTerminalOption_literals_[v])
{
}

EnumFilterTerminalOption::
EnumFilterTerminalOption (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterTerminalOption::
EnumFilterTerminalOption (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterTerminalOption::
EnumFilterTerminalOption (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterTerminalOption::
EnumFilterTerminalOption (const EnumFilterTerminalOption& v,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterTerminalOption& EnumFilterTerminalOption::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterTerminalOption_literals_[v]);

  return *this;
}


// EnumFilterTerminalType
// 

EnumFilterTerminalType::
EnumFilterTerminalType (Value v)
: ::xml_schema::String (_xsd_EnumFilterTerminalType_literals_[v])
{
}

EnumFilterTerminalType::
EnumFilterTerminalType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterTerminalType::
EnumFilterTerminalType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterTerminalType::
EnumFilterTerminalType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterTerminalType::
EnumFilterTerminalType (const EnumFilterTerminalType& v,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterTerminalType& EnumFilterTerminalType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterTerminalType_literals_[v]);

  return *this;
}


// EnumFilterRegistryHive
// 

EnumFilterRegistryHive::
EnumFilterRegistryHive (Value v)
: ::xml_schema::String (_xsd_EnumFilterRegistryHive_literals_[v])
{
}

EnumFilterRegistryHive::
EnumFilterRegistryHive (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryHive::
EnumFilterRegistryHive (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryHive::
EnumFilterRegistryHive (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryHive::
EnumFilterRegistryHive (const EnumFilterRegistryHive& v,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterRegistryHive& EnumFilterRegistryHive::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterRegistryHive_literals_[v]);

  return *this;
}


// EnumFilterRegistryValueType
// 

EnumFilterRegistryValueType::
EnumFilterRegistryValueType (Value v)
: ::xml_schema::String (_xsd_EnumFilterRegistryValueType_literals_[v])
{
}

EnumFilterRegistryValueType::
EnumFilterRegistryValueType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryValueType::
EnumFilterRegistryValueType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryValueType::
EnumFilterRegistryValueType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryValueType::
EnumFilterRegistryValueType (const EnumFilterRegistryValueType& v,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterRegistryValueType& EnumFilterRegistryValueType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterRegistryValueType_literals_[v]);

  return *this;
}


// EnumFilterRegistrySubType
// 

EnumFilterRegistrySubType::
EnumFilterRegistrySubType (Value v)
: ::xml_schema::String (_xsd_EnumFilterRegistrySubType_literals_[v])
{
}

EnumFilterRegistrySubType::
EnumFilterRegistrySubType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistrySubType::
EnumFilterRegistrySubType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistrySubType::
EnumFilterRegistrySubType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistrySubType::
EnumFilterRegistrySubType (const EnumFilterRegistrySubType& v,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterRegistrySubType& EnumFilterRegistrySubType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterRegistrySubType_literals_[v]);

  return *this;
}


// EnumFilterRegistryType
// 

EnumFilterRegistryType::
EnumFilterRegistryType (Value v)
: ::xml_schema::String (_xsd_EnumFilterRegistryType_literals_[v])
{
}

EnumFilterRegistryType::
EnumFilterRegistryType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryType::
EnumFilterRegistryType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryType::
EnumFilterRegistryType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterRegistryType::
EnumFilterRegistryType (const EnumFilterRegistryType& v,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterRegistryType& EnumFilterRegistryType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterRegistryType_literals_[v]);

  return *this;
}


// EnumFilterOsSp
// 

EnumFilterOsSp::
EnumFilterOsSp (Value v)
: ::xml_schema::String (_xsd_EnumFilterOsSp_literals_[v])
{
}

EnumFilterOsSp::
EnumFilterOsSp (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterOsSp::
EnumFilterOsSp (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsSp::
EnumFilterOsSp (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsSp::
EnumFilterOsSp (const EnumFilterOsSp& v,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterOsSp& EnumFilterOsSp::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterOsSp_literals_[v]);

  return *this;
}


// EnumFilterOsEdition
// 

EnumFilterOsEdition::
EnumFilterOsEdition (Value v)
: ::xml_schema::String (_xsd_EnumFilterOsEdition_literals_[v])
{
}

EnumFilterOsEdition::
EnumFilterOsEdition (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterOsEdition::
EnumFilterOsEdition (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsEdition::
EnumFilterOsEdition (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsEdition::
EnumFilterOsEdition (const EnumFilterOsEdition& v,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterOsEdition& EnumFilterOsEdition::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterOsEdition_literals_[v]);

  return *this;
}


// EnumFilterOsType
// 

EnumFilterOsType::
EnumFilterOsType (Value v)
: ::xml_schema::String (_xsd_EnumFilterOsType_literals_[v])
{
}

EnumFilterOsType::
EnumFilterOsType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterOsType::
EnumFilterOsType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsType::
EnumFilterOsType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsType::
EnumFilterOsType (const EnumFilterOsType& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterOsType& EnumFilterOsType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterOsType_literals_[v]);

  return *this;
}


// EnumFilterOsVersion
// 

EnumFilterOsVersion::
EnumFilterOsVersion (Value v)
: ::xml_schema::String (_xsd_EnumFilterOsVersion_literals_[v])
{
}

EnumFilterOsVersion::
EnumFilterOsVersion (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterOsVersion::
EnumFilterOsVersion (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsVersion::
EnumFilterOsVersion (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsVersion::
EnumFilterOsVersion (const EnumFilterOsVersion& v,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterOsVersion& EnumFilterOsVersion::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterOsVersion_literals_[v]);

  return *this;
}


// EnumFilterOsClass
// 

EnumFilterOsClass::
EnumFilterOsClass (Value v)
: ::xml_schema::String (_xsd_EnumFilterOsClass_literals_[v])
{
}

EnumFilterOsClass::
EnumFilterOsClass (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterOsClass::
EnumFilterOsClass (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsClass::
EnumFilterOsClass (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterOsClass::
EnumFilterOsClass (const EnumFilterOsClass& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterOsClass& EnumFilterOsClass::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterOsClass_literals_[v]);

  return *this;
}


// EnumFilterMsiSubType
// 

EnumFilterMsiSubType::
EnumFilterMsiSubType (Value v)
: ::xml_schema::String (_xsd_EnumFilterMsiSubType_literals_[v])
{
}

EnumFilterMsiSubType::
EnumFilterMsiSubType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterMsiSubType::
EnumFilterMsiSubType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterMsiSubType::
EnumFilterMsiSubType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterMsiSubType::
EnumFilterMsiSubType (const EnumFilterMsiSubType& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterMsiSubType& EnumFilterMsiSubType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterMsiSubType_literals_[v]);

  return *this;
}


// EnumFilterMsiType
// 

EnumFilterMsiType::
EnumFilterMsiType (Value v)
: ::xml_schema::String (_xsd_EnumFilterMsiType_literals_[v])
{
}

EnumFilterMsiType::
EnumFilterMsiType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterMsiType::
EnumFilterMsiType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterMsiType::
EnumFilterMsiType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterMsiType::
EnumFilterMsiType (const EnumFilterMsiType& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterMsiType& EnumFilterMsiType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterMsiType_literals_[v]);

  return *this;
}


// EnumFilterFileType
// 

EnumFilterFileType::
EnumFilterFileType (Value v)
: ::xml_schema::String (_xsd_EnumFilterFileType_literals_[v])
{
}

EnumFilterFileType::
EnumFilterFileType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterFileType::
EnumFilterFileType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterFileType::
EnumFilterFileType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterFileType::
EnumFilterFileType (const EnumFilterFileType& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterFileType& EnumFilterFileType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterFileType_literals_[v]);

  return *this;
}


// EnumFilterDunType
// 

EnumFilterDunType::
EnumFilterDunType (Value v)
: ::xml_schema::String (_xsd_EnumFilterDunType_literals_[v])
{
}

EnumFilterDunType::
EnumFilterDunType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterDunType::
EnumFilterDunType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterDunType::
EnumFilterDunType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterDunType::
EnumFilterDunType (const EnumFilterDunType& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterDunType& EnumFilterDunType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterDunType_literals_[v]);

  return *this;
}


// EnumFilterDateDow
// 

EnumFilterDateDow::
EnumFilterDateDow (Value v)
: ::xml_schema::String (_xsd_EnumFilterDateDow_literals_[v])
{
}

EnumFilterDateDow::
EnumFilterDateDow (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterDateDow::
EnumFilterDateDow (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterDateDow::
EnumFilterDateDow (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterDateDow::
EnumFilterDateDow (const EnumFilterDateDow& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterDateDow& EnumFilterDateDow::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterDateDow_literals_[v]);

  return *this;
}


// EnumFilterDatePeriod
// 

EnumFilterDatePeriod::
EnumFilterDatePeriod (Value v)
: ::xml_schema::String (_xsd_EnumFilterDatePeriod_literals_[v])
{
}

EnumFilterDatePeriod::
EnumFilterDatePeriod (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterDatePeriod::
EnumFilterDatePeriod (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterDatePeriod::
EnumFilterDatePeriod (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterDatePeriod::
EnumFilterDatePeriod (const EnumFilterDatePeriod& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterDatePeriod& EnumFilterDatePeriod::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterDatePeriod_literals_[v]);

  return *this;
}


// EnumFilterComputerNameType
// 

EnumFilterComputerNameType::
EnumFilterComputerNameType (Value v)
: ::xml_schema::String (_xsd_EnumFilterComputerNameType_literals_[v])
{
}

EnumFilterComputerNameType::
EnumFilterComputerNameType (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterComputerNameType::
EnumFilterComputerNameType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterComputerNameType::
EnumFilterComputerNameType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterComputerNameType::
EnumFilterComputerNameType (const EnumFilterComputerNameType& v,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterComputerNameType& EnumFilterComputerNameType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterComputerNameType_literals_[v]);

  return *this;
}


// EnumFilterBool
// 

EnumFilterBool::
EnumFilterBool (Value v)
: ::xml_schema::String (_xsd_EnumFilterBool_literals_[v])
{
}

EnumFilterBool::
EnumFilterBool (const char* v)
: ::xml_schema::String (v)
{
}

EnumFilterBool::
EnumFilterBool (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumFilterBool::
EnumFilterBool (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumFilterBool::
EnumFilterBool (const EnumFilterBool& v,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumFilterBool& EnumFilterBool::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumFilterBool_literals_[v]);

  return *this;
}


// EnumTrueFalse
// 

EnumTrueFalse::
EnumTrueFalse (Value v)
: ::xml_schema::String (_xsd_EnumTrueFalse_literals_[v])
{
}

EnumTrueFalse::
EnumTrueFalse (const char* v)
: ::xml_schema::String (v)
{
}

EnumTrueFalse::
EnumTrueFalse (const ::std::string& v)
: ::xml_schema::String (v)
{
}

EnumTrueFalse::
EnumTrueFalse (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

EnumTrueFalse::
EnumTrueFalse (const EnumTrueFalse& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

EnumTrueFalse& EnumTrueFalse::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_EnumTrueFalse_literals_[v]);

  return *this;
}


// IFilter
// 

const IFilter::BoolType& IFilter::
bool_ () const
{
  return this->bool__.get ();
}

IFilter::BoolType& IFilter::
bool_ ()
{
  return this->bool__.get ();
}

void IFilter::
bool_ (const BoolType& x)
{
  this->bool__.set (x);
}

void IFilter::
bool_ (::std::unique_ptr< BoolType > x)
{
  this->bool__.set (std::move (x));
}

const IFilter::NotType& IFilter::
not_ () const
{
  return this->not__.get ();
}

IFilter::NotType& IFilter::
not_ ()
{
  return this->not__.get ();
}

void IFilter::
not_ (const NotType& x)
{
  this->not__.set (x);
}

void IFilter::
not_ (::std::unique_ptr< NotType > x)
{
  this->not__.set (std::move (x));
}

const IFilter::HiddenOptional& IFilter::
hidden () const
{
  return this->hidden_;
}

IFilter::HiddenOptional& IFilter::
hidden ()
{
  return this->hidden_;
}

void IFilter::
hidden (const HiddenType& x)
{
  this->hidden_.set (x);
}

void IFilter::
hidden (const HiddenOptional& x)
{
  this->hidden_ = x;
}

void IFilter::
hidden (::std::unique_ptr< HiddenType > x)
{
  this->hidden_.set (std::move (x));
}


// Filters_t
// 

const Filters_t::FilterSiteSequence& Filters_t::
FilterSite () const
{
  return this->FilterSite_;
}

Filters_t::FilterSiteSequence& Filters_t::
FilterSite ()
{
  return this->FilterSite_;
}

void Filters_t::
FilterSite (const FilterSiteSequence& s)
{
  this->FilterSite_ = s;
}

const Filters_t::FilterGroupSequence& Filters_t::
FilterGroup () const
{
  return this->FilterGroup_;
}

Filters_t::FilterGroupSequence& Filters_t::
FilterGroup ()
{
  return this->FilterGroup_;
}

void Filters_t::
FilterGroup (const FilterGroupSequence& s)
{
  this->FilterGroup_ = s;
}

const Filters_t::FilterRunOnceSequence& Filters_t::
FilterRunOnce () const
{
  return this->FilterRunOnce_;
}

Filters_t::FilterRunOnceSequence& Filters_t::
FilterRunOnce ()
{
  return this->FilterRunOnce_;
}

void Filters_t::
FilterRunOnce (const FilterRunOnceSequence& s)
{
  this->FilterRunOnce_ = s;
}

const Filters_t::FilterLdapSequence& Filters_t::
FilterLdap () const
{
  return this->FilterLdap_;
}

Filters_t::FilterLdapSequence& Filters_t::
FilterLdap ()
{
  return this->FilterLdap_;
}

void Filters_t::
FilterLdap (const FilterLdapSequence& s)
{
  this->FilterLdap_ = s;
}

const Filters_t::FilterBatterySequence& Filters_t::
FilterBattery () const
{
  return this->FilterBattery_;
}

Filters_t::FilterBatterySequence& Filters_t::
FilterBattery ()
{
  return this->FilterBattery_;
}

void Filters_t::
FilterBattery (const FilterBatterySequence& s)
{
  this->FilterBattery_ = s;
}

const Filters_t::FilterComputerSequence& Filters_t::
FilterComputer () const
{
  return this->FilterComputer_;
}

Filters_t::FilterComputerSequence& Filters_t::
FilterComputer ()
{
  return this->FilterComputer_;
}

void Filters_t::
FilterComputer (const FilterComputerSequence& s)
{
  this->FilterComputer_ = s;
}

const Filters_t::FilterCpuSequence& Filters_t::
FilterCpu () const
{
  return this->FilterCpu_;
}

Filters_t::FilterCpuSequence& Filters_t::
FilterCpu ()
{
  return this->FilterCpu_;
}

void Filters_t::
FilterCpu (const FilterCpuSequence& s)
{
  this->FilterCpu_ = s;
}

const Filters_t::FilterDateSequence& Filters_t::
FilterDate () const
{
  return this->FilterDate_;
}

Filters_t::FilterDateSequence& Filters_t::
FilterDate ()
{
  return this->FilterDate_;
}

void Filters_t::
FilterDate (const FilterDateSequence& s)
{
  this->FilterDate_ = s;
}

const Filters_t::FilterDunSequence& Filters_t::
FilterDun () const
{
  return this->FilterDun_;
}

Filters_t::FilterDunSequence& Filters_t::
FilterDun ()
{
  return this->FilterDun_;
}

void Filters_t::
FilterDun (const FilterDunSequence& s)
{
  this->FilterDun_ = s;
}

const Filters_t::FilterDiskSequence& Filters_t::
FilterDisk () const
{
  return this->FilterDisk_;
}

Filters_t::FilterDiskSequence& Filters_t::
FilterDisk ()
{
  return this->FilterDisk_;
}

void Filters_t::
FilterDisk (const FilterDiskSequence& s)
{
  this->FilterDisk_ = s;
}

const Filters_t::FilterDomainSequence& Filters_t::
FilterDomain () const
{
  return this->FilterDomain_;
}

Filters_t::FilterDomainSequence& Filters_t::
FilterDomain ()
{
  return this->FilterDomain_;
}

void Filters_t::
FilterDomain (const FilterDomainSequence& s)
{
  this->FilterDomain_ = s;
}

const Filters_t::FilterVariableSequence& Filters_t::
FilterVariable () const
{
  return this->FilterVariable_;
}

Filters_t::FilterVariableSequence& Filters_t::
FilterVariable ()
{
  return this->FilterVariable_;
}

void Filters_t::
FilterVariable (const FilterVariableSequence& s)
{
  this->FilterVariable_ = s;
}

const Filters_t::FilterFileSequence& Filters_t::
FilterFile () const
{
  return this->FilterFile_;
}

Filters_t::FilterFileSequence& Filters_t::
FilterFile ()
{
  return this->FilterFile_;
}

void Filters_t::
FilterFile (const FilterFileSequence& s)
{
  this->FilterFile_ = s;
}

const Filters_t::FilterIpRangeSequence& Filters_t::
FilterIpRange () const
{
  return this->FilterIpRange_;
}

Filters_t::FilterIpRangeSequence& Filters_t::
FilterIpRange ()
{
  return this->FilterIpRange_;
}

void Filters_t::
FilterIpRange (const FilterIpRangeSequence& s)
{
  this->FilterIpRange_ = s;
}

const Filters_t::FilterLanguageSequence& Filters_t::
FilterLanguage () const
{
  return this->FilterLanguage_;
}

Filters_t::FilterLanguageSequence& Filters_t::
FilterLanguage ()
{
  return this->FilterLanguage_;
}

void Filters_t::
FilterLanguage (const FilterLanguageSequence& s)
{
  this->FilterLanguage_ = s;
}

const Filters_t::FilterMacRangeSequence& Filters_t::
FilterMacRange () const
{
  return this->FilterMacRange_;
}

Filters_t::FilterMacRangeSequence& Filters_t::
FilterMacRange ()
{
  return this->FilterMacRange_;
}

void Filters_t::
FilterMacRange (const FilterMacRangeSequence& s)
{
  this->FilterMacRange_ = s;
}

const Filters_t::FilterMsiSequence& Filters_t::
FilterMsi () const
{
  return this->FilterMsi_;
}

Filters_t::FilterMsiSequence& Filters_t::
FilterMsi ()
{
  return this->FilterMsi_;
}

void Filters_t::
FilterMsi (const FilterMsiSequence& s)
{
  this->FilterMsi_ = s;
}

const Filters_t::FilterOsSequence& Filters_t::
FilterOs () const
{
  return this->FilterOs_;
}

Filters_t::FilterOsSequence& Filters_t::
FilterOs ()
{
  return this->FilterOs_;
}

void Filters_t::
FilterOs (const FilterOsSequence& s)
{
  this->FilterOs_ = s;
}

const Filters_t::FilterOrgUnitSequence& Filters_t::
FilterOrgUnit () const
{
  return this->FilterOrgUnit_;
}

Filters_t::FilterOrgUnitSequence& Filters_t::
FilterOrgUnit ()
{
  return this->FilterOrgUnit_;
}

void Filters_t::
FilterOrgUnit (const FilterOrgUnitSequence& s)
{
  this->FilterOrgUnit_ = s;
}

const Filters_t::FilterPcmciaSequence& Filters_t::
FilterPcmcia () const
{
  return this->FilterPcmcia_;
}

Filters_t::FilterPcmciaSequence& Filters_t::
FilterPcmcia ()
{
  return this->FilterPcmcia_;
}

void Filters_t::
FilterPcmcia (const FilterPcmciaSequence& s)
{
  this->FilterPcmcia_ = s;
}

const Filters_t::FilterPortableSequence& Filters_t::
FilterPortable () const
{
  return this->FilterPortable_;
}

Filters_t::FilterPortableSequence& Filters_t::
FilterPortable ()
{
  return this->FilterPortable_;
}

void Filters_t::
FilterPortable (const FilterPortableSequence& s)
{
  this->FilterPortable_ = s;
}

const Filters_t::FilterProcModeSequence& Filters_t::
FilterProcMode () const
{
  return this->FilterProcMode_;
}

Filters_t::FilterProcModeSequence& Filters_t::
FilterProcMode ()
{
  return this->FilterProcMode_;
}

void Filters_t::
FilterProcMode (const FilterProcModeSequence& s)
{
  this->FilterProcMode_ = s;
}

const Filters_t::FilterRamSequence& Filters_t::
FilterRam () const
{
  return this->FilterRam_;
}

Filters_t::FilterRamSequence& Filters_t::
FilterRam ()
{
  return this->FilterRam_;
}

void Filters_t::
FilterRam (const FilterRamSequence& s)
{
  this->FilterRam_ = s;
}

const Filters_t::FilterRegistrySequence& Filters_t::
FilterRegistry () const
{
  return this->FilterRegistry_;
}

Filters_t::FilterRegistrySequence& Filters_t::
FilterRegistry ()
{
  return this->FilterRegistry_;
}

void Filters_t::
FilterRegistry (const FilterRegistrySequence& s)
{
  this->FilterRegistry_ = s;
}

const Filters_t::FilterTerminalSequence& Filters_t::
FilterTerminal () const
{
  return this->FilterTerminal_;
}

Filters_t::FilterTerminalSequence& Filters_t::
FilterTerminal ()
{
  return this->FilterTerminal_;
}

void Filters_t::
FilterTerminal (const FilterTerminalSequence& s)
{
  this->FilterTerminal_ = s;
}

const Filters_t::FilterTimeSequence& Filters_t::
FilterTime () const
{
  return this->FilterTime_;
}

Filters_t::FilterTimeSequence& Filters_t::
FilterTime ()
{
  return this->FilterTime_;
}

void Filters_t::
FilterTime (const FilterTimeSequence& s)
{
  this->FilterTime_ = s;
}

const Filters_t::FilterUserSequence& Filters_t::
FilterUser () const
{
  return this->FilterUser_;
}

Filters_t::FilterUserSequence& Filters_t::
FilterUser ()
{
  return this->FilterUser_;
}

void Filters_t::
FilterUser (const FilterUserSequence& s)
{
  this->FilterUser_ = s;
}

const Filters_t::FilterWmiSequence& Filters_t::
FilterWmi () const
{
  return this->FilterWmi_;
}

Filters_t::FilterWmiSequence& Filters_t::
FilterWmi ()
{
  return this->FilterWmi_;
}

void Filters_t::
FilterWmi (const FilterWmiSequence& s)
{
  this->FilterWmi_ = s;
}

const Filters_t::FilterCollectionSequence& Filters_t::
FilterCollection () const
{
  return this->FilterCollection_;
}

Filters_t::FilterCollectionSequence& Filters_t::
FilterCollection ()
{
  return this->FilterCollection_;
}

void Filters_t::
FilterCollection (const FilterCollectionSequence& s)
{
  this->FilterCollection_ = s;
}


// FilterSite
// 

const FilterSite::NameType& FilterSite::
name () const
{
  return this->name_.get ();
}

FilterSite::NameType& FilterSite::
name ()
{
  return this->name_.get ();
}

void FilterSite::
name (const NameType& x)
{
  this->name_.set (x);
}

void FilterSite::
name (::std::unique_ptr< NameType > x)
{
  this->name_.set (std::move (x));
}


// FilterGroup
// 

const FilterGroup::NameType& FilterGroup::
name () const
{
  return this->name_.get ();
}

FilterGroup::NameType& FilterGroup::
name ()
{
  return this->name_.get ();
}

void FilterGroup::
name (const NameType& x)
{
  this->name_.set (x);
}

void FilterGroup::
name (::std::unique_ptr< NameType > x)
{
  this->name_.set (std::move (x));
}

const FilterGroup::NameType& FilterGroup::
name_default_value ()
{
  return name_default_value_;
}

const FilterGroup::SidType& FilterGroup::
sid () const
{
  return this->sid_.get ();
}

FilterGroup::SidType& FilterGroup::
sid ()
{
  return this->sid_.get ();
}

void FilterGroup::
sid (const SidType& x)
{
  this->sid_.set (x);
}

void FilterGroup::
sid (::std::unique_ptr< SidType > x)
{
  this->sid_.set (std::move (x));
}

const FilterGroup::SidType& FilterGroup::
sid_default_value ()
{
  return sid_default_value_;
}

const FilterGroup::UserContextType& FilterGroup::
userContext () const
{
  return this->userContext_.get ();
}

FilterGroup::UserContextType& FilterGroup::
userContext ()
{
  return this->userContext_.get ();
}

void FilterGroup::
userContext (const UserContextType& x)
{
  this->userContext_.set (x);
}

void FilterGroup::
userContext (::std::unique_ptr< UserContextType > x)
{
  this->userContext_.set (std::move (x));
}

const FilterGroup::UserContextType& FilterGroup::
userContext_default_value ()
{
  return userContext_default_value_;
}

const FilterGroup::PrimaryGroupType& FilterGroup::
primaryGroup () const
{
  return this->primaryGroup_.get ();
}

FilterGroup::PrimaryGroupType& FilterGroup::
primaryGroup ()
{
  return this->primaryGroup_.get ();
}

void FilterGroup::
primaryGroup (const PrimaryGroupType& x)
{
  this->primaryGroup_.set (x);
}

void FilterGroup::
primaryGroup (::std::unique_ptr< PrimaryGroupType > x)
{
  this->primaryGroup_.set (std::move (x));
}

const FilterGroup::PrimaryGroupType& FilterGroup::
primaryGroup_default_value ()
{
  return primaryGroup_default_value_;
}

const FilterGroup::LocalGroupType& FilterGroup::
localGroup () const
{
  return this->localGroup_.get ();
}

FilterGroup::LocalGroupType& FilterGroup::
localGroup ()
{
  return this->localGroup_.get ();
}

void FilterGroup::
localGroup (const LocalGroupType& x)
{
  this->localGroup_.set (x);
}

void FilterGroup::
localGroup (::std::unique_ptr< LocalGroupType > x)
{
  this->localGroup_.set (std::move (x));
}

const FilterGroup::LocalGroupType& FilterGroup::
localGroup_default_value ()
{
  return localGroup_default_value_;
}


// FilterRunOnce
// 

const FilterRunOnce::IdType& FilterRunOnce::
id () const
{
  return this->id_.get ();
}

FilterRunOnce::IdType& FilterRunOnce::
id ()
{
  return this->id_.get ();
}

void FilterRunOnce::
id (const IdType& x)
{
  this->id_.set (x);
}

void FilterRunOnce::
id (::std::unique_ptr< IdType > x)
{
  this->id_.set (std::move (x));
}

const FilterRunOnce::UserContextType& FilterRunOnce::
userContext () const
{
  return this->userContext_.get ();
}

FilterRunOnce::UserContextType& FilterRunOnce::
userContext ()
{
  return this->userContext_.get ();
}

void FilterRunOnce::
userContext (const UserContextType& x)
{
  this->userContext_.set (x);
}

void FilterRunOnce::
userContext (::std::unique_ptr< UserContextType > x)
{
  this->userContext_.set (std::move (x));
}

const FilterRunOnce::UserContextType& FilterRunOnce::
userContext_default_value ()
{
  return userContext_default_value_;
}

const FilterRunOnce::CommentsType& FilterRunOnce::
comments () const
{
  return this->comments_.get ();
}

FilterRunOnce::CommentsType& FilterRunOnce::
comments ()
{
  return this->comments_.get ();
}

void FilterRunOnce::
comments (const CommentsType& x)
{
  this->comments_.set (x);
}

void FilterRunOnce::
comments (::std::unique_ptr< CommentsType > x)
{
  this->comments_.set (std::move (x));
}

const FilterRunOnce::CommentsType& FilterRunOnce::
comments_default_value ()
{
  return comments_default_value_;
}


// FilterLdap
// 

const FilterLdap::SearchFilterOptional& FilterLdap::
searchFilter () const
{
  return this->searchFilter_;
}

FilterLdap::SearchFilterOptional& FilterLdap::
searchFilter ()
{
  return this->searchFilter_;
}

void FilterLdap::
searchFilter (const SearchFilterType& x)
{
  this->searchFilter_.set (x);
}

void FilterLdap::
searchFilter (const SearchFilterOptional& x)
{
  this->searchFilter_ = x;
}

void FilterLdap::
searchFilter (::std::unique_ptr< SearchFilterType > x)
{
  this->searchFilter_.set (std::move (x));
}

const FilterLdap::BindingType& FilterLdap::
binding () const
{
  return this->binding_.get ();
}

FilterLdap::BindingType& FilterLdap::
binding ()
{
  return this->binding_.get ();
}

void FilterLdap::
binding (const BindingType& x)
{
  this->binding_.set (x);
}

void FilterLdap::
binding (::std::unique_ptr< BindingType > x)
{
  this->binding_.set (std::move (x));
}

const FilterLdap::VariableNameOptional& FilterLdap::
variableName () const
{
  return this->variableName_;
}

FilterLdap::VariableNameOptional& FilterLdap::
variableName ()
{
  return this->variableName_;
}

void FilterLdap::
variableName (const VariableNameType& x)
{
  this->variableName_.set (x);
}

void FilterLdap::
variableName (const VariableNameOptional& x)
{
  this->variableName_ = x;
}

void FilterLdap::
variableName (::std::unique_ptr< VariableNameType > x)
{
  this->variableName_.set (std::move (x));
}

const FilterLdap::AttributeOptional& FilterLdap::
attribute () const
{
  return this->attribute_;
}

FilterLdap::AttributeOptional& FilterLdap::
attribute ()
{
  return this->attribute_;
}

void FilterLdap::
attribute (const AttributeType& x)
{
  this->attribute_.set (x);
}

void FilterLdap::
attribute (const AttributeOptional& x)
{
  this->attribute_ = x;
}

void FilterLdap::
attribute (::std::unique_ptr< AttributeType > x)
{
  this->attribute_.set (std::move (x));
}


// FilterBattery
// 


// FilterComputer
// 

const FilterComputer::TypeType& FilterComputer::
type () const
{
  return this->type_.get ();
}

FilterComputer::TypeType& FilterComputer::
type ()
{
  return this->type_.get ();
}

void FilterComputer::
type (const TypeType& x)
{
  this->type_.set (x);
}

void FilterComputer::
type (::std::unique_ptr< TypeType > x)
{
  this->type_.set (std::move (x));
}

const FilterComputer::NameType& FilterComputer::
name () const
{
  return this->name_.get ();
}

FilterComputer::NameType& FilterComputer::
name ()
{
  return this->name_.get ();
}

void FilterComputer::
name (const NameType& x)
{
  this->name_.set (x);
}

void FilterComputer::
name (::std::unique_ptr< NameType > x)
{
  this->name_.set (std::move (x));
}


// FilterCpu
// 

const FilterCpu::SpeedMHzType& FilterCpu::
speedMHz () const
{
  return this->speedMHz_.get ();
}

FilterCpu::SpeedMHzType& FilterCpu::
speedMHz ()
{
  return this->speedMHz_.get ();
}

void FilterCpu::
speedMHz (const SpeedMHzType& x)
{
  this->speedMHz_.set (x);
}


// FilterDate
// 

const FilterDate::PeriodType& FilterDate::
period () const
{
  return this->period_.get ();
}

FilterDate::PeriodType& FilterDate::
period ()
{
  return this->period_.get ();
}

void FilterDate::
period (const PeriodType& x)
{
  this->period_.set (x);
}

void FilterDate::
period (::std::unique_ptr< PeriodType > x)
{
  this->period_.set (std::move (x));
}

const FilterDate::DowOptional& FilterDate::
dow () const
{
  return this->dow_;
}

FilterDate::DowOptional& FilterDate::
dow ()
{
  return this->dow_;
}

void FilterDate::
dow (const DowType& x)
{
  this->dow_.set (x);
}

void FilterDate::
dow (const DowOptional& x)
{
  this->dow_ = x;
}

void FilterDate::
dow (::std::unique_ptr< DowType > x)
{
  this->dow_.set (std::move (x));
}

const FilterDate::DayOptional& FilterDate::
day () const
{
  return this->day_;
}

FilterDate::DayOptional& FilterDate::
day ()
{
  return this->day_;
}

void FilterDate::
day (const DayType& x)
{
  this->day_.set (x);
}

void FilterDate::
day (const DayOptional& x)
{
  this->day_ = x;
}

const FilterDate::MonthOptional& FilterDate::
month () const
{
  return this->month_;
}

FilterDate::MonthOptional& FilterDate::
month ()
{
  return this->month_;
}

void FilterDate::
month (const MonthType& x)
{
  this->month_.set (x);
}

void FilterDate::
month (const MonthOptional& x)
{
  this->month_ = x;
}

const FilterDate::YearOptional& FilterDate::
year () const
{
  return this->year_;
}

FilterDate::YearOptional& FilterDate::
year ()
{
  return this->year_;
}

void FilterDate::
year (const YearType& x)
{
  this->year_.set (x);
}

void FilterDate::
year (const YearOptional& x)
{
  this->year_ = x;
}


// FilterDun
// 

const FilterDun::TypeType& FilterDun::
type () const
{
  return this->type_.get ();
}

FilterDun::TypeType& FilterDun::
type ()
{
  return this->type_.get ();
}

void FilterDun::
type (const TypeType& x)
{
  this->type_.set (x);
}

void FilterDun::
type (::std::unique_ptr< TypeType > x)
{
  this->type_.set (std::move (x));
}


// FilterDisk
// 

const FilterDisk::FreeSpaceType& FilterDisk::
freeSpace () const
{
  return this->freeSpace_.get ();
}

FilterDisk::FreeSpaceType& FilterDisk::
freeSpace ()
{
  return this->freeSpace_.get ();
}

void FilterDisk::
freeSpace (const FreeSpaceType& x)
{
  this->freeSpace_.set (x);
}

const FilterDisk::DriveType& FilterDisk::
drive () const
{
  return this->drive_.get ();
}

FilterDisk::DriveType& FilterDisk::
drive ()
{
  return this->drive_.get ();
}

void FilterDisk::
drive (const DriveType& x)
{
  this->drive_.set (x);
}

void FilterDisk::
drive (::std::unique_ptr< DriveType > x)
{
  this->drive_.set (std::move (x));
}


// FilterDomain
// 

const FilterDomain::NameType& FilterDomain::
name () const
{
  return this->name_.get ();
}

FilterDomain::NameType& FilterDomain::
name ()
{
  return this->name_.get ();
}

void FilterDomain::
name (const NameType& x)
{
  this->name_.set (x);
}

void FilterDomain::
name (::std::unique_ptr< NameType > x)
{
  this->name_.set (std::move (x));
}

const FilterDomain::UserContextType& FilterDomain::
userContext () const
{
  return this->userContext_.get ();
}

FilterDomain::UserContextType& FilterDomain::
userContext ()
{
  return this->userContext_.get ();
}

void FilterDomain::
userContext (const UserContextType& x)
{
  this->userContext_.set (x);
}

void FilterDomain::
userContext (::std::unique_ptr< UserContextType > x)
{
  this->userContext_.set (std::move (x));
}

const FilterDomain::UserContextType& FilterDomain::
userContext_default_value ()
{
  return userContext_default_value_;
}


// FilterVariable
// 

const FilterVariable::VariableNameType& FilterVariable::
variableName () const
{
  return this->variableName_.get ();
}

FilterVariable::VariableNameType& FilterVariable::
variableName ()
{
  return this->variableName_.get ();
}

void FilterVariable::
variableName (const VariableNameType& x)
{
  this->variableName_.set (x);
}

void FilterVariable::
variableName (::std::unique_ptr< VariableNameType > x)
{
  this->variableName_.set (std::move (x));
}

const FilterVariable::ValueType& FilterVariable::
value () const
{
  return this->value_.get ();
}

FilterVariable::ValueType& FilterVariable::
value ()
{
  return this->value_.get ();
}

void FilterVariable::
value (const ValueType& x)
{
  this->value_.set (x);
}

void FilterVariable::
value (::std::unique_ptr< ValueType > x)
{
  this->value_.set (std::move (x));
}

const FilterVariable::ValueType& FilterVariable::
value_default_value ()
{
  return value_default_value_;
}


// FilterFile
// 

const FilterFile::GteType& FilterFile::
gte () const
{
  return this->gte_.get ();
}

FilterFile::GteType& FilterFile::
gte ()
{
  return this->gte_.get ();
}

void FilterFile::
gte (const GteType& x)
{
  this->gte_.set (x);
}

void FilterFile::
gte (::std::unique_ptr< GteType > x)
{
  this->gte_.set (std::move (x));
}

const FilterFile::GteType& FilterFile::
gte_default_value ()
{
  return gte_default_value_;
}

const FilterFile::LteType& FilterFile::
lte () const
{
  return this->lte_.get ();
}

FilterFile::LteType& FilterFile::
lte ()
{
  return this->lte_.get ();
}

void FilterFile::
lte (const LteType& x)
{
  this->lte_.set (x);
}

void FilterFile::
lte (::std::unique_ptr< LteType > x)
{
  this->lte_.set (std::move (x));
}

const FilterFile::LteType& FilterFile::
lte_default_value ()
{
  return lte_default_value_;
}

const FilterFile::MinOptional& FilterFile::
min () const
{
  return this->min_;
}

FilterFile::MinOptional& FilterFile::
min ()
{
  return this->min_;
}

void FilterFile::
min (const MinType& x)
{
  this->min_.set (x);
}

void FilterFile::
min (const MinOptional& x)
{
  this->min_ = x;
}

void FilterFile::
min (::std::unique_ptr< MinType > x)
{
  this->min_.set (std::move (x));
}

const FilterFile::MaxOptional& FilterFile::
max () const
{
  return this->max_;
}

FilterFile::MaxOptional& FilterFile::
max ()
{
  return this->max_;
}

void FilterFile::
max (const MaxType& x)
{
  this->max_.set (x);
}

void FilterFile::
max (const MaxOptional& x)
{
  this->max_ = x;
}

void FilterFile::
max (::std::unique_ptr< MaxType > x)
{
  this->max_.set (std::move (x));
}

const FilterFile::PathType& FilterFile::
path () const
{
  return this->path_.get ();
}

FilterFile::PathType& FilterFile::
path ()
{
  return this->path_.get ();
}

void FilterFile::
path (const PathType& x)
{
  this->path_.set (x);
}

void FilterFile::
path (::std::unique_ptr< PathType > x)
{
  this->path_.set (std::move (x));
}

const FilterFile::TypeType& FilterFile::
type () const
{
  return this->type_.get ();
}

FilterFile::TypeType& FilterFile::
type ()
{
  return this->type_.get ();
}

void FilterFile::
type (const TypeType& x)
{
  this->type_.set (x);
}

void FilterFile::
type (::std::unique_ptr< TypeType > x)
{
  this->type_.set (std::move (x));
}

const FilterFile::TypeType& FilterFile::
type_default_value ()
{
  return type_default_value_;
}

const FilterFile::FolderType& FilterFile::
folder () const
{
  return this->folder_.get ();
}

FilterFile::FolderType& FilterFile::
folder ()
{
  return this->folder_.get ();
}

void FilterFile::
folder (const FolderType& x)
{
  this->folder_.set (x);
}

void FilterFile::
folder (::std::unique_ptr< FolderType > x)
{
  this->folder_.set (std::move (x));
}

const FilterFile::FolderType& FilterFile::
folder_default_value ()
{
  return folder_default_value_;
}


// FilterIpRange
// 

const FilterIpRange::MinType& FilterIpRange::
min () const
{
  return this->min_.get ();
}

FilterIpRange::MinType& FilterIpRange::
min ()
{
  return this->min_.get ();
}

void FilterIpRange::
min (const MinType& x)
{
  this->min_.set (x);
}

void FilterIpRange::
min (::std::unique_ptr< MinType > x)
{
  this->min_.set (std::move (x));
}

const FilterIpRange::MaxType& FilterIpRange::
max () const
{
  return this->max_.get ();
}

FilterIpRange::MaxType& FilterIpRange::
max ()
{
  return this->max_.get ();
}

void FilterIpRange::
max (const MaxType& x)
{
  this->max_.set (x);
}

void FilterIpRange::
max (::std::unique_ptr< MaxType > x)
{
  this->max_.set (std::move (x));
}


// FilterLanguage
// 

const FilterLanguage::DefaultType& FilterLanguage::
default_ () const
{
  return this->default__.get ();
}

FilterLanguage::DefaultType& FilterLanguage::
default_ ()
{
  return this->default__.get ();
}

void FilterLanguage::
default_ (const DefaultType& x)
{
  this->default__.set (x);
}

void FilterLanguage::
default_ (::std::unique_ptr< DefaultType > x)
{
  this->default__.set (std::move (x));
}

const FilterLanguage::DefaultType& FilterLanguage::
default_default_value ()
{
  return default__default_value_;
}

const FilterLanguage::SystemType& FilterLanguage::
system () const
{
  return this->system_.get ();
}

FilterLanguage::SystemType& FilterLanguage::
system ()
{
  return this->system_.get ();
}

void FilterLanguage::
system (const SystemType& x)
{
  this->system_.set (x);
}

void FilterLanguage::
system (::std::unique_ptr< SystemType > x)
{
  this->system_.set (std::move (x));
}

const FilterLanguage::SystemType& FilterLanguage::
system_default_value ()
{
  return system_default_value_;
}

const FilterLanguage::NativeType& FilterLanguage::
native () const
{
  return this->native_.get ();
}

FilterLanguage::NativeType& FilterLanguage::
native ()
{
  return this->native_.get ();
}

void FilterLanguage::
native (const NativeType& x)
{
  this->native_.set (x);
}

void FilterLanguage::
native (::std::unique_ptr< NativeType > x)
{
  this->native_.set (std::move (x));
}

const FilterLanguage::NativeType& FilterLanguage::
native_default_value ()
{
  return native_default_value_;
}

const FilterLanguage::DisplayNameOptional& FilterLanguage::
displayName () const
{
  return this->displayName_;
}

FilterLanguage::DisplayNameOptional& FilterLanguage::
displayName ()
{
  return this->displayName_;
}

void FilterLanguage::
displayName (const DisplayNameType& x)
{
  this->displayName_.set (x);
}

void FilterLanguage::
displayName (const DisplayNameOptional& x)
{
  this->displayName_ = x;
}

void FilterLanguage::
displayName (::std::unique_ptr< DisplayNameType > x)
{
  this->displayName_.set (std::move (x));
}

const FilterLanguage::LanguageType& FilterLanguage::
language () const
{
  return this->language_.get ();
}

FilterLanguage::LanguageType& FilterLanguage::
language ()
{
  return this->language_.get ();
}

void FilterLanguage::
language (const LanguageType& x)
{
  this->language_.set (x);
}

const FilterLanguage::LocaleType& FilterLanguage::
locale () const
{
  return this->locale_.get ();
}

FilterLanguage::LocaleType& FilterLanguage::
locale ()
{
  return this->locale_.get ();
}

void FilterLanguage::
locale (const LocaleType& x)
{
  this->locale_.set (x);
}


// FilterMacRange
// 

const FilterMacRange::MinType& FilterMacRange::
min () const
{
  return this->min_.get ();
}

FilterMacRange::MinType& FilterMacRange::
min ()
{
  return this->min_.get ();
}

void FilterMacRange::
min (const MinType& x)
{
  this->min_.set (x);
}

void FilterMacRange::
min (::std::unique_ptr< MinType > x)
{
  this->min_.set (std::move (x));
}

const FilterMacRange::MaxType& FilterMacRange::
max () const
{
  return this->max_.get ();
}

FilterMacRange::MaxType& FilterMacRange::
max ()
{
  return this->max_.get ();
}

void FilterMacRange::
max (const MaxType& x)
{
  this->max_.set (x);
}

void FilterMacRange::
max (::std::unique_ptr< MaxType > x)
{
  this->max_.set (std::move (x));
}


// FilterMsi
// 

const FilterMsi::TypeType& FilterMsi::
type () const
{
  return this->type_.get ();
}

FilterMsi::TypeType& FilterMsi::
type ()
{
  return this->type_.get ();
}

void FilterMsi::
type (const TypeType& x)
{
  this->type_.set (x);
}

void FilterMsi::
type (::std::unique_ptr< TypeType > x)
{
  this->type_.set (std::move (x));
}

const FilterMsi::SubtypeType& FilterMsi::
subtype () const
{
  return this->subtype_.get ();
}

FilterMsi::SubtypeType& FilterMsi::
subtype ()
{
  return this->subtype_.get ();
}

void FilterMsi::
subtype (const SubtypeType& x)
{
  this->subtype_.set (x);
}

void FilterMsi::
subtype (::std::unique_ptr< SubtypeType > x)
{
  this->subtype_.set (std::move (x));
}

const FilterMsi::CodeOptional& FilterMsi::
code () const
{
  return this->code_;
}

FilterMsi::CodeOptional& FilterMsi::
code ()
{
  return this->code_;
}

void FilterMsi::
code (const CodeType& x)
{
  this->code_.set (x);
}

void FilterMsi::
code (const CodeOptional& x)
{
  this->code_ = x;
}

void FilterMsi::
code (::std::unique_ptr< CodeType > x)
{
  this->code_.set (std::move (x));
}

const FilterMsi::ItemOptional& FilterMsi::
item () const
{
  return this->item_;
}

FilterMsi::ItemOptional& FilterMsi::
item ()
{
  return this->item_;
}

void FilterMsi::
item (const ItemType& x)
{
  this->item_.set (x);
}

void FilterMsi::
item (const ItemOptional& x)
{
  this->item_ = x;
}

void FilterMsi::
item (::std::unique_ptr< ItemType > x)
{
  this->item_.set (std::move (x));
}

const FilterMsi::ValueOptional& FilterMsi::
value () const
{
  return this->value_;
}

FilterMsi::ValueOptional& FilterMsi::
value ()
{
  return this->value_;
}

void FilterMsi::
value (const ValueType& x)
{
  this->value_.set (x);
}

void FilterMsi::
value (const ValueOptional& x)
{
  this->value_ = x;
}

void FilterMsi::
value (::std::unique_ptr< ValueType > x)
{
  this->value_.set (std::move (x));
}

const FilterMsi::MinOptional& FilterMsi::
min () const
{
  return this->min_;
}

FilterMsi::MinOptional& FilterMsi::
min ()
{
  return this->min_;
}

void FilterMsi::
min (const MinType& x)
{
  this->min_.set (x);
}

void FilterMsi::
min (const MinOptional& x)
{
  this->min_ = x;
}

void FilterMsi::
min (::std::unique_ptr< MinType > x)
{
  this->min_.set (std::move (x));
}

const FilterMsi::MaxOptional& FilterMsi::
max () const
{
  return this->max_;
}

FilterMsi::MaxOptional& FilterMsi::
max ()
{
  return this->max_;
}

void FilterMsi::
max (const MaxType& x)
{
  this->max_.set (x);
}

void FilterMsi::
max (const MaxOptional& x)
{
  this->max_ = x;
}

void FilterMsi::
max (::std::unique_ptr< MaxType > x)
{
  this->max_.set (std::move (x));
}

const FilterMsi::GteType& FilterMsi::
gte () const
{
  return this->gte_.get ();
}

FilterMsi::GteType& FilterMsi::
gte ()
{
  return this->gte_.get ();
}

void FilterMsi::
gte (const GteType& x)
{
  this->gte_.set (x);
}

void FilterMsi::
gte (::std::unique_ptr< GteType > x)
{
  this->gte_.set (std::move (x));
}

const FilterMsi::GteType& FilterMsi::
gte_default_value ()
{
  return gte_default_value_;
}

const FilterMsi::LteType& FilterMsi::
lte () const
{
  return this->lte_.get ();
}

FilterMsi::LteType& FilterMsi::
lte ()
{
  return this->lte_.get ();
}

void FilterMsi::
lte (const LteType& x)
{
  this->lte_.set (x);
}

void FilterMsi::
lte (::std::unique_ptr< LteType > x)
{
  this->lte_.set (std::move (x));
}

const FilterMsi::LteType& FilterMsi::
lte_default_value ()
{
  return lte_default_value_;
}


// FilterOs
// 

const FilterOs::ClassType& FilterOs::
class_ () const
{
  return this->class__.get ();
}

FilterOs::ClassType& FilterOs::
class_ ()
{
  return this->class__.get ();
}

void FilterOs::
class_ (const ClassType& x)
{
  this->class__.set (x);
}

void FilterOs::
class_ (::std::unique_ptr< ClassType > x)
{
  this->class__.set (std::move (x));
}

const FilterOs::ClassType& FilterOs::
class_default_value ()
{
  return class__default_value_;
}

const FilterOs::VersionType& FilterOs::
version () const
{
  return this->version_.get ();
}

FilterOs::VersionType& FilterOs::
version ()
{
  return this->version_.get ();
}

void FilterOs::
version (const VersionType& x)
{
  this->version_.set (x);
}

void FilterOs::
version (::std::unique_ptr< VersionType > x)
{
  this->version_.set (std::move (x));
}

const FilterOs::VersionType& FilterOs::
version_default_value ()
{
  return version_default_value_;
}

const FilterOs::TypeType& FilterOs::
type () const
{
  return this->type_.get ();
}

FilterOs::TypeType& FilterOs::
type ()
{
  return this->type_.get ();
}

void FilterOs::
type (const TypeType& x)
{
  this->type_.set (x);
}

void FilterOs::
type (::std::unique_ptr< TypeType > x)
{
  this->type_.set (std::move (x));
}

const FilterOs::TypeType& FilterOs::
type_default_value ()
{
  return type_default_value_;
}

const FilterOs::EditionType& FilterOs::
edition () const
{
  return this->edition_.get ();
}

FilterOs::EditionType& FilterOs::
edition ()
{
  return this->edition_.get ();
}

void FilterOs::
edition (const EditionType& x)
{
  this->edition_.set (x);
}

void FilterOs::
edition (::std::unique_ptr< EditionType > x)
{
  this->edition_.set (std::move (x));
}

const FilterOs::EditionType& FilterOs::
edition_default_value ()
{
  return edition_default_value_;
}

const FilterOs::SpType& FilterOs::
sp () const
{
  return this->sp_.get ();
}

FilterOs::SpType& FilterOs::
sp ()
{
  return this->sp_.get ();
}

void FilterOs::
sp (const SpType& x)
{
  this->sp_.set (x);
}

void FilterOs::
sp (::std::unique_ptr< SpType > x)
{
  this->sp_.set (std::move (x));
}

const FilterOs::SpType& FilterOs::
sp_default_value ()
{
  return sp_default_value_;
}


// FilterOrgUnit
// 

const FilterOrgUnit::NameType& FilterOrgUnit::
name () const
{
  return this->name_.get ();
}

FilterOrgUnit::NameType& FilterOrgUnit::
name ()
{
  return this->name_.get ();
}

void FilterOrgUnit::
name (const NameType& x)
{
  this->name_.set (x);
}

void FilterOrgUnit::
name (::std::unique_ptr< NameType > x)
{
  this->name_.set (std::move (x));
}

const FilterOrgUnit::UserContextType& FilterOrgUnit::
userContext () const
{
  return this->userContext_.get ();
}

FilterOrgUnit::UserContextType& FilterOrgUnit::
userContext ()
{
  return this->userContext_.get ();
}

void FilterOrgUnit::
userContext (const UserContextType& x)
{
  this->userContext_.set (x);
}

void FilterOrgUnit::
userContext (::std::unique_ptr< UserContextType > x)
{
  this->userContext_.set (std::move (x));
}

const FilterOrgUnit::UserContextType& FilterOrgUnit::
userContext_default_value ()
{
  return userContext_default_value_;
}

const FilterOrgUnit::DirectMemberType& FilterOrgUnit::
directMember () const
{
  return this->directMember_.get ();
}

FilterOrgUnit::DirectMemberType& FilterOrgUnit::
directMember ()
{
  return this->directMember_.get ();
}

void FilterOrgUnit::
directMember (const DirectMemberType& x)
{
  this->directMember_.set (x);
}

void FilterOrgUnit::
directMember (::std::unique_ptr< DirectMemberType > x)
{
  this->directMember_.set (std::move (x));
}

const FilterOrgUnit::DirectMemberType& FilterOrgUnit::
directMember_default_value ()
{
  return directMember_default_value_;
}


// FilterPcmcia
// 


// FilterPortable
// 

const FilterPortable::UnknownType& FilterPortable::
unknown () const
{
  return this->unknown_.get ();
}

FilterPortable::UnknownType& FilterPortable::
unknown ()
{
  return this->unknown_.get ();
}

void FilterPortable::
unknown (const UnknownType& x)
{
  this->unknown_.set (x);
}

void FilterPortable::
unknown (::std::unique_ptr< UnknownType > x)
{
  this->unknown_.set (std::move (x));
}

const FilterPortable::UnknownType& FilterPortable::
unknown_default_value ()
{
  return unknown_default_value_;
}

const FilterPortable::DockedType& FilterPortable::
docked () const
{
  return this->docked_.get ();
}

FilterPortable::DockedType& FilterPortable::
docked ()
{
  return this->docked_.get ();
}

void FilterPortable::
docked (const DockedType& x)
{
  this->docked_.set (x);
}

void FilterPortable::
docked (::std::unique_ptr< DockedType > x)
{
  this->docked_.set (std::move (x));
}

const FilterPortable::DockedType& FilterPortable::
docked_default_value ()
{
  return docked_default_value_;
}

const FilterPortable::UndockedType& FilterPortable::
undocked () const
{
  return this->undocked_.get ();
}

FilterPortable::UndockedType& FilterPortable::
undocked ()
{
  return this->undocked_.get ();
}

void FilterPortable::
undocked (const UndockedType& x)
{
  this->undocked_.set (x);
}

void FilterPortable::
undocked (::std::unique_ptr< UndockedType > x)
{
  this->undocked_.set (std::move (x));
}

const FilterPortable::UndockedType& FilterPortable::
undocked_default_value ()
{
  return undocked_default_value_;
}


// FilterProcMode
// 

const FilterProcMode::SynchForeType& FilterProcMode::
synchFore () const
{
  return this->synchFore_.get ();
}

FilterProcMode::SynchForeType& FilterProcMode::
synchFore ()
{
  return this->synchFore_.get ();
}

void FilterProcMode::
synchFore (const SynchForeType& x)
{
  this->synchFore_.set (x);
}

void FilterProcMode::
synchFore (::std::unique_ptr< SynchForeType > x)
{
  this->synchFore_.set (std::move (x));
}

const FilterProcMode::SynchForeType& FilterProcMode::
synchFore_default_value ()
{
  return synchFore_default_value_;
}

const FilterProcMode::AsynchForeType& FilterProcMode::
asynchFore () const
{
  return this->asynchFore_.get ();
}

FilterProcMode::AsynchForeType& FilterProcMode::
asynchFore ()
{
  return this->asynchFore_.get ();
}

void FilterProcMode::
asynchFore (const AsynchForeType& x)
{
  this->asynchFore_.set (x);
}

void FilterProcMode::
asynchFore (::std::unique_ptr< AsynchForeType > x)
{
  this->asynchFore_.set (std::move (x));
}

const FilterProcMode::AsynchForeType& FilterProcMode::
asynchFore_default_value ()
{
  return asynchFore_default_value_;
}

const FilterProcMode::BackRefrType& FilterProcMode::
backRefr () const
{
  return this->backRefr_.get ();
}

FilterProcMode::BackRefrType& FilterProcMode::
backRefr ()
{
  return this->backRefr_.get ();
}

void FilterProcMode::
backRefr (const BackRefrType& x)
{
  this->backRefr_.set (x);
}

void FilterProcMode::
backRefr (::std::unique_ptr< BackRefrType > x)
{
  this->backRefr_.set (std::move (x));
}

const FilterProcMode::BackRefrType& FilterProcMode::
backRefr_default_value ()
{
  return backRefr_default_value_;
}

const FilterProcMode::ForceRefrType& FilterProcMode::
forceRefr () const
{
  return this->forceRefr_.get ();
}

FilterProcMode::ForceRefrType& FilterProcMode::
forceRefr ()
{
  return this->forceRefr_.get ();
}

void FilterProcMode::
forceRefr (const ForceRefrType& x)
{
  this->forceRefr_.set (x);
}

void FilterProcMode::
forceRefr (::std::unique_ptr< ForceRefrType > x)
{
  this->forceRefr_.set (std::move (x));
}

const FilterProcMode::ForceRefrType& FilterProcMode::
forceRefr_default_value ()
{
  return forceRefr_default_value_;
}

const FilterProcMode::LinkTrnsType& FilterProcMode::
linkTrns () const
{
  return this->linkTrns_.get ();
}

FilterProcMode::LinkTrnsType& FilterProcMode::
linkTrns ()
{
  return this->linkTrns_.get ();
}

void FilterProcMode::
linkTrns (const LinkTrnsType& x)
{
  this->linkTrns_.set (x);
}

void FilterProcMode::
linkTrns (::std::unique_ptr< LinkTrnsType > x)
{
  this->linkTrns_.set (std::move (x));
}

const FilterProcMode::LinkTrnsType& FilterProcMode::
linkTrns_default_value ()
{
  return linkTrns_default_value_;
}

const FilterProcMode::NoChgType& FilterProcMode::
noChg () const
{
  return this->noChg_.get ();
}

FilterProcMode::NoChgType& FilterProcMode::
noChg ()
{
  return this->noChg_.get ();
}

void FilterProcMode::
noChg (const NoChgType& x)
{
  this->noChg_.set (x);
}

void FilterProcMode::
noChg (::std::unique_ptr< NoChgType > x)
{
  this->noChg_.set (std::move (x));
}

const FilterProcMode::NoChgType& FilterProcMode::
noChg_default_value ()
{
  return noChg_default_value_;
}

const FilterProcMode::RsopTrnsType& FilterProcMode::
rsopTrns () const
{
  return this->rsopTrns_.get ();
}

FilterProcMode::RsopTrnsType& FilterProcMode::
rsopTrns ()
{
  return this->rsopTrns_.get ();
}

void FilterProcMode::
rsopTrns (const RsopTrnsType& x)
{
  this->rsopTrns_.set (x);
}

void FilterProcMode::
rsopTrns (::std::unique_ptr< RsopTrnsType > x)
{
  this->rsopTrns_.set (std::move (x));
}

const FilterProcMode::RsopTrnsType& FilterProcMode::
rsopTrns_default_value ()
{
  return rsopTrns_default_value_;
}

const FilterProcMode::SafeBootType& FilterProcMode::
safeBoot () const
{
  return this->safeBoot_.get ();
}

FilterProcMode::SafeBootType& FilterProcMode::
safeBoot ()
{
  return this->safeBoot_.get ();
}

void FilterProcMode::
safeBoot (const SafeBootType& x)
{
  this->safeBoot_.set (x);
}

void FilterProcMode::
safeBoot (::std::unique_ptr< SafeBootType > x)
{
  this->safeBoot_.set (std::move (x));
}

const FilterProcMode::SafeBootType& FilterProcMode::
safeBoot_default_value ()
{
  return safeBoot_default_value_;
}

const FilterProcMode::SlowLinkType& FilterProcMode::
slowLink () const
{
  return this->slowLink_.get ();
}

FilterProcMode::SlowLinkType& FilterProcMode::
slowLink ()
{
  return this->slowLink_.get ();
}

void FilterProcMode::
slowLink (const SlowLinkType& x)
{
  this->slowLink_.set (x);
}

void FilterProcMode::
slowLink (::std::unique_ptr< SlowLinkType > x)
{
  this->slowLink_.set (std::move (x));
}

const FilterProcMode::SlowLinkType& FilterProcMode::
slowLink_default_value ()
{
  return slowLink_default_value_;
}

const FilterProcMode::VerbLogType& FilterProcMode::
verbLog () const
{
  return this->verbLog_.get ();
}

FilterProcMode::VerbLogType& FilterProcMode::
verbLog ()
{
  return this->verbLog_.get ();
}

void FilterProcMode::
verbLog (const VerbLogType& x)
{
  this->verbLog_.set (x);
}

void FilterProcMode::
verbLog (::std::unique_ptr< VerbLogType > x)
{
  this->verbLog_.set (std::move (x));
}

const FilterProcMode::VerbLogType& FilterProcMode::
verbLog_default_value ()
{
  return verbLog_default_value_;
}

const FilterProcMode::RsopEnblType& FilterProcMode::
rsopEnbl () const
{
  return this->rsopEnbl_.get ();
}

FilterProcMode::RsopEnblType& FilterProcMode::
rsopEnbl ()
{
  return this->rsopEnbl_.get ();
}

void FilterProcMode::
rsopEnbl (const RsopEnblType& x)
{
  this->rsopEnbl_.set (x);
}

void FilterProcMode::
rsopEnbl (::std::unique_ptr< RsopEnblType > x)
{
  this->rsopEnbl_.set (std::move (x));
}

const FilterProcMode::RsopEnblType& FilterProcMode::
rsopEnbl_default_value ()
{
  return rsopEnbl_default_value_;
}


// FilterRam
// 

const FilterRam::TotalMBType& FilterRam::
totalMB () const
{
  return this->totalMB_.get ();
}

FilterRam::TotalMBType& FilterRam::
totalMB ()
{
  return this->totalMB_.get ();
}

void FilterRam::
totalMB (const TotalMBType& x)
{
  this->totalMB_.set (x);
}


// FilterRegistry
// 

const FilterRegistry::TypeType& FilterRegistry::
type () const
{
  return this->type_.get ();
}

FilterRegistry::TypeType& FilterRegistry::
type ()
{
  return this->type_.get ();
}

void FilterRegistry::
type (const TypeType& x)
{
  this->type_.set (x);
}

void FilterRegistry::
type (::std::unique_ptr< TypeType > x)
{
  this->type_.set (std::move (x));
}

const FilterRegistry::TypeType& FilterRegistry::
type_default_value ()
{
  return type_default_value_;
}

const FilterRegistry::SubtypeType& FilterRegistry::
subtype () const
{
  return this->subtype_.get ();
}

FilterRegistry::SubtypeType& FilterRegistry::
subtype ()
{
  return this->subtype_.get ();
}

void FilterRegistry::
subtype (const SubtypeType& x)
{
  this->subtype_.set (x);
}

void FilterRegistry::
subtype (::std::unique_ptr< SubtypeType > x)
{
  this->subtype_.set (std::move (x));
}

const FilterRegistry::SubtypeType& FilterRegistry::
subtype_default_value ()
{
  return subtype_default_value_;
}

const FilterRegistry::ValueNameOptional& FilterRegistry::
valueName () const
{
  return this->valueName_;
}

FilterRegistry::ValueNameOptional& FilterRegistry::
valueName ()
{
  return this->valueName_;
}

void FilterRegistry::
valueName (const ValueNameType& x)
{
  this->valueName_.set (x);
}

void FilterRegistry::
valueName (const ValueNameOptional& x)
{
  this->valueName_ = x;
}

void FilterRegistry::
valueName (::std::unique_ptr< ValueNameType > x)
{
  this->valueName_.set (std::move (x));
}

const FilterRegistry::ValueTypeType& FilterRegistry::
valueType () const
{
  return this->valueType_.get ();
}

FilterRegistry::ValueTypeType& FilterRegistry::
valueType ()
{
  return this->valueType_.get ();
}

void FilterRegistry::
valueType (const ValueTypeType& x)
{
  this->valueType_.set (x);
}

void FilterRegistry::
valueType (::std::unique_ptr< ValueTypeType > x)
{
  this->valueType_.set (std::move (x));
}

const FilterRegistry::ValueTypeType& FilterRegistry::
valueType_default_value ()
{
  return valueType_default_value_;
}

const FilterRegistry::ValueDataOptional& FilterRegistry::
valueData () const
{
  return this->valueData_;
}

FilterRegistry::ValueDataOptional& FilterRegistry::
valueData ()
{
  return this->valueData_;
}

void FilterRegistry::
valueData (const ValueDataType& x)
{
  this->valueData_.set (x);
}

void FilterRegistry::
valueData (const ValueDataOptional& x)
{
  this->valueData_ = x;
}

void FilterRegistry::
valueData (::std::unique_ptr< ValueDataType > x)
{
  this->valueData_.set (std::move (x));
}

const FilterRegistry::VariableNameOptional& FilterRegistry::
variableName () const
{
  return this->variableName_;
}

FilterRegistry::VariableNameOptional& FilterRegistry::
variableName ()
{
  return this->variableName_;
}

void FilterRegistry::
variableName (const VariableNameType& x)
{
  this->variableName_.set (x);
}

void FilterRegistry::
variableName (const VariableNameOptional& x)
{
  this->variableName_ = x;
}

void FilterRegistry::
variableName (::std::unique_ptr< VariableNameType > x)
{
  this->variableName_.set (std::move (x));
}

const FilterRegistry::KeyType& FilterRegistry::
key () const
{
  return this->key_.get ();
}

FilterRegistry::KeyType& FilterRegistry::
key ()
{
  return this->key_.get ();
}

void FilterRegistry::
key (const KeyType& x)
{
  this->key_.set (x);
}

void FilterRegistry::
key (::std::unique_ptr< KeyType > x)
{
  this->key_.set (std::move (x));
}

const FilterRegistry::HiveType& FilterRegistry::
hive () const
{
  return this->hive_.get ();
}

FilterRegistry::HiveType& FilterRegistry::
hive ()
{
  return this->hive_.get ();
}

void FilterRegistry::
hive (const HiveType& x)
{
  this->hive_.set (x);
}

void FilterRegistry::
hive (::std::unique_ptr< HiveType > x)
{
  this->hive_.set (std::move (x));
}

const FilterRegistry::HiveType& FilterRegistry::
hive_default_value ()
{
  return hive_default_value_;
}

const FilterRegistry::MinOptional& FilterRegistry::
min () const
{
  return this->min_;
}

FilterRegistry::MinOptional& FilterRegistry::
min ()
{
  return this->min_;
}

void FilterRegistry::
min (const MinType& x)
{
  this->min_.set (x);
}

void FilterRegistry::
min (const MinOptional& x)
{
  this->min_ = x;
}

void FilterRegistry::
min (::std::unique_ptr< MinType > x)
{
  this->min_.set (std::move (x));
}

const FilterRegistry::MaxOptional& FilterRegistry::
max () const
{
  return this->max_;
}

FilterRegistry::MaxOptional& FilterRegistry::
max ()
{
  return this->max_;
}

void FilterRegistry::
max (const MaxType& x)
{
  this->max_.set (x);
}

void FilterRegistry::
max (const MaxOptional& x)
{
  this->max_ = x;
}

void FilterRegistry::
max (::std::unique_ptr< MaxType > x)
{
  this->max_.set (std::move (x));
}

const FilterRegistry::GteType& FilterRegistry::
gte () const
{
  return this->gte_.get ();
}

FilterRegistry::GteType& FilterRegistry::
gte ()
{
  return this->gte_.get ();
}

void FilterRegistry::
gte (const GteType& x)
{
  this->gte_.set (x);
}

void FilterRegistry::
gte (::std::unique_ptr< GteType > x)
{
  this->gte_.set (std::move (x));
}

const FilterRegistry::GteType& FilterRegistry::
gte_default_value ()
{
  return gte_default_value_;
}

const FilterRegistry::LteType& FilterRegistry::
lte () const
{
  return this->lte_.get ();
}

FilterRegistry::LteType& FilterRegistry::
lte ()
{
  return this->lte_.get ();
}

void FilterRegistry::
lte (const LteType& x)
{
  this->lte_.set (x);
}

void FilterRegistry::
lte (::std::unique_ptr< LteType > x)
{
  this->lte_.set (std::move (x));
}

const FilterRegistry::LteType& FilterRegistry::
lte_default_value ()
{
  return lte_default_value_;
}

const FilterRegistry::VersionOptional& FilterRegistry::
version () const
{
  return this->version_;
}

FilterRegistry::VersionOptional& FilterRegistry::
version ()
{
  return this->version_;
}

void FilterRegistry::
version (const VersionType& x)
{
  this->version_.set (x);
}

void FilterRegistry::
version (const VersionOptional& x)
{
  this->version_ = x;
}

void FilterRegistry::
version (::std::unique_ptr< VersionType > x)
{
  this->version_.set (std::move (x));
}


// FilterTerminal
// 

const FilterTerminal::TypeType& FilterTerminal::
type () const
{
  return this->type_.get ();
}

FilterTerminal::TypeType& FilterTerminal::
type ()
{
  return this->type_.get ();
}

void FilterTerminal::
type (const TypeType& x)
{
  this->type_.set (x);
}

void FilterTerminal::
type (::std::unique_ptr< TypeType > x)
{
  this->type_.set (std::move (x));
}

const FilterTerminal::OptionType& FilterTerminal::
option () const
{
  return this->option_.get ();
}

FilterTerminal::OptionType& FilterTerminal::
option ()
{
  return this->option_.get ();
}

void FilterTerminal::
option (const OptionType& x)
{
  this->option_.set (x);
}

void FilterTerminal::
option (::std::unique_ptr< OptionType > x)
{
  this->option_.set (std::move (x));
}

const FilterTerminal::ValueType& FilterTerminal::
value () const
{
  return this->value_.get ();
}

FilterTerminal::ValueType& FilterTerminal::
value ()
{
  return this->value_.get ();
}

void FilterTerminal::
value (const ValueType& x)
{
  this->value_.set (x);
}

void FilterTerminal::
value (::std::unique_ptr< ValueType > x)
{
  this->value_.set (std::move (x));
}

const FilterTerminal::ValueType& FilterTerminal::
value_default_value ()
{
  return value_default_value_;
}

const FilterTerminal::MinType& FilterTerminal::
min () const
{
  return this->min_.get ();
}

FilterTerminal::MinType& FilterTerminal::
min ()
{
  return this->min_.get ();
}

void FilterTerminal::
min (const MinType& x)
{
  this->min_.set (x);
}

void FilterTerminal::
min (::std::unique_ptr< MinType > x)
{
  this->min_.set (std::move (x));
}

const FilterTerminal::MinType& FilterTerminal::
min_default_value ()
{
  return min_default_value_;
}

const FilterTerminal::MaxType& FilterTerminal::
max () const
{
  return this->max_.get ();
}

FilterTerminal::MaxType& FilterTerminal::
max ()
{
  return this->max_.get ();
}

void FilterTerminal::
max (const MaxType& x)
{
  this->max_.set (x);
}

void FilterTerminal::
max (::std::unique_ptr< MaxType > x)
{
  this->max_.set (std::move (x));
}

const FilterTerminal::MaxType& FilterTerminal::
max_default_value ()
{
  return max_default_value_;
}


// FilterTime
// 

const FilterTime::BeginType& FilterTime::
begin () const
{
  return this->begin_.get ();
}

FilterTime::BeginType& FilterTime::
begin ()
{
  return this->begin_.get ();
}

void FilterTime::
begin (const BeginType& x)
{
  this->begin_.set (x);
}

void FilterTime::
begin (::std::unique_ptr< BeginType > x)
{
  this->begin_.set (std::move (x));
}

const FilterTime::EndType& FilterTime::
end () const
{
  return this->end_.get ();
}

FilterTime::EndType& FilterTime::
end ()
{
  return this->end_.get ();
}

void FilterTime::
end (const EndType& x)
{
  this->end_.set (x);
}

void FilterTime::
end (::std::unique_ptr< EndType > x)
{
  this->end_.set (std::move (x));
}


// FilterUser
// 

const FilterUser::NameOptional& FilterUser::
name () const
{
  return this->name_;
}

FilterUser::NameOptional& FilterUser::
name ()
{
  return this->name_;
}

void FilterUser::
name (const NameType& x)
{
  this->name_.set (x);
}

void FilterUser::
name (const NameOptional& x)
{
  this->name_ = x;
}

void FilterUser::
name (::std::unique_ptr< NameType > x)
{
  this->name_.set (std::move (x));
}

const FilterUser::SidOptional& FilterUser::
sid () const
{
  return this->sid_;
}

FilterUser::SidOptional& FilterUser::
sid ()
{
  return this->sid_;
}

void FilterUser::
sid (const SidType& x)
{
  this->sid_.set (x);
}

void FilterUser::
sid (const SidOptional& x)
{
  this->sid_ = x;
}

void FilterUser::
sid (::std::unique_ptr< SidType > x)
{
  this->sid_.set (std::move (x));
}


// FilterWmi
// 

const FilterWmi::QueryType& FilterWmi::
query () const
{
  return this->query_.get ();
}

FilterWmi::QueryType& FilterWmi::
query ()
{
  return this->query_.get ();
}

void FilterWmi::
query (const QueryType& x)
{
  this->query_.set (x);
}

void FilterWmi::
query (::std::unique_ptr< QueryType > x)
{
  this->query_.set (std::move (x));
}

const FilterWmi::NameSpaceType& FilterWmi::
nameSpace () const
{
  return this->nameSpace_.get ();
}

FilterWmi::NameSpaceType& FilterWmi::
nameSpace ()
{
  return this->nameSpace_.get ();
}

void FilterWmi::
nameSpace (const NameSpaceType& x)
{
  this->nameSpace_.set (x);
}

void FilterWmi::
nameSpace (::std::unique_ptr< NameSpaceType > x)
{
  this->nameSpace_.set (std::move (x));
}

const FilterWmi::NameSpaceType& FilterWmi::
nameSpace_default_value ()
{
  return nameSpace_default_value_;
}

const FilterWmi::PropertyOptional& FilterWmi::
property () const
{
  return this->property_;
}

FilterWmi::PropertyOptional& FilterWmi::
property ()
{
  return this->property_;
}

void FilterWmi::
property (const PropertyType& x)
{
  this->property_.set (x);
}

void FilterWmi::
property (const PropertyOptional& x)
{
  this->property_ = x;
}

void FilterWmi::
property (::std::unique_ptr< PropertyType > x)
{
  this->property_.set (std::move (x));
}

const FilterWmi::VariableNameOptional& FilterWmi::
variableName () const
{
  return this->variableName_;
}

FilterWmi::VariableNameOptional& FilterWmi::
variableName ()
{
  return this->variableName_;
}

void FilterWmi::
variableName (const VariableNameType& x)
{
  this->variableName_.set (x);
}

void FilterWmi::
variableName (const VariableNameOptional& x)
{
  this->variableName_ = x;
}

void FilterWmi::
variableName (::std::unique_ptr< VariableNameType > x)
{
  this->variableName_.set (std::move (x));
}


// FilterCollection
// 

const FilterCollection::FilterSiteSequence& FilterCollection::
FilterSite () const
{
  return this->FilterSite_;
}

FilterCollection::FilterSiteSequence& FilterCollection::
FilterSite ()
{
  return this->FilterSite_;
}

void FilterCollection::
FilterSite (const FilterSiteSequence& s)
{
  this->FilterSite_ = s;
}

const FilterCollection::FilterGroupSequence& FilterCollection::
FilterGroup () const
{
  return this->FilterGroup_;
}

FilterCollection::FilterGroupSequence& FilterCollection::
FilterGroup ()
{
  return this->FilterGroup_;
}

void FilterCollection::
FilterGroup (const FilterGroupSequence& s)
{
  this->FilterGroup_ = s;
}

const FilterCollection::FilterRunOnceSequence& FilterCollection::
FilterRunOnce () const
{
  return this->FilterRunOnce_;
}

FilterCollection::FilterRunOnceSequence& FilterCollection::
FilterRunOnce ()
{
  return this->FilterRunOnce_;
}

void FilterCollection::
FilterRunOnce (const FilterRunOnceSequence& s)
{
  this->FilterRunOnce_ = s;
}

const FilterCollection::FilterLdapSequence& FilterCollection::
FilterLdap () const
{
  return this->FilterLdap_;
}

FilterCollection::FilterLdapSequence& FilterCollection::
FilterLdap ()
{
  return this->FilterLdap_;
}

void FilterCollection::
FilterLdap (const FilterLdapSequence& s)
{
  this->FilterLdap_ = s;
}

const FilterCollection::FilterBatterySequence& FilterCollection::
FilterBattery () const
{
  return this->FilterBattery_;
}

FilterCollection::FilterBatterySequence& FilterCollection::
FilterBattery ()
{
  return this->FilterBattery_;
}

void FilterCollection::
FilterBattery (const FilterBatterySequence& s)
{
  this->FilterBattery_ = s;
}

const FilterCollection::FilterComputerSequence& FilterCollection::
FilterComputer () const
{
  return this->FilterComputer_;
}

FilterCollection::FilterComputerSequence& FilterCollection::
FilterComputer ()
{
  return this->FilterComputer_;
}

void FilterCollection::
FilterComputer (const FilterComputerSequence& s)
{
  this->FilterComputer_ = s;
}

const FilterCollection::FilterCpuSequence& FilterCollection::
FilterCpu () const
{
  return this->FilterCpu_;
}

FilterCollection::FilterCpuSequence& FilterCollection::
FilterCpu ()
{
  return this->FilterCpu_;
}

void FilterCollection::
FilterCpu (const FilterCpuSequence& s)
{
  this->FilterCpu_ = s;
}

const FilterCollection::FilterDateSequence& FilterCollection::
FilterDate () const
{
  return this->FilterDate_;
}

FilterCollection::FilterDateSequence& FilterCollection::
FilterDate ()
{
  return this->FilterDate_;
}

void FilterCollection::
FilterDate (const FilterDateSequence& s)
{
  this->FilterDate_ = s;
}

const FilterCollection::FilterDunSequence& FilterCollection::
FilterDun () const
{
  return this->FilterDun_;
}

FilterCollection::FilterDunSequence& FilterCollection::
FilterDun ()
{
  return this->FilterDun_;
}

void FilterCollection::
FilterDun (const FilterDunSequence& s)
{
  this->FilterDun_ = s;
}

const FilterCollection::FilterDiskSequence& FilterCollection::
FilterDisk () const
{
  return this->FilterDisk_;
}

FilterCollection::FilterDiskSequence& FilterCollection::
FilterDisk ()
{
  return this->FilterDisk_;
}

void FilterCollection::
FilterDisk (const FilterDiskSequence& s)
{
  this->FilterDisk_ = s;
}

const FilterCollection::FilterDomainSequence& FilterCollection::
FilterDomain () const
{
  return this->FilterDomain_;
}

FilterCollection::FilterDomainSequence& FilterCollection::
FilterDomain ()
{
  return this->FilterDomain_;
}

void FilterCollection::
FilterDomain (const FilterDomainSequence& s)
{
  this->FilterDomain_ = s;
}

const FilterCollection::FilterVariableSequence& FilterCollection::
FilterVariable () const
{
  return this->FilterVariable_;
}

FilterCollection::FilterVariableSequence& FilterCollection::
FilterVariable ()
{
  return this->FilterVariable_;
}

void FilterCollection::
FilterVariable (const FilterVariableSequence& s)
{
  this->FilterVariable_ = s;
}

const FilterCollection::FilterFileSequence& FilterCollection::
FilterFile () const
{
  return this->FilterFile_;
}

FilterCollection::FilterFileSequence& FilterCollection::
FilterFile ()
{
  return this->FilterFile_;
}

void FilterCollection::
FilterFile (const FilterFileSequence& s)
{
  this->FilterFile_ = s;
}

const FilterCollection::FilterIpRangeSequence& FilterCollection::
FilterIpRange () const
{
  return this->FilterIpRange_;
}

FilterCollection::FilterIpRangeSequence& FilterCollection::
FilterIpRange ()
{
  return this->FilterIpRange_;
}

void FilterCollection::
FilterIpRange (const FilterIpRangeSequence& s)
{
  this->FilterIpRange_ = s;
}

const FilterCollection::FilterLanguageSequence& FilterCollection::
FilterLanguage () const
{
  return this->FilterLanguage_;
}

FilterCollection::FilterLanguageSequence& FilterCollection::
FilterLanguage ()
{
  return this->FilterLanguage_;
}

void FilterCollection::
FilterLanguage (const FilterLanguageSequence& s)
{
  this->FilterLanguage_ = s;
}

const FilterCollection::FilterMacRangeSequence& FilterCollection::
FilterMacRange () const
{
  return this->FilterMacRange_;
}

FilterCollection::FilterMacRangeSequence& FilterCollection::
FilterMacRange ()
{
  return this->FilterMacRange_;
}

void FilterCollection::
FilterMacRange (const FilterMacRangeSequence& s)
{
  this->FilterMacRange_ = s;
}

const FilterCollection::FilterMsiSequence& FilterCollection::
FilterMsi () const
{
  return this->FilterMsi_;
}

FilterCollection::FilterMsiSequence& FilterCollection::
FilterMsi ()
{
  return this->FilterMsi_;
}

void FilterCollection::
FilterMsi (const FilterMsiSequence& s)
{
  this->FilterMsi_ = s;
}

const FilterCollection::FilterOsSequence& FilterCollection::
FilterOs () const
{
  return this->FilterOs_;
}

FilterCollection::FilterOsSequence& FilterCollection::
FilterOs ()
{
  return this->FilterOs_;
}

void FilterCollection::
FilterOs (const FilterOsSequence& s)
{
  this->FilterOs_ = s;
}

const FilterCollection::FilterOrgUnitSequence& FilterCollection::
FilterOrgUnit () const
{
  return this->FilterOrgUnit_;
}

FilterCollection::FilterOrgUnitSequence& FilterCollection::
FilterOrgUnit ()
{
  return this->FilterOrgUnit_;
}

void FilterCollection::
FilterOrgUnit (const FilterOrgUnitSequence& s)
{
  this->FilterOrgUnit_ = s;
}

const FilterCollection::FilterPcmciaSequence& FilterCollection::
FilterPcmcia () const
{
  return this->FilterPcmcia_;
}

FilterCollection::FilterPcmciaSequence& FilterCollection::
FilterPcmcia ()
{
  return this->FilterPcmcia_;
}

void FilterCollection::
FilterPcmcia (const FilterPcmciaSequence& s)
{
  this->FilterPcmcia_ = s;
}

const FilterCollection::FilterPortableSequence& FilterCollection::
FilterPortable () const
{
  return this->FilterPortable_;
}

FilterCollection::FilterPortableSequence& FilterCollection::
FilterPortable ()
{
  return this->FilterPortable_;
}

void FilterCollection::
FilterPortable (const FilterPortableSequence& s)
{
  this->FilterPortable_ = s;
}

const FilterCollection::FilterProcModeSequence& FilterCollection::
FilterProcMode () const
{
  return this->FilterProcMode_;
}

FilterCollection::FilterProcModeSequence& FilterCollection::
FilterProcMode ()
{
  return this->FilterProcMode_;
}

void FilterCollection::
FilterProcMode (const FilterProcModeSequence& s)
{
  this->FilterProcMode_ = s;
}

const FilterCollection::FilterRamSequence& FilterCollection::
FilterRam () const
{
  return this->FilterRam_;
}

FilterCollection::FilterRamSequence& FilterCollection::
FilterRam ()
{
  return this->FilterRam_;
}

void FilterCollection::
FilterRam (const FilterRamSequence& s)
{
  this->FilterRam_ = s;
}

const FilterCollection::FilterRegistrySequence& FilterCollection::
FilterRegistry () const
{
  return this->FilterRegistry_;
}

FilterCollection::FilterRegistrySequence& FilterCollection::
FilterRegistry ()
{
  return this->FilterRegistry_;
}

void FilterCollection::
FilterRegistry (const FilterRegistrySequence& s)
{
  this->FilterRegistry_ = s;
}

const FilterCollection::FilterTerminalSequence& FilterCollection::
FilterTerminal () const
{
  return this->FilterTerminal_;
}

FilterCollection::FilterTerminalSequence& FilterCollection::
FilterTerminal ()
{
  return this->FilterTerminal_;
}

void FilterCollection::
FilterTerminal (const FilterTerminalSequence& s)
{
  this->FilterTerminal_ = s;
}

const FilterCollection::FilterTimeSequence& FilterCollection::
FilterTime () const
{
  return this->FilterTime_;
}

FilterCollection::FilterTimeSequence& FilterCollection::
FilterTime ()
{
  return this->FilterTime_;
}

void FilterCollection::
FilterTime (const FilterTimeSequence& s)
{
  this->FilterTime_ = s;
}

const FilterCollection::FilterUserSequence& FilterCollection::
FilterUser () const
{
  return this->FilterUser_;
}

FilterCollection::FilterUserSequence& FilterCollection::
FilterUser ()
{
  return this->FilterUser_;
}

void FilterCollection::
FilterUser (const FilterUserSequence& s)
{
  this->FilterUser_ = s;
}

const FilterCollection::FilterWmiSequence& FilterCollection::
FilterWmi () const
{
  return this->FilterWmi_;
}

FilterCollection::FilterWmiSequence& FilterCollection::
FilterWmi ()
{
  return this->FilterWmi_;
}

void FilterCollection::
FilterWmi (const FilterWmiSequence& s)
{
  this->FilterWmi_ = s;
}

const FilterCollection::FilterCollection1Sequence& FilterCollection::
FilterCollection1 () const
{
  return this->FilterCollection1_;
}

FilterCollection::FilterCollection1Sequence& FilterCollection::
FilterCollection1 ()
{
  return this->FilterCollection1_;
}

void FilterCollection::
FilterCollection1 (const FilterCollection1Sequence& s)
{
  this->FilterCollection1_ = s;
}

const FilterCollection::NameOptional& FilterCollection::
name () const
{
  return this->name_;
}

FilterCollection::NameOptional& FilterCollection::
name ()
{
  return this->name_;
}

void FilterCollection::
name (const NameType& x)
{
  this->name_.set (x);
}

void FilterCollection::
name (const NameOptional& x)
{
  this->name_ = x;
}

void FilterCollection::
name (::std::unique_ptr< NameType > x)
{
  this->name_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// EnumFilterTerminalOption
//

EnumFilterTerminalOption::
EnumFilterTerminalOption (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterTerminalOption_convert ();
}

EnumFilterTerminalOption::
EnumFilterTerminalOption (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterTerminalOption_convert ();
}

EnumFilterTerminalOption::
EnumFilterTerminalOption (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterTerminalOption_convert ();
}

EnumFilterTerminalOption* EnumFilterTerminalOption::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterTerminalOption (*this, f, c);
}

EnumFilterTerminalOption::Value EnumFilterTerminalOption::
_xsd_EnumFilterTerminalOption_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterTerminalOption_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterTerminalOption_indexes_,
                    _xsd_EnumFilterTerminalOption_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_EnumFilterTerminalOption_indexes_ + 7 || _xsd_EnumFilterTerminalOption_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterTerminalOption::
_xsd_EnumFilterTerminalOption_literals_[7] =
{
  "APPLICATION",
  "PROGRAM",
  "CLIENT",
  "SESSION",
  "DIRECTORY",
  "IP",
  "NE"
};

const EnumFilterTerminalOption::Value EnumFilterTerminalOption::
_xsd_EnumFilterTerminalOption_indexes_[7] =
{
  ::EnumFilterTerminalOption::APPLICATION,
  ::EnumFilterTerminalOption::CLIENT,
  ::EnumFilterTerminalOption::DIRECTORY,
  ::EnumFilterTerminalOption::IP,
  ::EnumFilterTerminalOption::NE,
  ::EnumFilterTerminalOption::PROGRAM,
  ::EnumFilterTerminalOption::SESSION
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterTerminalOption >
_xsd_EnumFilterTerminalOption_type_factory_init (
  "enumFilterTerminalOption",
  "");

// EnumFilterTerminalType
//

EnumFilterTerminalType::
EnumFilterTerminalType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterTerminalType_convert ();
}

EnumFilterTerminalType::
EnumFilterTerminalType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterTerminalType_convert ();
}

EnumFilterTerminalType::
EnumFilterTerminalType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterTerminalType_convert ();
}

EnumFilterTerminalType* EnumFilterTerminalType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterTerminalType (*this, f, c);
}

EnumFilterTerminalType::Value EnumFilterTerminalType::
_xsd_EnumFilterTerminalType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterTerminalType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterTerminalType_indexes_,
                    _xsd_EnumFilterTerminalType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_EnumFilterTerminalType_indexes_ + 3 || _xsd_EnumFilterTerminalType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterTerminalType::
_xsd_EnumFilterTerminalType_literals_[3] =
{
  "NE",
  "TS",
  "CONSOLE"
};

const EnumFilterTerminalType::Value EnumFilterTerminalType::
_xsd_EnumFilterTerminalType_indexes_[3] =
{
  ::EnumFilterTerminalType::CONSOLE,
  ::EnumFilterTerminalType::NE,
  ::EnumFilterTerminalType::TS
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterTerminalType >
_xsd_EnumFilterTerminalType_type_factory_init (
  "enumFilterTerminalType",
  "");

// EnumFilterRegistryHive
//

EnumFilterRegistryHive::
EnumFilterRegistryHive (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterRegistryHive_convert ();
}

EnumFilterRegistryHive::
EnumFilterRegistryHive (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterRegistryHive_convert ();
}

EnumFilterRegistryHive::
EnumFilterRegistryHive (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterRegistryHive_convert ();
}

EnumFilterRegistryHive* EnumFilterRegistryHive::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterRegistryHive (*this, f, c);
}

EnumFilterRegistryHive::Value EnumFilterRegistryHive::
_xsd_EnumFilterRegistryHive_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterRegistryHive_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterRegistryHive_indexes_,
                    _xsd_EnumFilterRegistryHive_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_EnumFilterRegistryHive_indexes_ + 5 || _xsd_EnumFilterRegistryHive_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterRegistryHive::
_xsd_EnumFilterRegistryHive_literals_[5] =
{
  "HKEY_LOCAL_MACHINE",
  "HKEY_CLASSES_ROOT",
  "HKEY_CURRENT_USER",
  "HKEY_CURRENT_CONFIG",
  "HKEY_USERS"
};

const EnumFilterRegistryHive::Value EnumFilterRegistryHive::
_xsd_EnumFilterRegistryHive_indexes_[5] =
{
  ::EnumFilterRegistryHive::HKEY_CLASSES_ROOT,
  ::EnumFilterRegistryHive::HKEY_CURRENT_CONFIG,
  ::EnumFilterRegistryHive::HKEY_CURRENT_USER,
  ::EnumFilterRegistryHive::HKEY_LOCAL_MACHINE,
  ::EnumFilterRegistryHive::HKEY_USERS
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterRegistryHive >
_xsd_EnumFilterRegistryHive_type_factory_init (
  "enumFilterRegistryHive",
  "");

// EnumFilterRegistryValueType
//

EnumFilterRegistryValueType::
EnumFilterRegistryValueType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterRegistryValueType_convert ();
}

EnumFilterRegistryValueType::
EnumFilterRegistryValueType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterRegistryValueType_convert ();
}

EnumFilterRegistryValueType::
EnumFilterRegistryValueType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterRegistryValueType_convert ();
}

EnumFilterRegistryValueType* EnumFilterRegistryValueType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterRegistryValueType (*this, f, c);
}

EnumFilterRegistryValueType::Value EnumFilterRegistryValueType::
_xsd_EnumFilterRegistryValueType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterRegistryValueType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterRegistryValueType_indexes_,
                    _xsd_EnumFilterRegistryValueType_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_EnumFilterRegistryValueType_indexes_ + 6 || _xsd_EnumFilterRegistryValueType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterRegistryValueType::
_xsd_EnumFilterRegistryValueType_literals_[6] =
{
  "REG_SZ",
  "REG_EXPAND_SZ",
  "REG_MULTI_SZ",
  "REG_DWORD",
  "REG_BINARY",
  ""
};

const EnumFilterRegistryValueType::Value EnumFilterRegistryValueType::
_xsd_EnumFilterRegistryValueType_indexes_[6] =
{
  ::EnumFilterRegistryValueType::empty,
  ::EnumFilterRegistryValueType::REG_BINARY,
  ::EnumFilterRegistryValueType::REG_DWORD,
  ::EnumFilterRegistryValueType::REG_EXPAND_SZ,
  ::EnumFilterRegistryValueType::REG_MULTI_SZ,
  ::EnumFilterRegistryValueType::REG_SZ
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterRegistryValueType >
_xsd_EnumFilterRegistryValueType_type_factory_init (
  "enumFilterRegistryValueType",
  "");

// EnumFilterRegistrySubType
//

EnumFilterRegistrySubType::
EnumFilterRegistrySubType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterRegistrySubType_convert ();
}

EnumFilterRegistrySubType::
EnumFilterRegistrySubType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterRegistrySubType_convert ();
}

EnumFilterRegistrySubType::
EnumFilterRegistrySubType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterRegistrySubType_convert ();
}

EnumFilterRegistrySubType* EnumFilterRegistrySubType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterRegistrySubType (*this, f, c);
}

EnumFilterRegistrySubType::Value EnumFilterRegistrySubType::
_xsd_EnumFilterRegistrySubType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterRegistrySubType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterRegistrySubType_indexes_,
                    _xsd_EnumFilterRegistrySubType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_EnumFilterRegistrySubType_indexes_ + 4 || _xsd_EnumFilterRegistrySubType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterRegistrySubType::
_xsd_EnumFilterRegistrySubType_literals_[4] =
{
  "EQUALHEX",
  "EQUALDEC",
  "SUBSTRING",
  "VERSION"
};

const EnumFilterRegistrySubType::Value EnumFilterRegistrySubType::
_xsd_EnumFilterRegistrySubType_indexes_[4] =
{
  ::EnumFilterRegistrySubType::EQUALDEC,
  ::EnumFilterRegistrySubType::EQUALHEX,
  ::EnumFilterRegistrySubType::SUBSTRING,
  ::EnumFilterRegistrySubType::VERSION
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterRegistrySubType >
_xsd_EnumFilterRegistrySubType_type_factory_init (
  "enumFilterRegistrySubType",
  "");

// EnumFilterRegistryType
//

EnumFilterRegistryType::
EnumFilterRegistryType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterRegistryType_convert ();
}

EnumFilterRegistryType::
EnumFilterRegistryType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterRegistryType_convert ();
}

EnumFilterRegistryType::
EnumFilterRegistryType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterRegistryType_convert ();
}

EnumFilterRegistryType* EnumFilterRegistryType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterRegistryType (*this, f, c);
}

EnumFilterRegistryType::Value EnumFilterRegistryType::
_xsd_EnumFilterRegistryType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterRegistryType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterRegistryType_indexes_,
                    _xsd_EnumFilterRegistryType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_EnumFilterRegistryType_indexes_ + 4 || _xsd_EnumFilterRegistryType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterRegistryType::
_xsd_EnumFilterRegistryType_literals_[4] =
{
  "VALUEEXISTS",
  "KEYEXISTS",
  "MATCHVALUE",
  "GETVALUE"
};

const EnumFilterRegistryType::Value EnumFilterRegistryType::
_xsd_EnumFilterRegistryType_indexes_[4] =
{
  ::EnumFilterRegistryType::GETVALUE,
  ::EnumFilterRegistryType::KEYEXISTS,
  ::EnumFilterRegistryType::MATCHVALUE,
  ::EnumFilterRegistryType::VALUEEXISTS
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterRegistryType >
_xsd_EnumFilterRegistryType_type_factory_init (
  "enumFilterRegistryType",
  "");

// EnumFilterOsSp
//

EnumFilterOsSp::
EnumFilterOsSp (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterOsSp_convert ();
}

EnumFilterOsSp::
EnumFilterOsSp (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterOsSp_convert ();
}

EnumFilterOsSp::
EnumFilterOsSp (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterOsSp_convert ();
}

EnumFilterOsSp* EnumFilterOsSp::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterOsSp (*this, f, c);
}

EnumFilterOsSp::Value EnumFilterOsSp::
_xsd_EnumFilterOsSp_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterOsSp_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterOsSp_indexes_,
                    _xsd_EnumFilterOsSp_indexes_ + 8,
                    *this,
                    c));

  if (i == _xsd_EnumFilterOsSp_indexes_ + 8 || _xsd_EnumFilterOsSp_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterOsSp::
_xsd_EnumFilterOsSp_literals_[8] =
{
  "NE",
  "Gold",
  "Service Pack 1",
  "Service Pack 2",
  "Service Pack 3",
  "Service Pack 4",
  "Service Pack 5",
  "Service Pack 6"
};

const EnumFilterOsSp::Value EnumFilterOsSp::
_xsd_EnumFilterOsSp_indexes_[8] =
{
  ::EnumFilterOsSp::Gold,
  ::EnumFilterOsSp::NE,
  ::EnumFilterOsSp::Service_Pack_1,
  ::EnumFilterOsSp::Service_Pack_2,
  ::EnumFilterOsSp::Service_Pack_3,
  ::EnumFilterOsSp::Service_Pack_4,
  ::EnumFilterOsSp::Service_Pack_5,
  ::EnumFilterOsSp::Service_Pack_6
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterOsSp >
_xsd_EnumFilterOsSp_type_factory_init (
  "enumFilterOsSp",
  "");

// EnumFilterOsEdition
//

EnumFilterOsEdition::
EnumFilterOsEdition (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterOsEdition_convert ();
}

EnumFilterOsEdition::
EnumFilterOsEdition (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterOsEdition_convert ();
}

EnumFilterOsEdition::
EnumFilterOsEdition (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterOsEdition_convert ();
}

EnumFilterOsEdition* EnumFilterOsEdition::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterOsEdition (*this, f, c);
}

EnumFilterOsEdition::Value EnumFilterOsEdition::
_xsd_EnumFilterOsEdition_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterOsEdition_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterOsEdition_indexes_,
                    _xsd_EnumFilterOsEdition_indexes_ + 16,
                    *this,
                    c));

  if (i == _xsd_EnumFilterOsEdition_indexes_ + 16 || _xsd_EnumFilterOsEdition_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterOsEdition::
_xsd_EnumFilterOsEdition_literals_[16] =
{
  "NE",
  "64EP",
  "64DC",
  "AS",
  "DTC",
  "EP",
  "WEB",
  "64",
  "HM",
  "MC",
  "TPC",
  "SRV",
  "STD",
  "TSE",
  "SBS",
  "PRO"
};

const EnumFilterOsEdition::Value EnumFilterOsEdition::
_xsd_EnumFilterOsEdition_indexes_[16] =
{
  ::EnumFilterOsEdition::cxx_64,
  ::EnumFilterOsEdition::cxx_64DC,
  ::EnumFilterOsEdition::cxx_64EP,
  ::EnumFilterOsEdition::AS,
  ::EnumFilterOsEdition::DTC,
  ::EnumFilterOsEdition::EP,
  ::EnumFilterOsEdition::HM,
  ::EnumFilterOsEdition::MC,
  ::EnumFilterOsEdition::NE,
  ::EnumFilterOsEdition::PRO,
  ::EnumFilterOsEdition::SBS,
  ::EnumFilterOsEdition::SRV,
  ::EnumFilterOsEdition::STD,
  ::EnumFilterOsEdition::TPC,
  ::EnumFilterOsEdition::TSE,
  ::EnumFilterOsEdition::WEB
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterOsEdition >
_xsd_EnumFilterOsEdition_type_factory_init (
  "enumFilterOsEdition",
  "");

// EnumFilterOsType
//

EnumFilterOsType::
EnumFilterOsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterOsType_convert ();
}

EnumFilterOsType::
EnumFilterOsType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterOsType_convert ();
}

EnumFilterOsType::
EnumFilterOsType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterOsType_convert ();
}

EnumFilterOsType* EnumFilterOsType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterOsType (*this, f, c);
}

EnumFilterOsType::Value EnumFilterOsType::
_xsd_EnumFilterOsType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterOsType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterOsType_indexes_,
                    _xsd_EnumFilterOsType_indexes_ + 8,
                    *this,
                    c));

  if (i == _xsd_EnumFilterOsType_indexes_ + 8 || _xsd_EnumFilterOsType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterOsType::
_xsd_EnumFilterOsType_literals_[8] =
{
  "NE",
  "R2",
  "SE",
  "WS",
  "SV",
  "DC",
  "PRO",
  "PR"
};

const EnumFilterOsType::Value EnumFilterOsType::
_xsd_EnumFilterOsType_indexes_[8] =
{
  ::EnumFilterOsType::DC,
  ::EnumFilterOsType::NE,
  ::EnumFilterOsType::PR,
  ::EnumFilterOsType::PRO,
  ::EnumFilterOsType::R2,
  ::EnumFilterOsType::SE,
  ::EnumFilterOsType::SV,
  ::EnumFilterOsType::WS
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterOsType >
_xsd_EnumFilterOsType_type_factory_init (
  "enumFilterOsType",
  "");

// EnumFilterOsVersion
//

EnumFilterOsVersion::
EnumFilterOsVersion (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterOsVersion_convert ();
}

EnumFilterOsVersion::
EnumFilterOsVersion (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterOsVersion_convert ();
}

EnumFilterOsVersion::
EnumFilterOsVersion (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterOsVersion_convert ();
}

EnumFilterOsVersion* EnumFilterOsVersion::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterOsVersion (*this, f, c);
}

EnumFilterOsVersion::Value EnumFilterOsVersion::
_xsd_EnumFilterOsVersion_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterOsVersion_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterOsVersion_indexes_,
                    _xsd_EnumFilterOsVersion_indexes_ + 19,
                    *this,
                    c));

  if (i == _xsd_EnumFilterOsVersion_indexes_ + 19 || _xsd_EnumFilterOsVersion_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterOsVersion::
_xsd_EnumFilterOsVersion_literals_[19] =
{
  "NE",
  "95",
  "98",
  "ME",
  "NT",
  "2K",
  "XP",
  "2K3",
  "2K3R2",
  "VISTA",
  "2K8",
  "WIN7",
  "2K8R2",
  "WIN8",
  "WIN8S",
  "WINBLUE",
  "WINBLUESRV",
  "WINTHRESHOLD",
  "WINTHRESHOLDSRV"
};

const EnumFilterOsVersion::Value EnumFilterOsVersion::
_xsd_EnumFilterOsVersion_indexes_[19] =
{
  ::EnumFilterOsVersion::cxx_2K,
  ::EnumFilterOsVersion::cxx_2K3,
  ::EnumFilterOsVersion::cxx_2K3R2,
  ::EnumFilterOsVersion::cxx_2K8,
  ::EnumFilterOsVersion::cxx_2K8R2,
  ::EnumFilterOsVersion::cxx_95,
  ::EnumFilterOsVersion::cxx_98,
  ::EnumFilterOsVersion::ME,
  ::EnumFilterOsVersion::NE,
  ::EnumFilterOsVersion::NT,
  ::EnumFilterOsVersion::VISTA,
  ::EnumFilterOsVersion::WIN7,
  ::EnumFilterOsVersion::WIN8,
  ::EnumFilterOsVersion::WIN8S,
  ::EnumFilterOsVersion::WINBLUE,
  ::EnumFilterOsVersion::WINBLUESRV,
  ::EnumFilterOsVersion::WINTHRESHOLD,
  ::EnumFilterOsVersion::WINTHRESHOLDSRV,
  ::EnumFilterOsVersion::XP
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterOsVersion >
_xsd_EnumFilterOsVersion_type_factory_init (
  "enumFilterOsVersion",
  "");

// EnumFilterOsClass
//

EnumFilterOsClass::
EnumFilterOsClass (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterOsClass_convert ();
}

EnumFilterOsClass::
EnumFilterOsClass (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterOsClass_convert ();
}

EnumFilterOsClass::
EnumFilterOsClass (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterOsClass_convert ();
}

EnumFilterOsClass* EnumFilterOsClass::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterOsClass (*this, f, c);
}

EnumFilterOsClass::Value EnumFilterOsClass::
_xsd_EnumFilterOsClass_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterOsClass_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterOsClass_indexes_,
                    _xsd_EnumFilterOsClass_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_EnumFilterOsClass_indexes_ + 3 || _xsd_EnumFilterOsClass_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterOsClass::
_xsd_EnumFilterOsClass_literals_[3] =
{
  "NE",
  "9X",
  "NT"
};

const EnumFilterOsClass::Value EnumFilterOsClass::
_xsd_EnumFilterOsClass_indexes_[3] =
{
  ::EnumFilterOsClass::cxx_9X,
  ::EnumFilterOsClass::NE,
  ::EnumFilterOsClass::NT
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterOsClass >
_xsd_EnumFilterOsClass_type_factory_init (
  "enumFilterOsClass",
  "");

// EnumFilterMsiSubType
//

EnumFilterMsiSubType::
EnumFilterMsiSubType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterMsiSubType_convert ();
}

EnumFilterMsiSubType::
EnumFilterMsiSubType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterMsiSubType_convert ();
}

EnumFilterMsiSubType::
EnumFilterMsiSubType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterMsiSubType_convert ();
}

EnumFilterMsiSubType* EnumFilterMsiSubType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterMsiSubType (*this, f, c);
}

EnumFilterMsiSubType::Value EnumFilterMsiSubType::
_xsd_EnumFilterMsiSubType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterMsiSubType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterMsiSubType_indexes_,
                    _xsd_EnumFilterMsiSubType_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_EnumFilterMsiSubType_indexes_ + 6 || _xsd_EnumFilterMsiSubType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterMsiSubType::
_xsd_EnumFilterMsiSubType_literals_[6] =
{
  "EXISTS",
  "VERSION",
  "GET_PROPERTY",
  "GET_INFORMATION",
  "MATCH_PROPERTY",
  "MATCH_INFORMATION"
};

const EnumFilterMsiSubType::Value EnumFilterMsiSubType::
_xsd_EnumFilterMsiSubType_indexes_[6] =
{
  ::EnumFilterMsiSubType::EXISTS,
  ::EnumFilterMsiSubType::GET_INFORMATION,
  ::EnumFilterMsiSubType::GET_PROPERTY,
  ::EnumFilterMsiSubType::MATCH_INFORMATION,
  ::EnumFilterMsiSubType::MATCH_PROPERTY,
  ::EnumFilterMsiSubType::VERSION
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterMsiSubType >
_xsd_EnumFilterMsiSubType_type_factory_init (
  "enumFilterMsiSubType",
  "");

// EnumFilterMsiType
//

EnumFilterMsiType::
EnumFilterMsiType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterMsiType_convert ();
}

EnumFilterMsiType::
EnumFilterMsiType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterMsiType_convert ();
}

EnumFilterMsiType::
EnumFilterMsiType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterMsiType_convert ();
}

EnumFilterMsiType* EnumFilterMsiType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterMsiType (*this, f, c);
}

EnumFilterMsiType::Value EnumFilterMsiType::
_xsd_EnumFilterMsiType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterMsiType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterMsiType_indexes_,
                    _xsd_EnumFilterMsiType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_EnumFilterMsiType_indexes_ + 3 || _xsd_EnumFilterMsiType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterMsiType::
_xsd_EnumFilterMsiType_literals_[3] =
{
  "PRODUCT",
  "PATCH",
  "FILECOMPONENT"
};

const EnumFilterMsiType::Value EnumFilterMsiType::
_xsd_EnumFilterMsiType_indexes_[3] =
{
  ::EnumFilterMsiType::FILECOMPONENT,
  ::EnumFilterMsiType::PATCH,
  ::EnumFilterMsiType::PRODUCT
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterMsiType >
_xsd_EnumFilterMsiType_type_factory_init (
  "enumFilterMsiType",
  "");

// EnumFilterFileType
//

EnumFilterFileType::
EnumFilterFileType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterFileType_convert ();
}

EnumFilterFileType::
EnumFilterFileType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterFileType_convert ();
}

EnumFilterFileType::
EnumFilterFileType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterFileType_convert ();
}

EnumFilterFileType* EnumFilterFileType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterFileType (*this, f, c);
}

EnumFilterFileType::Value EnumFilterFileType::
_xsd_EnumFilterFileType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterFileType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterFileType_indexes_,
                    _xsd_EnumFilterFileType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_EnumFilterFileType_indexes_ + 2 || _xsd_EnumFilterFileType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterFileType::
_xsd_EnumFilterFileType_literals_[2] =
{
  "EXISTS",
  "VERSION"
};

const EnumFilterFileType::Value EnumFilterFileType::
_xsd_EnumFilterFileType_indexes_[2] =
{
  ::EnumFilterFileType::EXISTS,
  ::EnumFilterFileType::VERSION
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterFileType >
_xsd_EnumFilterFileType_type_factory_init (
  "enumFilterFileType",
  "");

// EnumFilterDunType
//

EnumFilterDunType::
EnumFilterDunType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterDunType_convert ();
}

EnumFilterDunType::
EnumFilterDunType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterDunType_convert ();
}

EnumFilterDunType::
EnumFilterDunType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterDunType_convert ();
}

EnumFilterDunType* EnumFilterDunType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterDunType (*this, f, c);
}

EnumFilterDunType::Value EnumFilterDunType::
_xsd_EnumFilterDunType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterDunType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterDunType_indexes_,
                    _xsd_EnumFilterDunType_indexes_ + 15,
                    *this,
                    c));

  if (i == _xsd_EnumFilterDunType_indexes_ + 15 || _xsd_EnumFilterDunType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterDunType::
_xsd_EnumFilterDunType_literals_[15] =
{
  "",
  "modem",
  "isdn",
  "x25",
  "vpn",
  "pad",
  "GENERIC",
  "SERIAL",
  "FRAMERELAY",
  "ATM",
  "SONET",
  "SW56",
  "IRDA",
  "PARALLEL",
  "PPPoE"
};

const EnumFilterDunType::Value EnumFilterDunType::
_xsd_EnumFilterDunType_indexes_[15] =
{
  ::EnumFilterDunType::empty,
  ::EnumFilterDunType::ATM,
  ::EnumFilterDunType::FRAMERELAY,
  ::EnumFilterDunType::GENERIC,
  ::EnumFilterDunType::IRDA,
  ::EnumFilterDunType::PARALLEL,
  ::EnumFilterDunType::PPPoE,
  ::EnumFilterDunType::SERIAL,
  ::EnumFilterDunType::SONET,
  ::EnumFilterDunType::SW56,
  ::EnumFilterDunType::isdn,
  ::EnumFilterDunType::modem,
  ::EnumFilterDunType::pad,
  ::EnumFilterDunType::vpn,
  ::EnumFilterDunType::x25
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterDunType >
_xsd_EnumFilterDunType_type_factory_init (
  "enumFilterDunType",
  "");

// EnumFilterDateDow
//

EnumFilterDateDow::
EnumFilterDateDow (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterDateDow_convert ();
}

EnumFilterDateDow::
EnumFilterDateDow (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterDateDow_convert ();
}

EnumFilterDateDow::
EnumFilterDateDow (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterDateDow_convert ();
}

EnumFilterDateDow* EnumFilterDateDow::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterDateDow (*this, f, c);
}

EnumFilterDateDow::Value EnumFilterDateDow::
_xsd_EnumFilterDateDow_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterDateDow_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterDateDow_indexes_,
                    _xsd_EnumFilterDateDow_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_EnumFilterDateDow_indexes_ + 7 || _xsd_EnumFilterDateDow_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterDateDow::
_xsd_EnumFilterDateDow_literals_[7] =
{
  "SUN",
  "MON",
  "TUE",
  "WED",
  "THU",
  "FRI",
  "SAT"
};

const EnumFilterDateDow::Value EnumFilterDateDow::
_xsd_EnumFilterDateDow_indexes_[7] =
{
  ::EnumFilterDateDow::FRI,
  ::EnumFilterDateDow::MON,
  ::EnumFilterDateDow::SAT,
  ::EnumFilterDateDow::SUN,
  ::EnumFilterDateDow::THU,
  ::EnumFilterDateDow::TUE,
  ::EnumFilterDateDow::WED
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterDateDow >
_xsd_EnumFilterDateDow_type_factory_init (
  "enumFilterDateDow",
  "");

// EnumFilterDatePeriod
//

EnumFilterDatePeriod::
EnumFilterDatePeriod (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterDatePeriod_convert ();
}

EnumFilterDatePeriod::
EnumFilterDatePeriod (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterDatePeriod_convert ();
}

EnumFilterDatePeriod::
EnumFilterDatePeriod (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterDatePeriod_convert ();
}

EnumFilterDatePeriod* EnumFilterDatePeriod::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterDatePeriod (*this, f, c);
}

EnumFilterDatePeriod::Value EnumFilterDatePeriod::
_xsd_EnumFilterDatePeriod_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterDatePeriod_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterDatePeriod_indexes_,
                    _xsd_EnumFilterDatePeriod_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_EnumFilterDatePeriod_indexes_ + 3 || _xsd_EnumFilterDatePeriod_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterDatePeriod::
_xsd_EnumFilterDatePeriod_literals_[3] =
{
  "MONTHLY",
  "WEEKLY",
  "YEARLY"
};

const EnumFilterDatePeriod::Value EnumFilterDatePeriod::
_xsd_EnumFilterDatePeriod_indexes_[3] =
{
  ::EnumFilterDatePeriod::MONTHLY,
  ::EnumFilterDatePeriod::WEEKLY,
  ::EnumFilterDatePeriod::YEARLY
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterDatePeriod >
_xsd_EnumFilterDatePeriod_type_factory_init (
  "enumFilterDatePeriod",
  "");

// EnumFilterComputerNameType
//

EnumFilterComputerNameType::
EnumFilterComputerNameType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterComputerNameType_convert ();
}

EnumFilterComputerNameType::
EnumFilterComputerNameType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterComputerNameType_convert ();
}

EnumFilterComputerNameType::
EnumFilterComputerNameType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterComputerNameType_convert ();
}

EnumFilterComputerNameType* EnumFilterComputerNameType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterComputerNameType (*this, f, c);
}

EnumFilterComputerNameType::Value EnumFilterComputerNameType::
_xsd_EnumFilterComputerNameType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterComputerNameType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterComputerNameType_indexes_,
                    _xsd_EnumFilterComputerNameType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_EnumFilterComputerNameType_indexes_ + 2 || _xsd_EnumFilterComputerNameType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterComputerNameType::
_xsd_EnumFilterComputerNameType_literals_[2] =
{
  "DNS",
  "NETBIOS"
};

const EnumFilterComputerNameType::Value EnumFilterComputerNameType::
_xsd_EnumFilterComputerNameType_indexes_[2] =
{
  ::EnumFilterComputerNameType::DNS,
  ::EnumFilterComputerNameType::NETBIOS
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterComputerNameType >
_xsd_EnumFilterComputerNameType_type_factory_init (
  "enumFilterComputerNameType",
  "");

// EnumFilterBool
//

EnumFilterBool::
EnumFilterBool (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumFilterBool_convert ();
}

EnumFilterBool::
EnumFilterBool (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumFilterBool_convert ();
}

EnumFilterBool::
EnumFilterBool (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumFilterBool_convert ();
}

EnumFilterBool* EnumFilterBool::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumFilterBool (*this, f, c);
}

EnumFilterBool::Value EnumFilterBool::
_xsd_EnumFilterBool_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumFilterBool_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumFilterBool_indexes_,
                    _xsd_EnumFilterBool_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_EnumFilterBool_indexes_ + 2 || _xsd_EnumFilterBool_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumFilterBool::
_xsd_EnumFilterBool_literals_[2] =
{
  "AND",
  "OR"
};

const EnumFilterBool::Value EnumFilterBool::
_xsd_EnumFilterBool_indexes_[2] =
{
  ::EnumFilterBool::AND,
  ::EnumFilterBool::OR
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumFilterBool >
_xsd_EnumFilterBool_type_factory_init (
  "enumFilterBool",
  "");

// EnumTrueFalse
//

EnumTrueFalse::
EnumTrueFalse (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_EnumTrueFalse_convert ();
}

EnumTrueFalse::
EnumTrueFalse (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_EnumTrueFalse_convert ();
}

EnumTrueFalse::
EnumTrueFalse (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_EnumTrueFalse_convert ();
}

EnumTrueFalse* EnumTrueFalse::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class EnumTrueFalse (*this, f, c);
}

EnumTrueFalse::Value EnumTrueFalse::
_xsd_EnumTrueFalse_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnumTrueFalse_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_EnumTrueFalse_indexes_,
                    _xsd_EnumTrueFalse_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_EnumTrueFalse_indexes_ + 2 || _xsd_EnumTrueFalse_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EnumTrueFalse::
_xsd_EnumTrueFalse_literals_[2] =
{
  "0",
  "1"
};

const EnumTrueFalse::Value EnumTrueFalse::
_xsd_EnumTrueFalse_indexes_[2] =
{
  ::EnumTrueFalse::cxx_0,
  ::EnumTrueFalse::cxx_1
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumTrueFalse >
_xsd_EnumTrueFalse_type_factory_init (
  "enumTrueFalse",
  "");

// IFilter
//

IFilter::
IFilter (const BoolType& bool_,
         const NotType& not_)
: ::xml_schema::Type (),
  bool__ (bool_, this),
  not__ (not_, this),
  hidden_ (this)
{
}

IFilter::
IFilter (const IFilter& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  bool__ (x.bool__, f, this),
  not__ (x.not__, f, this),
  hidden_ (x.hidden_, f, this)
{
}

IFilter::
IFilter (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  bool__ (this),
  not__ (this),
  hidden_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void IFilter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bool" && n.namespace_ ().empty ())
    {
      this->bool__.set (BoolTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "not" && n.namespace_ ().empty ())
    {
      this->not__.set (NotTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "hidden" && n.namespace_ ().empty ())
    {
      this->hidden_.set (HiddenTraits::create (i, f, this));
      continue;
    }
  }

  if (!bool__.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "bool",
      "");
  }

  if (!not__.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "not",
      "");
  }
}

IFilter& IFilter::
operator= (const IFilter& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::Type& > (*this) = x;
    this->bool__ = x.bool__;
    this->not__ = x.not__;
    this->hidden_ = x.hidden_;
  }

  return *this;
}

IFilter::
~IFilter ()
{
}

// Filters_t
//

Filters_t::
Filters_t ()
: ::xml_schema::Type (),
  FilterSite_ (this),
  FilterGroup_ (this),
  FilterRunOnce_ (this),
  FilterLdap_ (this),
  FilterBattery_ (this),
  FilterComputer_ (this),
  FilterCpu_ (this),
  FilterDate_ (this),
  FilterDun_ (this),
  FilterDisk_ (this),
  FilterDomain_ (this),
  FilterVariable_ (this),
  FilterFile_ (this),
  FilterIpRange_ (this),
  FilterLanguage_ (this),
  FilterMacRange_ (this),
  FilterMsi_ (this),
  FilterOs_ (this),
  FilterOrgUnit_ (this),
  FilterPcmcia_ (this),
  FilterPortable_ (this),
  FilterProcMode_ (this),
  FilterRam_ (this),
  FilterRegistry_ (this),
  FilterTerminal_ (this),
  FilterTime_ (this),
  FilterUser_ (this),
  FilterWmi_ (this),
  FilterCollection_ (this)
{
}

Filters_t::
Filters_t (const Filters_t& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  FilterSite_ (x.FilterSite_, f, this),
  FilterGroup_ (x.FilterGroup_, f, this),
  FilterRunOnce_ (x.FilterRunOnce_, f, this),
  FilterLdap_ (x.FilterLdap_, f, this),
  FilterBattery_ (x.FilterBattery_, f, this),
  FilterComputer_ (x.FilterComputer_, f, this),
  FilterCpu_ (x.FilterCpu_, f, this),
  FilterDate_ (x.FilterDate_, f, this),
  FilterDun_ (x.FilterDun_, f, this),
  FilterDisk_ (x.FilterDisk_, f, this),
  FilterDomain_ (x.FilterDomain_, f, this),
  FilterVariable_ (x.FilterVariable_, f, this),
  FilterFile_ (x.FilterFile_, f, this),
  FilterIpRange_ (x.FilterIpRange_, f, this),
  FilterLanguage_ (x.FilterLanguage_, f, this),
  FilterMacRange_ (x.FilterMacRange_, f, this),
  FilterMsi_ (x.FilterMsi_, f, this),
  FilterOs_ (x.FilterOs_, f, this),
  FilterOrgUnit_ (x.FilterOrgUnit_, f, this),
  FilterPcmcia_ (x.FilterPcmcia_, f, this),
  FilterPortable_ (x.FilterPortable_, f, this),
  FilterProcMode_ (x.FilterProcMode_, f, this),
  FilterRam_ (x.FilterRam_, f, this),
  FilterRegistry_ (x.FilterRegistry_, f, this),
  FilterTerminal_ (x.FilterTerminal_, f, this),
  FilterTime_ (x.FilterTime_, f, this),
  FilterUser_ (x.FilterUser_, f, this),
  FilterWmi_ (x.FilterWmi_, f, this),
  FilterCollection_ (x.FilterCollection_, f, this)
{
}

Filters_t::
Filters_t (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  FilterSite_ (this),
  FilterGroup_ (this),
  FilterRunOnce_ (this),
  FilterLdap_ (this),
  FilterBattery_ (this),
  FilterComputer_ (this),
  FilterCpu_ (this),
  FilterDate_ (this),
  FilterDun_ (this),
  FilterDisk_ (this),
  FilterDomain_ (this),
  FilterVariable_ (this),
  FilterFile_ (this),
  FilterIpRange_ (this),
  FilterLanguage_ (this),
  FilterMacRange_ (this),
  FilterMsi_ (this),
  FilterOs_ (this),
  FilterOrgUnit_ (this),
  FilterPcmcia_ (this),
  FilterPortable_ (this),
  FilterProcMode_ (this),
  FilterRam_ (this),
  FilterRegistry_ (this),
  FilterTerminal_ (this),
  FilterTime_ (this),
  FilterUser_ (this),
  FilterWmi_ (this),
  FilterCollection_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Filters_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FilterSite
    //
    if (n.name () == "FilterSite" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterSiteType > r (
        FilterSiteTraits::create (i, f, this));

      this->FilterSite_.push_back (::std::move (r));
      continue;
    }

    // FilterGroup
    //
    if (n.name () == "FilterGroup" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterGroupType > r (
        FilterGroupTraits::create (i, f, this));

      this->FilterGroup_.push_back (::std::move (r));
      continue;
    }

    // FilterRunOnce
    //
    if (n.name () == "FilterRunOnce" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterRunOnceType > r (
        FilterRunOnceTraits::create (i, f, this));

      this->FilterRunOnce_.push_back (::std::move (r));
      continue;
    }

    // FilterLdap
    //
    if (n.name () == "FilterLdap" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterLdapType > r (
        FilterLdapTraits::create (i, f, this));

      this->FilterLdap_.push_back (::std::move (r));
      continue;
    }

    // FilterBattery
    //
    if (n.name () == "FilterBattery" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterBatteryType > r (
        FilterBatteryTraits::create (i, f, this));

      this->FilterBattery_.push_back (::std::move (r));
      continue;
    }

    // FilterComputer
    //
    if (n.name () == "FilterComputer" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterComputerType > r (
        FilterComputerTraits::create (i, f, this));

      this->FilterComputer_.push_back (::std::move (r));
      continue;
    }

    // FilterCpu
    //
    if (n.name () == "FilterCpu" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterCpuType > r (
        FilterCpuTraits::create (i, f, this));

      this->FilterCpu_.push_back (::std::move (r));
      continue;
    }

    // FilterDate
    //
    if (n.name () == "FilterDate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterDateType > r (
        FilterDateTraits::create (i, f, this));

      this->FilterDate_.push_back (::std::move (r));
      continue;
    }

    // FilterDun
    //
    if (n.name () == "FilterDun" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterDunType > r (
        FilterDunTraits::create (i, f, this));

      this->FilterDun_.push_back (::std::move (r));
      continue;
    }

    // FilterDisk
    //
    if (n.name () == "FilterDisk" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterDiskType > r (
        FilterDiskTraits::create (i, f, this));

      this->FilterDisk_.push_back (::std::move (r));
      continue;
    }

    // FilterDomain
    //
    if (n.name () == "FilterDomain" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterDomainType > r (
        FilterDomainTraits::create (i, f, this));

      this->FilterDomain_.push_back (::std::move (r));
      continue;
    }

    // FilterVariable
    //
    if (n.name () == "FilterVariable" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterVariableType > r (
        FilterVariableTraits::create (i, f, this));

      this->FilterVariable_.push_back (::std::move (r));
      continue;
    }

    // FilterFile
    //
    if (n.name () == "FilterFile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterFileType > r (
        FilterFileTraits::create (i, f, this));

      this->FilterFile_.push_back (::std::move (r));
      continue;
    }

    // FilterIpRange
    //
    if (n.name () == "FilterIpRange" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterIpRangeType > r (
        FilterIpRangeTraits::create (i, f, this));

      this->FilterIpRange_.push_back (::std::move (r));
      continue;
    }

    // FilterLanguage
    //
    if (n.name () == "FilterLanguage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterLanguageType > r (
        FilterLanguageTraits::create (i, f, this));

      this->FilterLanguage_.push_back (::std::move (r));
      continue;
    }

    // FilterMacRange
    //
    if (n.name () == "FilterMacRange" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterMacRangeType > r (
        FilterMacRangeTraits::create (i, f, this));

      this->FilterMacRange_.push_back (::std::move (r));
      continue;
    }

    // FilterMsi
    //
    if (n.name () == "FilterMsi" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterMsiType > r (
        FilterMsiTraits::create (i, f, this));

      this->FilterMsi_.push_back (::std::move (r));
      continue;
    }

    // FilterOs
    //
    if (n.name () == "FilterOs" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterOsType > r (
        FilterOsTraits::create (i, f, this));

      this->FilterOs_.push_back (::std::move (r));
      continue;
    }

    // FilterOrgUnit
    //
    if (n.name () == "FilterOrgUnit" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterOrgUnitType > r (
        FilterOrgUnitTraits::create (i, f, this));

      this->FilterOrgUnit_.push_back (::std::move (r));
      continue;
    }

    // FilterPcmcia
    //
    if (n.name () == "FilterPcmcia" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterPcmciaType > r (
        FilterPcmciaTraits::create (i, f, this));

      this->FilterPcmcia_.push_back (::std::move (r));
      continue;
    }

    // FilterPortable
    //
    if (n.name () == "FilterPortable" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterPortableType > r (
        FilterPortableTraits::create (i, f, this));

      this->FilterPortable_.push_back (::std::move (r));
      continue;
    }

    // FilterProcMode
    //
    if (n.name () == "FilterProcMode" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterProcModeType > r (
        FilterProcModeTraits::create (i, f, this));

      this->FilterProcMode_.push_back (::std::move (r));
      continue;
    }

    // FilterRam
    //
    if (n.name () == "FilterRam" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterRamType > r (
        FilterRamTraits::create (i, f, this));

      this->FilterRam_.push_back (::std::move (r));
      continue;
    }

    // FilterRegistry
    //
    if (n.name () == "FilterRegistry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterRegistryType > r (
        FilterRegistryTraits::create (i, f, this));

      this->FilterRegistry_.push_back (::std::move (r));
      continue;
    }

    // FilterTerminal
    //
    if (n.name () == "FilterTerminal" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterTerminalType > r (
        FilterTerminalTraits::create (i, f, this));

      this->FilterTerminal_.push_back (::std::move (r));
      continue;
    }

    // FilterTime
    //
    if (n.name () == "FilterTime" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterTimeType > r (
        FilterTimeTraits::create (i, f, this));

      this->FilterTime_.push_back (::std::move (r));
      continue;
    }

    // FilterUser
    //
    if (n.name () == "FilterUser" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterUserType > r (
        FilterUserTraits::create (i, f, this));

      this->FilterUser_.push_back (::std::move (r));
      continue;
    }

    // FilterWmi
    //
    if (n.name () == "FilterWmi" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterWmiType > r (
        FilterWmiTraits::create (i, f, this));

      this->FilterWmi_.push_back (::std::move (r));
      continue;
    }

    // FilterCollection
    //
    if (n.name () == "FilterCollection" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterCollectionType > r (
        FilterCollectionTraits::create (i, f, this));

      this->FilterCollection_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Filters_t* Filters_t::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class Filters_t (*this, f, c);
}

Filters_t& Filters_t::
operator= (const Filters_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::Type& > (*this) = x;
    this->FilterSite_ = x.FilterSite_;
    this->FilterGroup_ = x.FilterGroup_;
    this->FilterRunOnce_ = x.FilterRunOnce_;
    this->FilterLdap_ = x.FilterLdap_;
    this->FilterBattery_ = x.FilterBattery_;
    this->FilterComputer_ = x.FilterComputer_;
    this->FilterCpu_ = x.FilterCpu_;
    this->FilterDate_ = x.FilterDate_;
    this->FilterDun_ = x.FilterDun_;
    this->FilterDisk_ = x.FilterDisk_;
    this->FilterDomain_ = x.FilterDomain_;
    this->FilterVariable_ = x.FilterVariable_;
    this->FilterFile_ = x.FilterFile_;
    this->FilterIpRange_ = x.FilterIpRange_;
    this->FilterLanguage_ = x.FilterLanguage_;
    this->FilterMacRange_ = x.FilterMacRange_;
    this->FilterMsi_ = x.FilterMsi_;
    this->FilterOs_ = x.FilterOs_;
    this->FilterOrgUnit_ = x.FilterOrgUnit_;
    this->FilterPcmcia_ = x.FilterPcmcia_;
    this->FilterPortable_ = x.FilterPortable_;
    this->FilterProcMode_ = x.FilterProcMode_;
    this->FilterRam_ = x.FilterRam_;
    this->FilterRegistry_ = x.FilterRegistry_;
    this->FilterTerminal_ = x.FilterTerminal_;
    this->FilterTime_ = x.FilterTime_;
    this->FilterUser_ = x.FilterUser_;
    this->FilterWmi_ = x.FilterWmi_;
    this->FilterCollection_ = x.FilterCollection_;
  }

  return *this;
}

Filters_t::
~Filters_t ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Filters_t >
_xsd_Filters_t_type_factory_init (
  "Filters_t",
  "");

// FilterSite
//

FilterSite::
FilterSite (const BoolType& bool_,
            const NotType& not_,
            const NameType& name)
: ::IFilter (bool_,
             not_),
  name_ (name, this)
{
}

FilterSite::
FilterSite (const FilterSite& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  name_ (x.name_, f, this)
{
}

FilterSite::
FilterSite (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  name_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterSite::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (NameTraits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

FilterSite* FilterSite::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterSite (*this, f, c);
}

FilterSite& FilterSite::
operator= (const FilterSite& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->name_ = x.name_;
  }

  return *this;
}

FilterSite::
~FilterSite ()
{
}

// FilterGroup
//

const FilterGroup::NameType FilterGroup::name_default_value_ (
  "");

const FilterGroup::SidType FilterGroup::sid_default_value_ (
  "");

const FilterGroup::UserContextType FilterGroup::userContext_default_value_ (
  "1");

const FilterGroup::PrimaryGroupType FilterGroup::primaryGroup_default_value_ (
  "0");

const FilterGroup::LocalGroupType FilterGroup::localGroup_default_value_ (
  "0");

FilterGroup::
FilterGroup (const BoolType& bool_,
             const NotType& not_)
: ::IFilter (bool_,
             not_),
  name_ (name_default_value (), this),
  sid_ (sid_default_value (), this),
  userContext_ (userContext_default_value (), this),
  primaryGroup_ (primaryGroup_default_value (), this),
  localGroup_ (localGroup_default_value (), this)
{
}

FilterGroup::
FilterGroup (const FilterGroup& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  name_ (x.name_, f, this),
  sid_ (x.sid_, f, this),
  userContext_ (x.userContext_, f, this),
  primaryGroup_ (x.primaryGroup_, f, this),
  localGroup_ (x.localGroup_, f, this)
{
}

FilterGroup::
FilterGroup (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  name_ (this),
  sid_ (this),
  userContext_ (this),
  primaryGroup_ (this),
  localGroup_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterGroup::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (NameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "sid" && n.namespace_ ().empty ())
    {
      this->sid_.set (SidTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "userContext" && n.namespace_ ().empty ())
    {
      this->userContext_.set (UserContextTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "primaryGroup" && n.namespace_ ().empty ())
    {
      this->primaryGroup_.set (PrimaryGroupTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "localGroup" && n.namespace_ ().empty ())
    {
      this->localGroup_.set (LocalGroupTraits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    this->name_.set (name_default_value ());
  }

  if (!sid_.present ())
  {
    this->sid_.set (sid_default_value ());
  }

  if (!userContext_.present ())
  {
    this->userContext_.set (userContext_default_value ());
  }

  if (!primaryGroup_.present ())
  {
    this->primaryGroup_.set (primaryGroup_default_value ());
  }

  if (!localGroup_.present ())
  {
    this->localGroup_.set (localGroup_default_value ());
  }
}

FilterGroup* FilterGroup::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterGroup (*this, f, c);
}

FilterGroup& FilterGroup::
operator= (const FilterGroup& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->name_ = x.name_;
    this->sid_ = x.sid_;
    this->userContext_ = x.userContext_;
    this->primaryGroup_ = x.primaryGroup_;
    this->localGroup_ = x.localGroup_;
  }

  return *this;
}

FilterGroup::
~FilterGroup ()
{
}

// FilterRunOnce
//

const FilterRunOnce::UserContextType FilterRunOnce::userContext_default_value_ (
  "1");

const FilterRunOnce::CommentsType FilterRunOnce::comments_default_value_ (
  "");

FilterRunOnce::
FilterRunOnce (const BoolType& bool_,
               const NotType& not_,
               const IdType& id)
: ::IFilter (bool_,
             not_),
  id_ (id, this),
  userContext_ (userContext_default_value (), this),
  comments_ (comments_default_value (), this)
{
}

FilterRunOnce::
FilterRunOnce (const FilterRunOnce& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  id_ (x.id_, f, this),
  userContext_ (x.userContext_, f, this),
  comments_ (x.comments_, f, this)
{
}

FilterRunOnce::
FilterRunOnce (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  id_ (this),
  userContext_ (this),
  comments_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterRunOnce::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (IdTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "userContext" && n.namespace_ ().empty ())
    {
      this->userContext_.set (UserContextTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "comments" && n.namespace_ ().empty ())
    {
      this->comments_.set (CommentsTraits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!userContext_.present ())
  {
    this->userContext_.set (userContext_default_value ());
  }

  if (!comments_.present ())
  {
    this->comments_.set (comments_default_value ());
  }
}

FilterRunOnce* FilterRunOnce::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterRunOnce (*this, f, c);
}

FilterRunOnce& FilterRunOnce::
operator= (const FilterRunOnce& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->id_ = x.id_;
    this->userContext_ = x.userContext_;
    this->comments_ = x.comments_;
  }

  return *this;
}

FilterRunOnce::
~FilterRunOnce ()
{
}

// FilterLdap
//

FilterLdap::
FilterLdap (const BoolType& bool_,
            const NotType& not_,
            const BindingType& binding)
: ::IFilter (bool_,
             not_),
  searchFilter_ (this),
  binding_ (binding, this),
  variableName_ (this),
  attribute_ (this)
{
}

FilterLdap::
FilterLdap (const FilterLdap& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  searchFilter_ (x.searchFilter_, f, this),
  binding_ (x.binding_, f, this),
  variableName_ (x.variableName_, f, this),
  attribute_ (x.attribute_, f, this)
{
}

FilterLdap::
FilterLdap (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  searchFilter_ (this),
  binding_ (this),
  variableName_ (this),
  attribute_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterLdap::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "searchFilter" && n.namespace_ ().empty ())
    {
      this->searchFilter_.set (SearchFilterTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "binding" && n.namespace_ ().empty ())
    {
      this->binding_.set (BindingTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "variableName" && n.namespace_ ().empty ())
    {
      this->variableName_.set (VariableNameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "attribute" && n.namespace_ ().empty ())
    {
      this->attribute_.set (AttributeTraits::create (i, f, this));
      continue;
    }
  }

  if (!binding_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "binding",
      "");
  }
}

FilterLdap* FilterLdap::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterLdap (*this, f, c);
}

FilterLdap& FilterLdap::
operator= (const FilterLdap& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->searchFilter_ = x.searchFilter_;
    this->binding_ = x.binding_;
    this->variableName_ = x.variableName_;
    this->attribute_ = x.attribute_;
  }

  return *this;
}

FilterLdap::
~FilterLdap ()
{
}

// FilterBattery
//

FilterBattery::
FilterBattery (const BoolType& bool_,
               const NotType& not_)
: ::IFilter (bool_,
             not_)
{
}

FilterBattery::
FilterBattery (const FilterBattery& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::IFilter (x, f, c)
{
}

FilterBattery::
FilterBattery (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::IFilter (e, f, c)
{
}

FilterBattery* FilterBattery::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterBattery (*this, f, c);
}

FilterBattery::
~FilterBattery ()
{
}

// FilterComputer
//

FilterComputer::
FilterComputer (const BoolType& bool_,
                const NotType& not_,
                const TypeType& type,
                const NameType& name)
: ::IFilter (bool_,
             not_),
  type_ (type, this),
  name_ (name, this)
{
}

FilterComputer::
FilterComputer (const FilterComputer& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  type_ (x.type_, f, this),
  name_ (x.name_, f, this)
{
}

FilterComputer::
FilterComputer (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  type_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterComputer::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (TypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (NameTraits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

FilterComputer* FilterComputer::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterComputer (*this, f, c);
}

FilterComputer& FilterComputer::
operator= (const FilterComputer& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->type_ = x.type_;
    this->name_ = x.name_;
  }

  return *this;
}

FilterComputer::
~FilterComputer ()
{
}

// FilterCpu
//

FilterCpu::
FilterCpu (const BoolType& bool_,
           const NotType& not_,
           const SpeedMHzType& speedMHz)
: ::IFilter (bool_,
             not_),
  speedMHz_ (speedMHz, this)
{
}

FilterCpu::
FilterCpu (const FilterCpu& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  speedMHz_ (x.speedMHz_, f, this)
{
}

FilterCpu::
FilterCpu (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  speedMHz_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterCpu::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "speedMHz" && n.namespace_ ().empty ())
    {
      this->speedMHz_.set (SpeedMHzTraits::create (i, f, this));
      continue;
    }
  }

  if (!speedMHz_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "speedMHz",
      "");
  }
}

FilterCpu* FilterCpu::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterCpu (*this, f, c);
}

FilterCpu& FilterCpu::
operator= (const FilterCpu& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->speedMHz_ = x.speedMHz_;
  }

  return *this;
}

FilterCpu::
~FilterCpu ()
{
}

// FilterDate
//

FilterDate::
FilterDate (const BoolType& bool_,
            const NotType& not_,
            const PeriodType& period)
: ::IFilter (bool_,
             not_),
  period_ (period, this),
  dow_ (this),
  day_ (this),
  month_ (this),
  year_ (this)
{
}

FilterDate::
FilterDate (const FilterDate& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  period_ (x.period_, f, this),
  dow_ (x.dow_, f, this),
  day_ (x.day_, f, this),
  month_ (x.month_, f, this),
  year_ (x.year_, f, this)
{
}

FilterDate::
FilterDate (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  period_ (this),
  dow_ (this),
  day_ (this),
  month_ (this),
  year_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterDate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "period" && n.namespace_ ().empty ())
    {
      this->period_.set (PeriodTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "dow" && n.namespace_ ().empty ())
    {
      this->dow_.set (DowTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "day" && n.namespace_ ().empty ())
    {
      this->day_.set (DayTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "month" && n.namespace_ ().empty ())
    {
      this->month_.set (MonthTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "year" && n.namespace_ ().empty ())
    {
      this->year_.set (YearTraits::create (i, f, this));
      continue;
    }
  }

  if (!period_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "period",
      "");
  }
}

FilterDate* FilterDate::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterDate (*this, f, c);
}

FilterDate& FilterDate::
operator= (const FilterDate& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->period_ = x.period_;
    this->dow_ = x.dow_;
    this->day_ = x.day_;
    this->month_ = x.month_;
    this->year_ = x.year_;
  }

  return *this;
}

FilterDate::
~FilterDate ()
{
}

// FilterDun
//

FilterDun::
FilterDun (const BoolType& bool_,
           const NotType& not_,
           const TypeType& type)
: ::IFilter (bool_,
             not_),
  type_ (type, this)
{
}

FilterDun::
FilterDun (const FilterDun& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  type_ (x.type_, f, this)
{
}

FilterDun::
FilterDun (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  type_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterDun::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (TypeTraits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

FilterDun* FilterDun::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterDun (*this, f, c);
}

FilterDun& FilterDun::
operator= (const FilterDun& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

FilterDun::
~FilterDun ()
{
}

// FilterDisk
//

FilterDisk::
FilterDisk (const BoolType& bool_,
            const NotType& not_,
            const FreeSpaceType& freeSpace,
            const DriveType& drive)
: ::IFilter (bool_,
             not_),
  freeSpace_ (freeSpace, this),
  drive_ (drive, this)
{
}

FilterDisk::
FilterDisk (const FilterDisk& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  freeSpace_ (x.freeSpace_, f, this),
  drive_ (x.drive_, f, this)
{
}

FilterDisk::
FilterDisk (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  freeSpace_ (this),
  drive_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterDisk::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "freeSpace" && n.namespace_ ().empty ())
    {
      this->freeSpace_.set (FreeSpaceTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "drive" && n.namespace_ ().empty ())
    {
      this->drive_.set (DriveTraits::create (i, f, this));
      continue;
    }
  }

  if (!freeSpace_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "freeSpace",
      "");
  }

  if (!drive_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "drive",
      "");
  }
}

FilterDisk* FilterDisk::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterDisk (*this, f, c);
}

FilterDisk& FilterDisk::
operator= (const FilterDisk& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->freeSpace_ = x.freeSpace_;
    this->drive_ = x.drive_;
  }

  return *this;
}

FilterDisk::
~FilterDisk ()
{
}

// FilterDomain
//

const FilterDomain::UserContextType FilterDomain::userContext_default_value_ (
  "1");

FilterDomain::
FilterDomain (const BoolType& bool_,
              const NotType& not_,
              const NameType& name)
: ::IFilter (bool_,
             not_),
  name_ (name, this),
  userContext_ (userContext_default_value (), this)
{
}

FilterDomain::
FilterDomain (const FilterDomain& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  name_ (x.name_, f, this),
  userContext_ (x.userContext_, f, this)
{
}

FilterDomain::
FilterDomain (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  name_ (this),
  userContext_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterDomain::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (NameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "userContext" && n.namespace_ ().empty ())
    {
      this->userContext_.set (UserContextTraits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!userContext_.present ())
  {
    this->userContext_.set (userContext_default_value ());
  }
}

FilterDomain* FilterDomain::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterDomain (*this, f, c);
}

FilterDomain& FilterDomain::
operator= (const FilterDomain& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->name_ = x.name_;
    this->userContext_ = x.userContext_;
  }

  return *this;
}

FilterDomain::
~FilterDomain ()
{
}

// FilterVariable
//

const FilterVariable::ValueType FilterVariable::value_default_value_ (
  "1");

FilterVariable::
FilterVariable (const BoolType& bool_,
                const NotType& not_,
                const VariableNameType& variableName)
: ::IFilter (bool_,
             not_),
  variableName_ (variableName, this),
  value_ (value_default_value (), this)
{
}

FilterVariable::
FilterVariable (const FilterVariable& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  variableName_ (x.variableName_, f, this),
  value_ (x.value_, f, this)
{
}

FilterVariable::
FilterVariable (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  variableName_ (this),
  value_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterVariable::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "variableName" && n.namespace_ ().empty ())
    {
      this->variableName_.set (VariableNameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (ValueTraits::create (i, f, this));
      continue;
    }
  }

  if (!variableName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "variableName",
      "");
  }

  if (!value_.present ())
  {
    this->value_.set (value_default_value ());
  }
}

FilterVariable* FilterVariable::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterVariable (*this, f, c);
}

FilterVariable& FilterVariable::
operator= (const FilterVariable& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->variableName_ = x.variableName_;
    this->value_ = x.value_;
  }

  return *this;
}

FilterVariable::
~FilterVariable ()
{
}

// FilterFile
//

const FilterFile::GteType FilterFile::gte_default_value_ (
  "0");

const FilterFile::LteType FilterFile::lte_default_value_ (
  "0");

const FilterFile::TypeType FilterFile::type_default_value_ (
  "EXISTS");

const FilterFile::FolderType FilterFile::folder_default_value_ (
  "0");

FilterFile::
FilterFile (const BoolType& bool_,
            const NotType& not_,
            const PathType& path)
: ::IFilter (bool_,
             not_),
  gte_ (gte_default_value (), this),
  lte_ (lte_default_value (), this),
  min_ (this),
  max_ (this),
  path_ (path, this),
  type_ (type_default_value (), this),
  folder_ (folder_default_value (), this)
{
}

FilterFile::
FilterFile (const FilterFile& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  gte_ (x.gte_, f, this),
  lte_ (x.lte_, f, this),
  min_ (x.min_, f, this),
  max_ (x.max_, f, this),
  path_ (x.path_, f, this),
  type_ (x.type_, f, this),
  folder_ (x.folder_, f, this)
{
}

FilterFile::
FilterFile (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  gte_ (this),
  lte_ (this),
  min_ (this),
  max_ (this),
  path_ (this),
  type_ (this),
  folder_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterFile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "gte" && n.namespace_ ().empty ())
    {
      this->gte_.set (GteTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "lte" && n.namespace_ ().empty ())
    {
      this->lte_.set (LteTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "min" && n.namespace_ ().empty ())
    {
      this->min_.set (MinTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (MaxTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "path" && n.namespace_ ().empty ())
    {
      this->path_.set (PathTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (TypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "folder" && n.namespace_ ().empty ())
    {
      this->folder_.set (FolderTraits::create (i, f, this));
      continue;
    }
  }

  if (!gte_.present ())
  {
    this->gte_.set (gte_default_value ());
  }

  if (!lte_.present ())
  {
    this->lte_.set (lte_default_value ());
  }

  if (!path_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "path",
      "");
  }

  if (!type_.present ())
  {
    this->type_.set (type_default_value ());
  }

  if (!folder_.present ())
  {
    this->folder_.set (folder_default_value ());
  }
}

FilterFile* FilterFile::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterFile (*this, f, c);
}

FilterFile& FilterFile::
operator= (const FilterFile& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->gte_ = x.gte_;
    this->lte_ = x.lte_;
    this->min_ = x.min_;
    this->max_ = x.max_;
    this->path_ = x.path_;
    this->type_ = x.type_;
    this->folder_ = x.folder_;
  }

  return *this;
}

FilterFile::
~FilterFile ()
{
}

// FilterIpRange
//

FilterIpRange::
FilterIpRange (const BoolType& bool_,
               const NotType& not_,
               const MinType& min,
               const MaxType& max)
: ::IFilter (bool_,
             not_),
  min_ (min, this),
  max_ (max, this)
{
}

FilterIpRange::
FilterIpRange (const FilterIpRange& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  min_ (x.min_, f, this),
  max_ (x.max_, f, this)
{
}

FilterIpRange::
FilterIpRange (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  min_ (this),
  max_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterIpRange::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "min" && n.namespace_ ().empty ())
    {
      this->min_.set (MinTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (MaxTraits::create (i, f, this));
      continue;
    }
  }

  if (!min_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "min",
      "");
  }

  if (!max_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max",
      "");
  }
}

FilterIpRange* FilterIpRange::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterIpRange (*this, f, c);
}

FilterIpRange& FilterIpRange::
operator= (const FilterIpRange& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->min_ = x.min_;
    this->max_ = x.max_;
  }

  return *this;
}

FilterIpRange::
~FilterIpRange ()
{
}

// FilterLanguage
//

const FilterLanguage::DefaultType FilterLanguage::default__default_value_ (
  "0");

const FilterLanguage::SystemType FilterLanguage::system_default_value_ (
  "0");

const FilterLanguage::NativeType FilterLanguage::native_default_value_ (
  "0");

FilterLanguage::
FilterLanguage (const BoolType& bool_,
                const NotType& not_,
                const LanguageType& language,
                const LocaleType& locale)
: ::IFilter (bool_,
             not_),
  default__ (default_default_value (), this),
  system_ (system_default_value (), this),
  native_ (native_default_value (), this),
  displayName_ (this),
  language_ (language, this),
  locale_ (locale, this)
{
}

FilterLanguage::
FilterLanguage (const FilterLanguage& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  default__ (x.default__, f, this),
  system_ (x.system_, f, this),
  native_ (x.native_, f, this),
  displayName_ (x.displayName_, f, this),
  language_ (x.language_, f, this),
  locale_ (x.locale_, f, this)
{
}

FilterLanguage::
FilterLanguage (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  default__ (this),
  system_ (this),
  native_ (this),
  displayName_ (this),
  language_ (this),
  locale_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterLanguage::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "default" && n.namespace_ ().empty ())
    {
      this->default__.set (DefaultTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "system" && n.namespace_ ().empty ())
    {
      this->system_.set (SystemTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "native" && n.namespace_ ().empty ())
    {
      this->native_.set (NativeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "displayName" && n.namespace_ ().empty ())
    {
      this->displayName_.set (DisplayNameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "language" && n.namespace_ ().empty ())
    {
      this->language_.set (LanguageTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "locale" && n.namespace_ ().empty ())
    {
      this->locale_.set (LocaleTraits::create (i, f, this));
      continue;
    }
  }

  if (!default__.present ())
  {
    this->default__.set (default_default_value ());
  }

  if (!system_.present ())
  {
    this->system_.set (system_default_value ());
  }

  if (!native_.present ())
  {
    this->native_.set (native_default_value ());
  }

  if (!language_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "language",
      "");
  }

  if (!locale_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "locale",
      "");
  }
}

FilterLanguage* FilterLanguage::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterLanguage (*this, f, c);
}

FilterLanguage& FilterLanguage::
operator= (const FilterLanguage& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->default__ = x.default__;
    this->system_ = x.system_;
    this->native_ = x.native_;
    this->displayName_ = x.displayName_;
    this->language_ = x.language_;
    this->locale_ = x.locale_;
  }

  return *this;
}

FilterLanguage::
~FilterLanguage ()
{
}

// FilterMacRange
//

FilterMacRange::
FilterMacRange (const BoolType& bool_,
                const NotType& not_,
                const MinType& min,
                const MaxType& max)
: ::IFilter (bool_,
             not_),
  min_ (min, this),
  max_ (max, this)
{
}

FilterMacRange::
FilterMacRange (const FilterMacRange& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  min_ (x.min_, f, this),
  max_ (x.max_, f, this)
{
}

FilterMacRange::
FilterMacRange (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  min_ (this),
  max_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterMacRange::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "min" && n.namespace_ ().empty ())
    {
      this->min_.set (MinTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (MaxTraits::create (i, f, this));
      continue;
    }
  }

  if (!min_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "min",
      "");
  }

  if (!max_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max",
      "");
  }
}

FilterMacRange* FilterMacRange::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterMacRange (*this, f, c);
}

FilterMacRange& FilterMacRange::
operator= (const FilterMacRange& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->min_ = x.min_;
    this->max_ = x.max_;
  }

  return *this;
}

FilterMacRange::
~FilterMacRange ()
{
}

// FilterMsi
//

const FilterMsi::GteType FilterMsi::gte_default_value_ (
  "0");

const FilterMsi::LteType FilterMsi::lte_default_value_ (
  "0");

FilterMsi::
FilterMsi (const BoolType& bool_,
           const NotType& not_,
           const TypeType& type,
           const SubtypeType& subtype)
: ::IFilter (bool_,
             not_),
  type_ (type, this),
  subtype_ (subtype, this),
  code_ (this),
  item_ (this),
  value_ (this),
  min_ (this),
  max_ (this),
  gte_ (gte_default_value (), this),
  lte_ (lte_default_value (), this)
{
}

FilterMsi::
FilterMsi (const FilterMsi& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  type_ (x.type_, f, this),
  subtype_ (x.subtype_, f, this),
  code_ (x.code_, f, this),
  item_ (x.item_, f, this),
  value_ (x.value_, f, this),
  min_ (x.min_, f, this),
  max_ (x.max_, f, this),
  gte_ (x.gte_, f, this),
  lte_ (x.lte_, f, this)
{
}

FilterMsi::
FilterMsi (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  type_ (this),
  subtype_ (this),
  code_ (this),
  item_ (this),
  value_ (this),
  min_ (this),
  max_ (this),
  gte_ (this),
  lte_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterMsi::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (TypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "subtype" && n.namespace_ ().empty ())
    {
      this->subtype_.set (SubtypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "code" && n.namespace_ ().empty ())
    {
      this->code_.set (CodeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "item" && n.namespace_ ().empty ())
    {
      this->item_.set (ItemTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (ValueTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "min" && n.namespace_ ().empty ())
    {
      this->min_.set (MinTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (MaxTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "gte" && n.namespace_ ().empty ())
    {
      this->gte_.set (GteTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "lte" && n.namespace_ ().empty ())
    {
      this->lte_.set (LteTraits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!subtype_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "subtype",
      "");
  }

  if (!gte_.present ())
  {
    this->gte_.set (gte_default_value ());
  }

  if (!lte_.present ())
  {
    this->lte_.set (lte_default_value ());
  }
}

FilterMsi* FilterMsi::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterMsi (*this, f, c);
}

FilterMsi& FilterMsi::
operator= (const FilterMsi& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->type_ = x.type_;
    this->subtype_ = x.subtype_;
    this->code_ = x.code_;
    this->item_ = x.item_;
    this->value_ = x.value_;
    this->min_ = x.min_;
    this->max_ = x.max_;
    this->gte_ = x.gte_;
    this->lte_ = x.lte_;
  }

  return *this;
}

FilterMsi::
~FilterMsi ()
{
}

// FilterOs
//

const FilterOs::ClassType FilterOs::class__default_value_ (
  "NE");

const FilterOs::VersionType FilterOs::version_default_value_ (
  "NE");

const FilterOs::TypeType FilterOs::type_default_value_ (
  "NE");

const FilterOs::EditionType FilterOs::edition_default_value_ (
  "NE");

const FilterOs::SpType FilterOs::sp_default_value_ (
  "NE");

FilterOs::
FilterOs (const BoolType& bool_,
          const NotType& not_)
: ::IFilter (bool_,
             not_),
  class__ (class_default_value (), this),
  version_ (version_default_value (), this),
  type_ (type_default_value (), this),
  edition_ (edition_default_value (), this),
  sp_ (sp_default_value (), this)
{
}

FilterOs::
FilterOs (const FilterOs& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  class__ (x.class__, f, this),
  version_ (x.version_, f, this),
  type_ (x.type_, f, this),
  edition_ (x.edition_, f, this),
  sp_ (x.sp_, f, this)
{
}

FilterOs::
FilterOs (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  class__ (this),
  version_ (this),
  type_ (this),
  edition_ (this),
  sp_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterOs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "class" && n.namespace_ ().empty ())
    {
      this->class__.set (ClassTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version_.set (VersionTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (TypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "edition" && n.namespace_ ().empty ())
    {
      this->edition_.set (EditionTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "sp" && n.namespace_ ().empty ())
    {
      this->sp_.set (SpTraits::create (i, f, this));
      continue;
    }
  }

  if (!class__.present ())
  {
    this->class__.set (class_default_value ());
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }

  if (!type_.present ())
  {
    this->type_.set (type_default_value ());
  }

  if (!edition_.present ())
  {
    this->edition_.set (edition_default_value ());
  }

  if (!sp_.present ())
  {
    this->sp_.set (sp_default_value ());
  }
}

FilterOs* FilterOs::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterOs (*this, f, c);
}

FilterOs& FilterOs::
operator= (const FilterOs& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->class__ = x.class__;
    this->version_ = x.version_;
    this->type_ = x.type_;
    this->edition_ = x.edition_;
    this->sp_ = x.sp_;
  }

  return *this;
}

FilterOs::
~FilterOs ()
{
}

// FilterOrgUnit
//

const FilterOrgUnit::UserContextType FilterOrgUnit::userContext_default_value_ (
  "1");

const FilterOrgUnit::DirectMemberType FilterOrgUnit::directMember_default_value_ (
  "0");

FilterOrgUnit::
FilterOrgUnit (const BoolType& bool_,
               const NotType& not_,
               const NameType& name)
: ::IFilter (bool_,
             not_),
  name_ (name, this),
  userContext_ (userContext_default_value (), this),
  directMember_ (directMember_default_value (), this)
{
}

FilterOrgUnit::
FilterOrgUnit (const FilterOrgUnit& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  name_ (x.name_, f, this),
  userContext_ (x.userContext_, f, this),
  directMember_ (x.directMember_, f, this)
{
}

FilterOrgUnit::
FilterOrgUnit (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  name_ (this),
  userContext_ (this),
  directMember_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterOrgUnit::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (NameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "userContext" && n.namespace_ ().empty ())
    {
      this->userContext_.set (UserContextTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "directMember" && n.namespace_ ().empty ())
    {
      this->directMember_.set (DirectMemberTraits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!userContext_.present ())
  {
    this->userContext_.set (userContext_default_value ());
  }

  if (!directMember_.present ())
  {
    this->directMember_.set (directMember_default_value ());
  }
}

FilterOrgUnit* FilterOrgUnit::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterOrgUnit (*this, f, c);
}

FilterOrgUnit& FilterOrgUnit::
operator= (const FilterOrgUnit& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->name_ = x.name_;
    this->userContext_ = x.userContext_;
    this->directMember_ = x.directMember_;
  }

  return *this;
}

FilterOrgUnit::
~FilterOrgUnit ()
{
}

// FilterPcmcia
//

FilterPcmcia::
FilterPcmcia (const BoolType& bool_,
              const NotType& not_)
: ::IFilter (bool_,
             not_)
{
}

FilterPcmcia::
FilterPcmcia (const FilterPcmcia& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::IFilter (x, f, c)
{
}

FilterPcmcia::
FilterPcmcia (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::IFilter (e, f, c)
{
}

FilterPcmcia* FilterPcmcia::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterPcmcia (*this, f, c);
}

FilterPcmcia::
~FilterPcmcia ()
{
}

// FilterPortable
//

const FilterPortable::UnknownType FilterPortable::unknown_default_value_ (
  "0");

const FilterPortable::DockedType FilterPortable::docked_default_value_ (
  "0");

const FilterPortable::UndockedType FilterPortable::undocked_default_value_ (
  "0");

FilterPortable::
FilterPortable (const BoolType& bool_,
                const NotType& not_)
: ::IFilter (bool_,
             not_),
  unknown_ (unknown_default_value (), this),
  docked_ (docked_default_value (), this),
  undocked_ (undocked_default_value (), this)
{
}

FilterPortable::
FilterPortable (const FilterPortable& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  unknown_ (x.unknown_, f, this),
  docked_ (x.docked_, f, this),
  undocked_ (x.undocked_, f, this)
{
}

FilterPortable::
FilterPortable (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  unknown_ (this),
  docked_ (this),
  undocked_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterPortable::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "unknown" && n.namespace_ ().empty ())
    {
      this->unknown_.set (UnknownTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "docked" && n.namespace_ ().empty ())
    {
      this->docked_.set (DockedTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "undocked" && n.namespace_ ().empty ())
    {
      this->undocked_.set (UndockedTraits::create (i, f, this));
      continue;
    }
  }

  if (!unknown_.present ())
  {
    this->unknown_.set (unknown_default_value ());
  }

  if (!docked_.present ())
  {
    this->docked_.set (docked_default_value ());
  }

  if (!undocked_.present ())
  {
    this->undocked_.set (undocked_default_value ());
  }
}

FilterPortable* FilterPortable::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterPortable (*this, f, c);
}

FilterPortable& FilterPortable::
operator= (const FilterPortable& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->unknown_ = x.unknown_;
    this->docked_ = x.docked_;
    this->undocked_ = x.undocked_;
  }

  return *this;
}

FilterPortable::
~FilterPortable ()
{
}

// FilterProcMode
//

const FilterProcMode::SynchForeType FilterProcMode::synchFore_default_value_ (
  "0");

const FilterProcMode::AsynchForeType FilterProcMode::asynchFore_default_value_ (
  "0");

const FilterProcMode::BackRefrType FilterProcMode::backRefr_default_value_ (
  "0");

const FilterProcMode::ForceRefrType FilterProcMode::forceRefr_default_value_ (
  "0");

const FilterProcMode::LinkTrnsType FilterProcMode::linkTrns_default_value_ (
  "0");

const FilterProcMode::NoChgType FilterProcMode::noChg_default_value_ (
  "0");

const FilterProcMode::RsopTrnsType FilterProcMode::rsopTrns_default_value_ (
  "0");

const FilterProcMode::SafeBootType FilterProcMode::safeBoot_default_value_ (
  "0");

const FilterProcMode::SlowLinkType FilterProcMode::slowLink_default_value_ (
  "0");

const FilterProcMode::VerbLogType FilterProcMode::verbLog_default_value_ (
  "0");

const FilterProcMode::RsopEnblType FilterProcMode::rsopEnbl_default_value_ (
  "0");

FilterProcMode::
FilterProcMode (const BoolType& bool_,
                const NotType& not_)
: ::IFilter (bool_,
             not_),
  synchFore_ (synchFore_default_value (), this),
  asynchFore_ (asynchFore_default_value (), this),
  backRefr_ (backRefr_default_value (), this),
  forceRefr_ (forceRefr_default_value (), this),
  linkTrns_ (linkTrns_default_value (), this),
  noChg_ (noChg_default_value (), this),
  rsopTrns_ (rsopTrns_default_value (), this),
  safeBoot_ (safeBoot_default_value (), this),
  slowLink_ (slowLink_default_value (), this),
  verbLog_ (verbLog_default_value (), this),
  rsopEnbl_ (rsopEnbl_default_value (), this)
{
}

FilterProcMode::
FilterProcMode (const FilterProcMode& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  synchFore_ (x.synchFore_, f, this),
  asynchFore_ (x.asynchFore_, f, this),
  backRefr_ (x.backRefr_, f, this),
  forceRefr_ (x.forceRefr_, f, this),
  linkTrns_ (x.linkTrns_, f, this),
  noChg_ (x.noChg_, f, this),
  rsopTrns_ (x.rsopTrns_, f, this),
  safeBoot_ (x.safeBoot_, f, this),
  slowLink_ (x.slowLink_, f, this),
  verbLog_ (x.verbLog_, f, this),
  rsopEnbl_ (x.rsopEnbl_, f, this)
{
}

FilterProcMode::
FilterProcMode (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  synchFore_ (this),
  asynchFore_ (this),
  backRefr_ (this),
  forceRefr_ (this),
  linkTrns_ (this),
  noChg_ (this),
  rsopTrns_ (this),
  safeBoot_ (this),
  slowLink_ (this),
  verbLog_ (this),
  rsopEnbl_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterProcMode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "synchFore" && n.namespace_ ().empty ())
    {
      this->synchFore_.set (SynchForeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "asynchFore" && n.namespace_ ().empty ())
    {
      this->asynchFore_.set (AsynchForeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "backRefr" && n.namespace_ ().empty ())
    {
      this->backRefr_.set (BackRefrTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "forceRefr" && n.namespace_ ().empty ())
    {
      this->forceRefr_.set (ForceRefrTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "linkTrns" && n.namespace_ ().empty ())
    {
      this->linkTrns_.set (LinkTrnsTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "noChg" && n.namespace_ ().empty ())
    {
      this->noChg_.set (NoChgTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "rsopTrns" && n.namespace_ ().empty ())
    {
      this->rsopTrns_.set (RsopTrnsTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "safeBoot" && n.namespace_ ().empty ())
    {
      this->safeBoot_.set (SafeBootTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "slowLink" && n.namespace_ ().empty ())
    {
      this->slowLink_.set (SlowLinkTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "verbLog" && n.namespace_ ().empty ())
    {
      this->verbLog_.set (VerbLogTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "rsopEnbl" && n.namespace_ ().empty ())
    {
      this->rsopEnbl_.set (RsopEnblTraits::create (i, f, this));
      continue;
    }
  }

  if (!synchFore_.present ())
  {
    this->synchFore_.set (synchFore_default_value ());
  }

  if (!asynchFore_.present ())
  {
    this->asynchFore_.set (asynchFore_default_value ());
  }

  if (!backRefr_.present ())
  {
    this->backRefr_.set (backRefr_default_value ());
  }

  if (!forceRefr_.present ())
  {
    this->forceRefr_.set (forceRefr_default_value ());
  }

  if (!linkTrns_.present ())
  {
    this->linkTrns_.set (linkTrns_default_value ());
  }

  if (!noChg_.present ())
  {
    this->noChg_.set (noChg_default_value ());
  }

  if (!rsopTrns_.present ())
  {
    this->rsopTrns_.set (rsopTrns_default_value ());
  }

  if (!safeBoot_.present ())
  {
    this->safeBoot_.set (safeBoot_default_value ());
  }

  if (!slowLink_.present ())
  {
    this->slowLink_.set (slowLink_default_value ());
  }

  if (!verbLog_.present ())
  {
    this->verbLog_.set (verbLog_default_value ());
  }

  if (!rsopEnbl_.present ())
  {
    this->rsopEnbl_.set (rsopEnbl_default_value ());
  }
}

FilterProcMode* FilterProcMode::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterProcMode (*this, f, c);
}

FilterProcMode& FilterProcMode::
operator= (const FilterProcMode& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->synchFore_ = x.synchFore_;
    this->asynchFore_ = x.asynchFore_;
    this->backRefr_ = x.backRefr_;
    this->forceRefr_ = x.forceRefr_;
    this->linkTrns_ = x.linkTrns_;
    this->noChg_ = x.noChg_;
    this->rsopTrns_ = x.rsopTrns_;
    this->safeBoot_ = x.safeBoot_;
    this->slowLink_ = x.slowLink_;
    this->verbLog_ = x.verbLog_;
    this->rsopEnbl_ = x.rsopEnbl_;
  }

  return *this;
}

FilterProcMode::
~FilterProcMode ()
{
}

// FilterRam
//

FilterRam::
FilterRam (const BoolType& bool_,
           const NotType& not_,
           const TotalMBType& totalMB)
: ::IFilter (bool_,
             not_),
  totalMB_ (totalMB, this)
{
}

FilterRam::
FilterRam (const FilterRam& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  totalMB_ (x.totalMB_, f, this)
{
}

FilterRam::
FilterRam (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  totalMB_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterRam::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "totalMB" && n.namespace_ ().empty ())
    {
      this->totalMB_.set (TotalMBTraits::create (i, f, this));
      continue;
    }
  }

  if (!totalMB_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "totalMB",
      "");
  }
}

FilterRam* FilterRam::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterRam (*this, f, c);
}

FilterRam& FilterRam::
operator= (const FilterRam& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->totalMB_ = x.totalMB_;
  }

  return *this;
}

FilterRam::
~FilterRam ()
{
}

// FilterRegistry
//

const FilterRegistry::TypeType FilterRegistry::type_default_value_ (
  "KEYEXISTS");

const FilterRegistry::SubtypeType FilterRegistry::subtype_default_value_ (
  "EQUALHEX");

const FilterRegistry::ValueTypeType FilterRegistry::valueType_default_value_ (
  "");

const FilterRegistry::HiveType FilterRegistry::hive_default_value_ (
  "HKEY_LOCAL_MACHINE");

const FilterRegistry::GteType FilterRegistry::gte_default_value_ (
  "0");

const FilterRegistry::LteType FilterRegistry::lte_default_value_ (
  "0");

FilterRegistry::
FilterRegistry (const BoolType& bool_,
                const NotType& not_,
                const KeyType& key)
: ::IFilter (bool_,
             not_),
  type_ (type_default_value (), this),
  subtype_ (subtype_default_value (), this),
  valueName_ (this),
  valueType_ (valueType_default_value (), this),
  valueData_ (this),
  variableName_ (this),
  key_ (key, this),
  hive_ (hive_default_value (), this),
  min_ (this),
  max_ (this),
  gte_ (gte_default_value (), this),
  lte_ (lte_default_value (), this),
  version_ (this)
{
}

FilterRegistry::
FilterRegistry (const FilterRegistry& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  type_ (x.type_, f, this),
  subtype_ (x.subtype_, f, this),
  valueName_ (x.valueName_, f, this),
  valueType_ (x.valueType_, f, this),
  valueData_ (x.valueData_, f, this),
  variableName_ (x.variableName_, f, this),
  key_ (x.key_, f, this),
  hive_ (x.hive_, f, this),
  min_ (x.min_, f, this),
  max_ (x.max_, f, this),
  gte_ (x.gte_, f, this),
  lte_ (x.lte_, f, this),
  version_ (x.version_, f, this)
{
}

FilterRegistry::
FilterRegistry (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  type_ (this),
  subtype_ (this),
  valueName_ (this),
  valueType_ (this),
  valueData_ (this),
  variableName_ (this),
  key_ (this),
  hive_ (this),
  min_ (this),
  max_ (this),
  gte_ (this),
  lte_ (this),
  version_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterRegistry::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (TypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "subtype" && n.namespace_ ().empty ())
    {
      this->subtype_.set (SubtypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "valueName" && n.namespace_ ().empty ())
    {
      this->valueName_.set (ValueNameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "valueType" && n.namespace_ ().empty ())
    {
      this->valueType_.set (ValueTypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "valueData" && n.namespace_ ().empty ())
    {
      this->valueData_.set (ValueDataTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "variableName" && n.namespace_ ().empty ())
    {
      this->variableName_.set (VariableNameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "key" && n.namespace_ ().empty ())
    {
      this->key_.set (KeyTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "hive" && n.namespace_ ().empty ())
    {
      this->hive_.set (HiveTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "min" && n.namespace_ ().empty ())
    {
      this->min_.set (MinTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (MaxTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "gte" && n.namespace_ ().empty ())
    {
      this->gte_.set (GteTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "lte" && n.namespace_ ().empty ())
    {
      this->lte_.set (LteTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version_.set (VersionTraits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    this->type_.set (type_default_value ());
  }

  if (!subtype_.present ())
  {
    this->subtype_.set (subtype_default_value ());
  }

  if (!valueType_.present ())
  {
    this->valueType_.set (valueType_default_value ());
  }

  if (!key_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "key",
      "");
  }

  if (!hive_.present ())
  {
    this->hive_.set (hive_default_value ());
  }

  if (!gte_.present ())
  {
    this->gte_.set (gte_default_value ());
  }

  if (!lte_.present ())
  {
    this->lte_.set (lte_default_value ());
  }
}

FilterRegistry* FilterRegistry::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterRegistry (*this, f, c);
}

FilterRegistry& FilterRegistry::
operator= (const FilterRegistry& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->type_ = x.type_;
    this->subtype_ = x.subtype_;
    this->valueName_ = x.valueName_;
    this->valueType_ = x.valueType_;
    this->valueData_ = x.valueData_;
    this->variableName_ = x.variableName_;
    this->key_ = x.key_;
    this->hive_ = x.hive_;
    this->min_ = x.min_;
    this->max_ = x.max_;
    this->gte_ = x.gte_;
    this->lte_ = x.lte_;
    this->version_ = x.version_;
  }

  return *this;
}

FilterRegistry::
~FilterRegistry ()
{
}

// FilterTerminal
//

const FilterTerminal::ValueType FilterTerminal::value_default_value_ (
  "");

const FilterTerminal::MinType FilterTerminal::min_default_value_ (
  "");

const FilterTerminal::MaxType FilterTerminal::max_default_value_ (
  "");

FilterTerminal::
FilterTerminal (const BoolType& bool_,
                const NotType& not_,
                const TypeType& type,
                const OptionType& option)
: ::IFilter (bool_,
             not_),
  type_ (type, this),
  option_ (option, this),
  value_ (value_default_value (), this),
  min_ (min_default_value (), this),
  max_ (max_default_value (), this)
{
}

FilterTerminal::
FilterTerminal (const FilterTerminal& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  type_ (x.type_, f, this),
  option_ (x.option_, f, this),
  value_ (x.value_, f, this),
  min_ (x.min_, f, this),
  max_ (x.max_, f, this)
{
}

FilterTerminal::
FilterTerminal (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  type_ (this),
  option_ (this),
  value_ (this),
  min_ (this),
  max_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterTerminal::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (TypeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "option" && n.namespace_ ().empty ())
    {
      this->option_.set (OptionTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (ValueTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "min" && n.namespace_ ().empty ())
    {
      this->min_.set (MinTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (MaxTraits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!option_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "option",
      "");
  }

  if (!value_.present ())
  {
    this->value_.set (value_default_value ());
  }

  if (!min_.present ())
  {
    this->min_.set (min_default_value ());
  }

  if (!max_.present ())
  {
    this->max_.set (max_default_value ());
  }
}

FilterTerminal* FilterTerminal::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterTerminal (*this, f, c);
}

FilterTerminal& FilterTerminal::
operator= (const FilterTerminal& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->type_ = x.type_;
    this->option_ = x.option_;
    this->value_ = x.value_;
    this->min_ = x.min_;
    this->max_ = x.max_;
  }

  return *this;
}

FilterTerminal::
~FilterTerminal ()
{
}

// FilterTime
//

FilterTime::
FilterTime (const BoolType& bool_,
            const NotType& not_,
            const BeginType& begin,
            const EndType& end)
: ::IFilter (bool_,
             not_),
  begin_ (begin, this),
  end_ (end, this)
{
}

FilterTime::
FilterTime (const FilterTime& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  begin_ (x.begin_, f, this),
  end_ (x.end_, f, this)
{
}

FilterTime::
FilterTime (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  begin_ (this),
  end_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterTime::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "begin" && n.namespace_ ().empty ())
    {
      this->begin_.set (BeginTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "end" && n.namespace_ ().empty ())
    {
      this->end_.set (EndTraits::create (i, f, this));
      continue;
    }
  }

  if (!begin_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "begin",
      "");
  }

  if (!end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "end",
      "");
  }
}

FilterTime* FilterTime::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterTime (*this, f, c);
}

FilterTime& FilterTime::
operator= (const FilterTime& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->begin_ = x.begin_;
    this->end_ = x.end_;
  }

  return *this;
}

FilterTime::
~FilterTime ()
{
}

// FilterUser
//

FilterUser::
FilterUser (const BoolType& bool_,
            const NotType& not_)
: ::IFilter (bool_,
             not_),
  name_ (this),
  sid_ (this)
{
}

FilterUser::
FilterUser (const FilterUser& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  name_ (x.name_, f, this),
  sid_ (x.sid_, f, this)
{
}

FilterUser::
FilterUser (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  name_ (this),
  sid_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterUser::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (NameTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "sid" && n.namespace_ ().empty ())
    {
      this->sid_.set (SidTraits::create (i, f, this));
      continue;
    }
  }
}

FilterUser* FilterUser::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterUser (*this, f, c);
}

FilterUser& FilterUser::
operator= (const FilterUser& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->name_ = x.name_;
    this->sid_ = x.sid_;
  }

  return *this;
}

FilterUser::
~FilterUser ()
{
}

// FilterWmi
//

const FilterWmi::NameSpaceType FilterWmi::nameSpace_default_value_ (
  "root\\cimv2");

FilterWmi::
FilterWmi (const BoolType& bool_,
           const NotType& not_,
           const QueryType& query)
: ::IFilter (bool_,
             not_),
  query_ (query, this),
  nameSpace_ (nameSpace_default_value (), this),
  property_ (this),
  variableName_ (this)
{
}

FilterWmi::
FilterWmi (const FilterWmi& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  query_ (x.query_, f, this),
  nameSpace_ (x.nameSpace_, f, this),
  property_ (x.property_, f, this),
  variableName_ (x.variableName_, f, this)
{
}

FilterWmi::
FilterWmi (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  query_ (this),
  nameSpace_ (this),
  property_ (this),
  variableName_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FilterWmi::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "query" && n.namespace_ ().empty ())
    {
      this->query_.set (QueryTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "nameSpace" && n.namespace_ ().empty ())
    {
      this->nameSpace_.set (NameSpaceTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "property" && n.namespace_ ().empty ())
    {
      this->property_.set (PropertyTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "variableName" && n.namespace_ ().empty ())
    {
      this->variableName_.set (VariableNameTraits::create (i, f, this));
      continue;
    }
  }

  if (!query_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "query",
      "");
  }

  if (!nameSpace_.present ())
  {
    this->nameSpace_.set (nameSpace_default_value ());
  }
}

FilterWmi* FilterWmi::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterWmi (*this, f, c);
}

FilterWmi& FilterWmi::
operator= (const FilterWmi& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->query_ = x.query_;
    this->nameSpace_ = x.nameSpace_;
    this->property_ = x.property_;
    this->variableName_ = x.variableName_;
  }

  return *this;
}

FilterWmi::
~FilterWmi ()
{
}

// FilterCollection
//

FilterCollection::
FilterCollection (const BoolType& bool_,
                  const NotType& not_)
: ::IFilter (bool_,
             not_),
  FilterSite_ (this),
  FilterGroup_ (this),
  FilterRunOnce_ (this),
  FilterLdap_ (this),
  FilterBattery_ (this),
  FilterComputer_ (this),
  FilterCpu_ (this),
  FilterDate_ (this),
  FilterDun_ (this),
  FilterDisk_ (this),
  FilterDomain_ (this),
  FilterVariable_ (this),
  FilterFile_ (this),
  FilterIpRange_ (this),
  FilterLanguage_ (this),
  FilterMacRange_ (this),
  FilterMsi_ (this),
  FilterOs_ (this),
  FilterOrgUnit_ (this),
  FilterPcmcia_ (this),
  FilterPortable_ (this),
  FilterProcMode_ (this),
  FilterRam_ (this),
  FilterRegistry_ (this),
  FilterTerminal_ (this),
  FilterTime_ (this),
  FilterUser_ (this),
  FilterWmi_ (this),
  FilterCollection1_ (this),
  name_ (this)
{
}

FilterCollection::
FilterCollection (const FilterCollection& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::IFilter (x, f, c),
  FilterSite_ (x.FilterSite_, f, this),
  FilterGroup_ (x.FilterGroup_, f, this),
  FilterRunOnce_ (x.FilterRunOnce_, f, this),
  FilterLdap_ (x.FilterLdap_, f, this),
  FilterBattery_ (x.FilterBattery_, f, this),
  FilterComputer_ (x.FilterComputer_, f, this),
  FilterCpu_ (x.FilterCpu_, f, this),
  FilterDate_ (x.FilterDate_, f, this),
  FilterDun_ (x.FilterDun_, f, this),
  FilterDisk_ (x.FilterDisk_, f, this),
  FilterDomain_ (x.FilterDomain_, f, this),
  FilterVariable_ (x.FilterVariable_, f, this),
  FilterFile_ (x.FilterFile_, f, this),
  FilterIpRange_ (x.FilterIpRange_, f, this),
  FilterLanguage_ (x.FilterLanguage_, f, this),
  FilterMacRange_ (x.FilterMacRange_, f, this),
  FilterMsi_ (x.FilterMsi_, f, this),
  FilterOs_ (x.FilterOs_, f, this),
  FilterOrgUnit_ (x.FilterOrgUnit_, f, this),
  FilterPcmcia_ (x.FilterPcmcia_, f, this),
  FilterPortable_ (x.FilterPortable_, f, this),
  FilterProcMode_ (x.FilterProcMode_, f, this),
  FilterRam_ (x.FilterRam_, f, this),
  FilterRegistry_ (x.FilterRegistry_, f, this),
  FilterTerminal_ (x.FilterTerminal_, f, this),
  FilterTime_ (x.FilterTime_, f, this),
  FilterUser_ (x.FilterUser_, f, this),
  FilterWmi_ (x.FilterWmi_, f, this),
  FilterCollection1_ (x.FilterCollection1_, f, this),
  name_ (x.name_, f, this)
{
}

FilterCollection::
FilterCollection (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::IFilter (e, f | ::xml_schema::Flags::base, c),
  FilterSite_ (this),
  FilterGroup_ (this),
  FilterRunOnce_ (this),
  FilterLdap_ (this),
  FilterBattery_ (this),
  FilterComputer_ (this),
  FilterCpu_ (this),
  FilterDate_ (this),
  FilterDun_ (this),
  FilterDisk_ (this),
  FilterDomain_ (this),
  FilterVariable_ (this),
  FilterFile_ (this),
  FilterIpRange_ (this),
  FilterLanguage_ (this),
  FilterMacRange_ (this),
  FilterMsi_ (this),
  FilterOs_ (this),
  FilterOrgUnit_ (this),
  FilterPcmcia_ (this),
  FilterPortable_ (this),
  FilterProcMode_ (this),
  FilterRam_ (this),
  FilterRegistry_ (this),
  FilterTerminal_ (this),
  FilterTime_ (this),
  FilterUser_ (this),
  FilterWmi_ (this),
  FilterCollection1_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FilterCollection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  this->::IFilter::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FilterSite
    //
    if (n.name () == "FilterSite" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterSiteType > r (
        FilterSiteTraits::create (i, f, this));

      this->FilterSite_.push_back (::std::move (r));
      continue;
    }

    // FilterGroup
    //
    if (n.name () == "FilterGroup" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterGroupType > r (
        FilterGroupTraits::create (i, f, this));

      this->FilterGroup_.push_back (::std::move (r));
      continue;
    }

    // FilterRunOnce
    //
    if (n.name () == "FilterRunOnce" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterRunOnceType > r (
        FilterRunOnceTraits::create (i, f, this));

      this->FilterRunOnce_.push_back (::std::move (r));
      continue;
    }

    // FilterLdap
    //
    if (n.name () == "FilterLdap" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterLdapType > r (
        FilterLdapTraits::create (i, f, this));

      this->FilterLdap_.push_back (::std::move (r));
      continue;
    }

    // FilterBattery
    //
    if (n.name () == "FilterBattery" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterBatteryType > r (
        FilterBatteryTraits::create (i, f, this));

      this->FilterBattery_.push_back (::std::move (r));
      continue;
    }

    // FilterComputer
    //
    if (n.name () == "FilterComputer" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterComputerType > r (
        FilterComputerTraits::create (i, f, this));

      this->FilterComputer_.push_back (::std::move (r));
      continue;
    }

    // FilterCpu
    //
    if (n.name () == "FilterCpu" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterCpuType > r (
        FilterCpuTraits::create (i, f, this));

      this->FilterCpu_.push_back (::std::move (r));
      continue;
    }

    // FilterDate
    //
    if (n.name () == "FilterDate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterDateType > r (
        FilterDateTraits::create (i, f, this));

      this->FilterDate_.push_back (::std::move (r));
      continue;
    }

    // FilterDun
    //
    if (n.name () == "FilterDun" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterDunType > r (
        FilterDunTraits::create (i, f, this));

      this->FilterDun_.push_back (::std::move (r));
      continue;
    }

    // FilterDisk
    //
    if (n.name () == "FilterDisk" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterDiskType > r (
        FilterDiskTraits::create (i, f, this));

      this->FilterDisk_.push_back (::std::move (r));
      continue;
    }

    // FilterDomain
    //
    if (n.name () == "FilterDomain" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterDomainType > r (
        FilterDomainTraits::create (i, f, this));

      this->FilterDomain_.push_back (::std::move (r));
      continue;
    }

    // FilterVariable
    //
    if (n.name () == "FilterVariable" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterVariableType > r (
        FilterVariableTraits::create (i, f, this));

      this->FilterVariable_.push_back (::std::move (r));
      continue;
    }

    // FilterFile
    //
    if (n.name () == "FilterFile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterFileType > r (
        FilterFileTraits::create (i, f, this));

      this->FilterFile_.push_back (::std::move (r));
      continue;
    }

    // FilterIpRange
    //
    if (n.name () == "FilterIpRange" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterIpRangeType > r (
        FilterIpRangeTraits::create (i, f, this));

      this->FilterIpRange_.push_back (::std::move (r));
      continue;
    }

    // FilterLanguage
    //
    if (n.name () == "FilterLanguage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterLanguageType > r (
        FilterLanguageTraits::create (i, f, this));

      this->FilterLanguage_.push_back (::std::move (r));
      continue;
    }

    // FilterMacRange
    //
    if (n.name () == "FilterMacRange" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterMacRangeType > r (
        FilterMacRangeTraits::create (i, f, this));

      this->FilterMacRange_.push_back (::std::move (r));
      continue;
    }

    // FilterMsi
    //
    if (n.name () == "FilterMsi" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterMsiType > r (
        FilterMsiTraits::create (i, f, this));

      this->FilterMsi_.push_back (::std::move (r));
      continue;
    }

    // FilterOs
    //
    if (n.name () == "FilterOs" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterOsType > r (
        FilterOsTraits::create (i, f, this));

      this->FilterOs_.push_back (::std::move (r));
      continue;
    }

    // FilterOrgUnit
    //
    if (n.name () == "FilterOrgUnit" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterOrgUnitType > r (
        FilterOrgUnitTraits::create (i, f, this));

      this->FilterOrgUnit_.push_back (::std::move (r));
      continue;
    }

    // FilterPcmcia
    //
    if (n.name () == "FilterPcmcia" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterPcmciaType > r (
        FilterPcmciaTraits::create (i, f, this));

      this->FilterPcmcia_.push_back (::std::move (r));
      continue;
    }

    // FilterPortable
    //
    if (n.name () == "FilterPortable" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterPortableType > r (
        FilterPortableTraits::create (i, f, this));

      this->FilterPortable_.push_back (::std::move (r));
      continue;
    }

    // FilterProcMode
    //
    if (n.name () == "FilterProcMode" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterProcModeType > r (
        FilterProcModeTraits::create (i, f, this));

      this->FilterProcMode_.push_back (::std::move (r));
      continue;
    }

    // FilterRam
    //
    if (n.name () == "FilterRam" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterRamType > r (
        FilterRamTraits::create (i, f, this));

      this->FilterRam_.push_back (::std::move (r));
      continue;
    }

    // FilterRegistry
    //
    if (n.name () == "FilterRegistry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterRegistryType > r (
        FilterRegistryTraits::create (i, f, this));

      this->FilterRegistry_.push_back (::std::move (r));
      continue;
    }

    // FilterTerminal
    //
    if (n.name () == "FilterTerminal" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterTerminalType > r (
        FilterTerminalTraits::create (i, f, this));

      this->FilterTerminal_.push_back (::std::move (r));
      continue;
    }

    // FilterTime
    //
    if (n.name () == "FilterTime" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterTimeType > r (
        FilterTimeTraits::create (i, f, this));

      this->FilterTime_.push_back (::std::move (r));
      continue;
    }

    // FilterUser
    //
    if (n.name () == "FilterUser" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterUserType > r (
        FilterUserTraits::create (i, f, this));

      this->FilterUser_.push_back (::std::move (r));
      continue;
    }

    // FilterWmi
    //
    if (n.name () == "FilterWmi" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterWmiType > r (
        FilterWmiTraits::create (i, f, this));

      this->FilterWmi_.push_back (::std::move (r));
      continue;
    }

    // FilterCollection
    //
    if (n.name () == "FilterCollection" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FilterCollection1Type > r (
        FilterCollection1Traits::create (i, f, this));

      this->FilterCollection1_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (NameTraits::create (i, f, this));
      continue;
    }
  }
}

FilterCollection* FilterCollection::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FilterCollection (*this, f, c);
}

FilterCollection& FilterCollection::
operator= (const FilterCollection& x)
{
  if (this != &x)
  {
    static_cast< ::IFilter& > (*this) = x;
    this->FilterSite_ = x.FilterSite_;
    this->FilterGroup_ = x.FilterGroup_;
    this->FilterRunOnce_ = x.FilterRunOnce_;
    this->FilterLdap_ = x.FilterLdap_;
    this->FilterBattery_ = x.FilterBattery_;
    this->FilterComputer_ = x.FilterComputer_;
    this->FilterCpu_ = x.FilterCpu_;
    this->FilterDate_ = x.FilterDate_;
    this->FilterDun_ = x.FilterDun_;
    this->FilterDisk_ = x.FilterDisk_;
    this->FilterDomain_ = x.FilterDomain_;
    this->FilterVariable_ = x.FilterVariable_;
    this->FilterFile_ = x.FilterFile_;
    this->FilterIpRange_ = x.FilterIpRange_;
    this->FilterLanguage_ = x.FilterLanguage_;
    this->FilterMacRange_ = x.FilterMacRange_;
    this->FilterMsi_ = x.FilterMsi_;
    this->FilterOs_ = x.FilterOs_;
    this->FilterOrgUnit_ = x.FilterOrgUnit_;
    this->FilterPcmcia_ = x.FilterPcmcia_;
    this->FilterPortable_ = x.FilterPortable_;
    this->FilterProcMode_ = x.FilterProcMode_;
    this->FilterRam_ = x.FilterRam_;
    this->FilterRegistry_ = x.FilterRegistry_;
    this->FilterTerminal_ = x.FilterTerminal_;
    this->FilterTime_ = x.FilterTime_;
    this->FilterUser_ = x.FilterUser_;
    this->FilterWmi_ = x.FilterWmi_;
    this->FilterCollection1_ = x.FilterCollection1_;
    this->name_ = x.name_;
  }

  return *this;
}

FilterCollection::
~FilterCollection ()
{
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

::std::ostream&
operator<< (::std::ostream& o, EnumFilterTerminalOption::Value i)
{
  return o << EnumFilterTerminalOption::_xsd_EnumFilterTerminalOption_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterTerminalOption& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterTerminalOption >
_xsd_EnumFilterTerminalOption_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterTerminalType::Value i)
{
  return o << EnumFilterTerminalType::_xsd_EnumFilterTerminalType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterTerminalType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterTerminalType >
_xsd_EnumFilterTerminalType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterRegistryHive::Value i)
{
  return o << EnumFilterRegistryHive::_xsd_EnumFilterRegistryHive_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterRegistryHive& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterRegistryHive >
_xsd_EnumFilterRegistryHive_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterRegistryValueType::Value i)
{
  return o << EnumFilterRegistryValueType::_xsd_EnumFilterRegistryValueType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterRegistryValueType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterRegistryValueType >
_xsd_EnumFilterRegistryValueType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterRegistrySubType::Value i)
{
  return o << EnumFilterRegistrySubType::_xsd_EnumFilterRegistrySubType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterRegistrySubType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterRegistrySubType >
_xsd_EnumFilterRegistrySubType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterRegistryType::Value i)
{
  return o << EnumFilterRegistryType::_xsd_EnumFilterRegistryType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterRegistryType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterRegistryType >
_xsd_EnumFilterRegistryType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterOsSp::Value i)
{
  return o << EnumFilterOsSp::_xsd_EnumFilterOsSp_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterOsSp& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterOsSp >
_xsd_EnumFilterOsSp_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterOsEdition::Value i)
{
  return o << EnumFilterOsEdition::_xsd_EnumFilterOsEdition_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterOsEdition& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterOsEdition >
_xsd_EnumFilterOsEdition_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterOsType::Value i)
{
  return o << EnumFilterOsType::_xsd_EnumFilterOsType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterOsType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterOsType >
_xsd_EnumFilterOsType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterOsVersion::Value i)
{
  return o << EnumFilterOsVersion::_xsd_EnumFilterOsVersion_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterOsVersion& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterOsVersion >
_xsd_EnumFilterOsVersion_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterOsClass::Value i)
{
  return o << EnumFilterOsClass::_xsd_EnumFilterOsClass_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterOsClass& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterOsClass >
_xsd_EnumFilterOsClass_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterMsiSubType::Value i)
{
  return o << EnumFilterMsiSubType::_xsd_EnumFilterMsiSubType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterMsiSubType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterMsiSubType >
_xsd_EnumFilterMsiSubType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterMsiType::Value i)
{
  return o << EnumFilterMsiType::_xsd_EnumFilterMsiType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterMsiType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterMsiType >
_xsd_EnumFilterMsiType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterFileType::Value i)
{
  return o << EnumFilterFileType::_xsd_EnumFilterFileType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterFileType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterFileType >
_xsd_EnumFilterFileType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterDunType::Value i)
{
  return o << EnumFilterDunType::_xsd_EnumFilterDunType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterDunType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterDunType >
_xsd_EnumFilterDunType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterDateDow::Value i)
{
  return o << EnumFilterDateDow::_xsd_EnumFilterDateDow_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterDateDow& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterDateDow >
_xsd_EnumFilterDateDow_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterDatePeriod::Value i)
{
  return o << EnumFilterDatePeriod::_xsd_EnumFilterDatePeriod_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterDatePeriod& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterDatePeriod >
_xsd_EnumFilterDatePeriod_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterComputerNameType::Value i)
{
  return o << EnumFilterComputerNameType::_xsd_EnumFilterComputerNameType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterComputerNameType& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterComputerNameType >
_xsd_EnumFilterComputerNameType_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumFilterBool::Value i)
{
  return o << EnumFilterBool::_xsd_EnumFilterBool_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumFilterBool& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumFilterBool >
_xsd_EnumFilterBool_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, EnumTrueFalse::Value i)
{
  return o << EnumTrueFalse::_xsd_EnumTrueFalse_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const EnumTrueFalse& i)
{
  return o << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumTrueFalse >
_xsd_EnumTrueFalse_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const IFilter& i)
{
  o << ::std::endl << "bool: " << i.bool_ ();
  o << ::std::endl << "not: " << i.not_ ();
  if (i.hidden ())
  {
    o << ::std::endl << "hidden: " << *i.hidden ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filters_t& i)
{
  for (Filters_t::FilterSiteConstIterator
       b (i.FilterSite ().begin ()), e (i.FilterSite ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterSite: " << *b;
  }

  for (Filters_t::FilterGroupConstIterator
       b (i.FilterGroup ().begin ()), e (i.FilterGroup ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterGroup: " << *b;
  }

  for (Filters_t::FilterRunOnceConstIterator
       b (i.FilterRunOnce ().begin ()), e (i.FilterRunOnce ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterRunOnce: " << *b;
  }

  for (Filters_t::FilterLdapConstIterator
       b (i.FilterLdap ().begin ()), e (i.FilterLdap ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterLdap: " << *b;
  }

  for (Filters_t::FilterBatteryConstIterator
       b (i.FilterBattery ().begin ()), e (i.FilterBattery ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterBattery: " << *b;
  }

  for (Filters_t::FilterComputerConstIterator
       b (i.FilterComputer ().begin ()), e (i.FilterComputer ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterComputer: " << *b;
  }

  for (Filters_t::FilterCpuConstIterator
       b (i.FilterCpu ().begin ()), e (i.FilterCpu ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterCpu: " << *b;
  }

  for (Filters_t::FilterDateConstIterator
       b (i.FilterDate ().begin ()), e (i.FilterDate ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterDate: " << *b;
  }

  for (Filters_t::FilterDunConstIterator
       b (i.FilterDun ().begin ()), e (i.FilterDun ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterDun: " << *b;
  }

  for (Filters_t::FilterDiskConstIterator
       b (i.FilterDisk ().begin ()), e (i.FilterDisk ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterDisk: " << *b;
  }

  for (Filters_t::FilterDomainConstIterator
       b (i.FilterDomain ().begin ()), e (i.FilterDomain ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterDomain: " << *b;
  }

  for (Filters_t::FilterVariableConstIterator
       b (i.FilterVariable ().begin ()), e (i.FilterVariable ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterVariable: " << *b;
  }

  for (Filters_t::FilterFileConstIterator
       b (i.FilterFile ().begin ()), e (i.FilterFile ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterFile: " << *b;
  }

  for (Filters_t::FilterIpRangeConstIterator
       b (i.FilterIpRange ().begin ()), e (i.FilterIpRange ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterIpRange: " << *b;
  }

  for (Filters_t::FilterLanguageConstIterator
       b (i.FilterLanguage ().begin ()), e (i.FilterLanguage ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterLanguage: " << *b;
  }

  for (Filters_t::FilterMacRangeConstIterator
       b (i.FilterMacRange ().begin ()), e (i.FilterMacRange ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterMacRange: " << *b;
  }

  for (Filters_t::FilterMsiConstIterator
       b (i.FilterMsi ().begin ()), e (i.FilterMsi ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterMsi: " << *b;
  }

  for (Filters_t::FilterOsConstIterator
       b (i.FilterOs ().begin ()), e (i.FilterOs ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterOs: " << *b;
  }

  for (Filters_t::FilterOrgUnitConstIterator
       b (i.FilterOrgUnit ().begin ()), e (i.FilterOrgUnit ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterOrgUnit: " << *b;
  }

  for (Filters_t::FilterPcmciaConstIterator
       b (i.FilterPcmcia ().begin ()), e (i.FilterPcmcia ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterPcmcia: " << *b;
  }

  for (Filters_t::FilterPortableConstIterator
       b (i.FilterPortable ().begin ()), e (i.FilterPortable ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterPortable: " << *b;
  }

  for (Filters_t::FilterProcModeConstIterator
       b (i.FilterProcMode ().begin ()), e (i.FilterProcMode ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterProcMode: " << *b;
  }

  for (Filters_t::FilterRamConstIterator
       b (i.FilterRam ().begin ()), e (i.FilterRam ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterRam: " << *b;
  }

  for (Filters_t::FilterRegistryConstIterator
       b (i.FilterRegistry ().begin ()), e (i.FilterRegistry ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterRegistry: " << *b;
  }

  for (Filters_t::FilterTerminalConstIterator
       b (i.FilterTerminal ().begin ()), e (i.FilterTerminal ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterTerminal: " << *b;
  }

  for (Filters_t::FilterTimeConstIterator
       b (i.FilterTime ().begin ()), e (i.FilterTime ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterTime: " << *b;
  }

  for (Filters_t::FilterUserConstIterator
       b (i.FilterUser ().begin ()), e (i.FilterUser ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterUser: " << *b;
  }

  for (Filters_t::FilterWmiConstIterator
       b (i.FilterWmi ().begin ()), e (i.FilterWmi ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterWmi: " << *b;
  }

  for (Filters_t::FilterCollectionConstIterator
       b (i.FilterCollection ().begin ()), e (i.FilterCollection ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterCollection: " << *b;
  }

  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Filters_t >
_xsd_Filters_t_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const FilterSite& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "name: " << i.name ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterGroup& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "sid: " << i.sid ();
  o << ::std::endl << "userContext: " << i.userContext ();
  o << ::std::endl << "primaryGroup: " << i.primaryGroup ();
  o << ::std::endl << "localGroup: " << i.localGroup ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterRunOnce& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "userContext: " << i.userContext ();
  o << ::std::endl << "comments: " << i.comments ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterLdap& i)
{
  o << static_cast< const ::IFilter& > (i);

  if (i.searchFilter ())
  {
    o << ::std::endl << "searchFilter: " << *i.searchFilter ();
  }

  o << ::std::endl << "binding: " << i.binding ();
  if (i.variableName ())
  {
    o << ::std::endl << "variableName: " << *i.variableName ();
  }

  if (i.attribute ())
  {
    o << ::std::endl << "attribute: " << *i.attribute ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterBattery& i)
{
  o << static_cast< const ::IFilter& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterComputer& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "name: " << i.name ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterCpu& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "speedMHz: " << i.speedMHz ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterDate& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "period: " << i.period ();
  if (i.dow ())
  {
    o << ::std::endl << "dow: " << *i.dow ();
  }

  if (i.day ())
  {
    o << ::std::endl << "day: " << *i.day ();
  }

  if (i.month ())
  {
    o << ::std::endl << "month: " << *i.month ();
  }

  if (i.year ())
  {
    o << ::std::endl << "year: " << *i.year ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterDun& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "type: " << i.type ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterDisk& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "freeSpace: " << i.freeSpace ();
  o << ::std::endl << "drive: " << i.drive ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterDomain& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "userContext: " << i.userContext ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterVariable& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "variableName: " << i.variableName ();
  o << ::std::endl << "value: " << i.value ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterFile& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "gte: " << i.gte ();
  o << ::std::endl << "lte: " << i.lte ();
  if (i.min ())
  {
    o << ::std::endl << "min: " << *i.min ();
  }

  if (i.max ())
  {
    o << ::std::endl << "max: " << *i.max ();
  }

  o << ::std::endl << "path: " << i.path ();
  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "folder: " << i.folder ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterIpRange& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "min: " << i.min ();
  o << ::std::endl << "max: " << i.max ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterLanguage& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "default: " << i.default_ ();
  o << ::std::endl << "system: " << i.system ();
  o << ::std::endl << "native: " << i.native ();
  if (i.displayName ())
  {
    o << ::std::endl << "displayName: " << *i.displayName ();
  }

  o << ::std::endl << "language: " << i.language ();
  o << ::std::endl << "locale: " << i.locale ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterMacRange& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "min: " << i.min ();
  o << ::std::endl << "max: " << i.max ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterMsi& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "subtype: " << i.subtype ();
  if (i.code ())
  {
    o << ::std::endl << "code: " << *i.code ();
  }

  if (i.item ())
  {
    o << ::std::endl << "item: " << *i.item ();
  }

  if (i.value ())
  {
    o << ::std::endl << "value: " << *i.value ();
  }

  if (i.min ())
  {
    o << ::std::endl << "min: " << *i.min ();
  }

  if (i.max ())
  {
    o << ::std::endl << "max: " << *i.max ();
  }

  o << ::std::endl << "gte: " << i.gte ();
  o << ::std::endl << "lte: " << i.lte ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterOs& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "class: " << i.class_ ();
  o << ::std::endl << "version: " << i.version ();
  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "edition: " << i.edition ();
  o << ::std::endl << "sp: " << i.sp ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterOrgUnit& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "userContext: " << i.userContext ();
  o << ::std::endl << "directMember: " << i.directMember ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterPcmcia& i)
{
  o << static_cast< const ::IFilter& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterPortable& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "unknown: " << i.unknown ();
  o << ::std::endl << "docked: " << i.docked ();
  o << ::std::endl << "undocked: " << i.undocked ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterProcMode& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "synchFore: " << i.synchFore ();
  o << ::std::endl << "asynchFore: " << i.asynchFore ();
  o << ::std::endl << "backRefr: " << i.backRefr ();
  o << ::std::endl << "forceRefr: " << i.forceRefr ();
  o << ::std::endl << "linkTrns: " << i.linkTrns ();
  o << ::std::endl << "noChg: " << i.noChg ();
  o << ::std::endl << "rsopTrns: " << i.rsopTrns ();
  o << ::std::endl << "safeBoot: " << i.safeBoot ();
  o << ::std::endl << "slowLink: " << i.slowLink ();
  o << ::std::endl << "verbLog: " << i.verbLog ();
  o << ::std::endl << "rsopEnbl: " << i.rsopEnbl ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterRam& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "totalMB: " << i.totalMB ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterRegistry& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "subtype: " << i.subtype ();
  if (i.valueName ())
  {
    o << ::std::endl << "valueName: " << *i.valueName ();
  }

  o << ::std::endl << "valueType: " << i.valueType ();
  if (i.valueData ())
  {
    o << ::std::endl << "valueData: " << *i.valueData ();
  }

  if (i.variableName ())
  {
    o << ::std::endl << "variableName: " << *i.variableName ();
  }

  o << ::std::endl << "key: " << i.key ();
  o << ::std::endl << "hive: " << i.hive ();
  if (i.min ())
  {
    o << ::std::endl << "min: " << *i.min ();
  }

  if (i.max ())
  {
    o << ::std::endl << "max: " << *i.max ();
  }

  o << ::std::endl << "gte: " << i.gte ();
  o << ::std::endl << "lte: " << i.lte ();
  if (i.version ())
  {
    o << ::std::endl << "version: " << *i.version ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterTerminal& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "option: " << i.option ();
  o << ::std::endl << "value: " << i.value ();
  o << ::std::endl << "min: " << i.min ();
  o << ::std::endl << "max: " << i.max ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterTime& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "begin: " << i.begin ();
  o << ::std::endl << "end: " << i.end ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterUser& i)
{
  o << static_cast< const ::IFilter& > (i);

  if (i.name ())
  {
    o << ::std::endl << "name: " << *i.name ();
  }

  if (i.sid ())
  {
    o << ::std::endl << "sid: " << *i.sid ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterWmi& i)
{
  o << static_cast< const ::IFilter& > (i);

  o << ::std::endl << "query: " << i.query ();
  o << ::std::endl << "nameSpace: " << i.nameSpace ();
  if (i.property ())
  {
    o << ::std::endl << "property: " << *i.property ();
  }

  if (i.variableName ())
  {
    o << ::std::endl << "variableName: " << *i.variableName ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const FilterCollection& i)
{
  o << static_cast< const ::IFilter& > (i);

  for (FilterCollection::FilterSiteConstIterator
       b (i.FilterSite ().begin ()), e (i.FilterSite ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterSite: " << *b;
  }

  for (FilterCollection::FilterGroupConstIterator
       b (i.FilterGroup ().begin ()), e (i.FilterGroup ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterGroup: " << *b;
  }

  for (FilterCollection::FilterRunOnceConstIterator
       b (i.FilterRunOnce ().begin ()), e (i.FilterRunOnce ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterRunOnce: " << *b;
  }

  for (FilterCollection::FilterLdapConstIterator
       b (i.FilterLdap ().begin ()), e (i.FilterLdap ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterLdap: " << *b;
  }

  for (FilterCollection::FilterBatteryConstIterator
       b (i.FilterBattery ().begin ()), e (i.FilterBattery ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterBattery: " << *b;
  }

  for (FilterCollection::FilterComputerConstIterator
       b (i.FilterComputer ().begin ()), e (i.FilterComputer ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterComputer: " << *b;
  }

  for (FilterCollection::FilterCpuConstIterator
       b (i.FilterCpu ().begin ()), e (i.FilterCpu ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterCpu: " << *b;
  }

  for (FilterCollection::FilterDateConstIterator
       b (i.FilterDate ().begin ()), e (i.FilterDate ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterDate: " << *b;
  }

  for (FilterCollection::FilterDunConstIterator
       b (i.FilterDun ().begin ()), e (i.FilterDun ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterDun: " << *b;
  }

  for (FilterCollection::FilterDiskConstIterator
       b (i.FilterDisk ().begin ()), e (i.FilterDisk ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterDisk: " << *b;
  }

  for (FilterCollection::FilterDomainConstIterator
       b (i.FilterDomain ().begin ()), e (i.FilterDomain ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterDomain: " << *b;
  }

  for (FilterCollection::FilterVariableConstIterator
       b (i.FilterVariable ().begin ()), e (i.FilterVariable ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterVariable: " << *b;
  }

  for (FilterCollection::FilterFileConstIterator
       b (i.FilterFile ().begin ()), e (i.FilterFile ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterFile: " << *b;
  }

  for (FilterCollection::FilterIpRangeConstIterator
       b (i.FilterIpRange ().begin ()), e (i.FilterIpRange ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterIpRange: " << *b;
  }

  for (FilterCollection::FilterLanguageConstIterator
       b (i.FilterLanguage ().begin ()), e (i.FilterLanguage ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterLanguage: " << *b;
  }

  for (FilterCollection::FilterMacRangeConstIterator
       b (i.FilterMacRange ().begin ()), e (i.FilterMacRange ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterMacRange: " << *b;
  }

  for (FilterCollection::FilterMsiConstIterator
       b (i.FilterMsi ().begin ()), e (i.FilterMsi ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterMsi: " << *b;
  }

  for (FilterCollection::FilterOsConstIterator
       b (i.FilterOs ().begin ()), e (i.FilterOs ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterOs: " << *b;
  }

  for (FilterCollection::FilterOrgUnitConstIterator
       b (i.FilterOrgUnit ().begin ()), e (i.FilterOrgUnit ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterOrgUnit: " << *b;
  }

  for (FilterCollection::FilterPcmciaConstIterator
       b (i.FilterPcmcia ().begin ()), e (i.FilterPcmcia ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterPcmcia: " << *b;
  }

  for (FilterCollection::FilterPortableConstIterator
       b (i.FilterPortable ().begin ()), e (i.FilterPortable ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterPortable: " << *b;
  }

  for (FilterCollection::FilterProcModeConstIterator
       b (i.FilterProcMode ().begin ()), e (i.FilterProcMode ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterProcMode: " << *b;
  }

  for (FilterCollection::FilterRamConstIterator
       b (i.FilterRam ().begin ()), e (i.FilterRam ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterRam: " << *b;
  }

  for (FilterCollection::FilterRegistryConstIterator
       b (i.FilterRegistry ().begin ()), e (i.FilterRegistry ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterRegistry: " << *b;
  }

  for (FilterCollection::FilterTerminalConstIterator
       b (i.FilterTerminal ().begin ()), e (i.FilterTerminal ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterTerminal: " << *b;
  }

  for (FilterCollection::FilterTimeConstIterator
       b (i.FilterTime ().begin ()), e (i.FilterTime ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterTime: " << *b;
  }

  for (FilterCollection::FilterUserConstIterator
       b (i.FilterUser ().begin ()), e (i.FilterUser ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterUser: " << *b;
  }

  for (FilterCollection::FilterWmiConstIterator
       b (i.FilterWmi ().begin ()), e (i.FilterWmi ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterWmi: " << *b;
  }

  for (FilterCollection::FilterCollection1ConstIterator
       b (i.FilterCollection1 ().begin ()), e (i.FilterCollection1 ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "FilterCollection: " << *b;
  }

  if (i.name ())
  {
    o << ::std::endl << "name: " << *i.name ();
  }

  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::Filters_t >
Filters (const ::std::string& u,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Filters_t > (
    ::Filters (
      std::move (d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr< ::Filters_t >
Filters (const ::std::string& u,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Filters_t > (
    ::Filters (
      std::move (d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr< ::Filters_t >
Filters (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Filters_t > (
    ::Filters (
      std::move (d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Filters (isrc, f, p);
}

::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Filters (isrc, h, f, p);
}

::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Filters (isrc, h, f, p);
}

::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Filters (isrc, f, p);
}

::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Filters (isrc, h, f, p);
}

::std::unique_ptr< ::Filters_t >
Filters (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Filters (isrc, h, f, p);
}

::std::unique_ptr< ::Filters_t >
Filters (::xercesc::InputSource& i,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Filters_t > (
    ::Filters (
      std::move (d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr< ::Filters_t >
Filters (::xercesc::InputSource& i,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Filters_t > (
    ::Filters (
      std::move (d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr< ::Filters_t >
Filters (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Filters_t > (
    ::Filters (
      std::move (d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr< ::Filters_t >
Filters (const ::xercesc::DOMDocument& doc,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
{
  if (f & ::xml_schema::Flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Filters_t > (
      ::Filters (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
      "Filters",
      "",
      &::xsd::cxx::tree::factory_impl< ::Filters_t >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::unique_ptr< ::Filters_t > r (
      dynamic_cast< ::Filters_t* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Filters",
    "");
}

::std::unique_ptr< ::Filters_t >
Filters (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::Flags::keep_dom) &&
     !(f & ::xml_schema::Flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::Flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
      "Filters",
      "",
      &::xsd::cxx::tree::factory_impl< ::Filters_t >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::unique_ptr< ::Filters_t > r (
      dynamic_cast< ::Filters_t* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Filters",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (::xercesc::DOMElement& e, const EnumFilterTerminalOption& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterTerminalOption& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterTerminalOption& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterTerminalOption >
_xsd_EnumFilterTerminalOption_type_serializer_init (
  "enumFilterTerminalOption",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterTerminalType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterTerminalType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterTerminalType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterTerminalType >
_xsd_EnumFilterTerminalType_type_serializer_init (
  "enumFilterTerminalType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterRegistryHive& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterRegistryHive& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterRegistryHive& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterRegistryHive >
_xsd_EnumFilterRegistryHive_type_serializer_init (
  "enumFilterRegistryHive",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterRegistryValueType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterRegistryValueType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterRegistryValueType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterRegistryValueType >
_xsd_EnumFilterRegistryValueType_type_serializer_init (
  "enumFilterRegistryValueType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterRegistrySubType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterRegistrySubType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterRegistrySubType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterRegistrySubType >
_xsd_EnumFilterRegistrySubType_type_serializer_init (
  "enumFilterRegistrySubType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterRegistryType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterRegistryType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterRegistryType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterRegistryType >
_xsd_EnumFilterRegistryType_type_serializer_init (
  "enumFilterRegistryType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterOsSp& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterOsSp& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterOsSp& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterOsSp >
_xsd_EnumFilterOsSp_type_serializer_init (
  "enumFilterOsSp",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterOsEdition& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterOsEdition& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterOsEdition& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterOsEdition >
_xsd_EnumFilterOsEdition_type_serializer_init (
  "enumFilterOsEdition",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterOsType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterOsType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterOsType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterOsType >
_xsd_EnumFilterOsType_type_serializer_init (
  "enumFilterOsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterOsVersion& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterOsVersion& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterOsVersion& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterOsVersion >
_xsd_EnumFilterOsVersion_type_serializer_init (
  "enumFilterOsVersion",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterOsClass& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterOsClass& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterOsClass& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterOsClass >
_xsd_EnumFilterOsClass_type_serializer_init (
  "enumFilterOsClass",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterMsiSubType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterMsiSubType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterMsiSubType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterMsiSubType >
_xsd_EnumFilterMsiSubType_type_serializer_init (
  "enumFilterMsiSubType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterMsiType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterMsiType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterMsiType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterMsiType >
_xsd_EnumFilterMsiType_type_serializer_init (
  "enumFilterMsiType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterFileType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterFileType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterFileType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterFileType >
_xsd_EnumFilterFileType_type_serializer_init (
  "enumFilterFileType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterDunType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterDunType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterDunType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterDunType >
_xsd_EnumFilterDunType_type_serializer_init (
  "enumFilterDunType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterDateDow& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterDateDow& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterDateDow& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterDateDow >
_xsd_EnumFilterDateDow_type_serializer_init (
  "enumFilterDateDow",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterDatePeriod& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterDatePeriod& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterDatePeriod& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterDatePeriod >
_xsd_EnumFilterDatePeriod_type_serializer_init (
  "enumFilterDatePeriod",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterComputerNameType& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterComputerNameType& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterComputerNameType& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterComputerNameType >
_xsd_EnumFilterComputerNameType_type_serializer_init (
  "enumFilterComputerNameType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumFilterBool& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumFilterBool& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumFilterBool& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumFilterBool >
_xsd_EnumFilterBool_type_serializer_init (
  "enumFilterBool",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnumTrueFalse& i)
{
  e << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const EnumTrueFalse& i)
{
  a << static_cast< const ::xml_schema::String& > (i);
}

void
operator<< (::xml_schema::ListStream& l,
            const EnumTrueFalse& i)
{
  l << static_cast< const ::xml_schema::String& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumTrueFalse >
_xsd_EnumTrueFalse_type_serializer_init (
  "enumTrueFalse",
  "");


void
operator<< (::xercesc::DOMElement& e, const IFilter& i)
{
  e << static_cast< const ::xml_schema::Type& > (i);

  // bool
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "bool",
        e));

    a << i.bool_ ();
  }

  // not
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "not",
        e));

    a << i.not_ ();
  }

  // hidden
  //
  if (i.hidden ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hidden",
        e));

    a << *i.hidden ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filters_t& i)
{
  e << static_cast< const ::xml_schema::Type& > (i);

  // FilterSite
  //
  for (Filters_t::FilterSiteConstIterator
       b (i.FilterSite ().begin ()), n (i.FilterSite ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterSite",
        e));

    s << *b;
  }

  // FilterGroup
  //
  for (Filters_t::FilterGroupConstIterator
       b (i.FilterGroup ().begin ()), n (i.FilterGroup ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterGroup",
        e));

    s << *b;
  }

  // FilterRunOnce
  //
  for (Filters_t::FilterRunOnceConstIterator
       b (i.FilterRunOnce ().begin ()), n (i.FilterRunOnce ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterRunOnce",
        e));

    s << *b;
  }

  // FilterLdap
  //
  for (Filters_t::FilterLdapConstIterator
       b (i.FilterLdap ().begin ()), n (i.FilterLdap ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterLdap",
        e));

    s << *b;
  }

  // FilterBattery
  //
  for (Filters_t::FilterBatteryConstIterator
       b (i.FilterBattery ().begin ()), n (i.FilterBattery ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterBattery",
        e));

    s << *b;
  }

  // FilterComputer
  //
  for (Filters_t::FilterComputerConstIterator
       b (i.FilterComputer ().begin ()), n (i.FilterComputer ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterComputer",
        e));

    s << *b;
  }

  // FilterCpu
  //
  for (Filters_t::FilterCpuConstIterator
       b (i.FilterCpu ().begin ()), n (i.FilterCpu ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterCpu",
        e));

    s << *b;
  }

  // FilterDate
  //
  for (Filters_t::FilterDateConstIterator
       b (i.FilterDate ().begin ()), n (i.FilterDate ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterDate",
        e));

    s << *b;
  }

  // FilterDun
  //
  for (Filters_t::FilterDunConstIterator
       b (i.FilterDun ().begin ()), n (i.FilterDun ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterDun",
        e));

    s << *b;
  }

  // FilterDisk
  //
  for (Filters_t::FilterDiskConstIterator
       b (i.FilterDisk ().begin ()), n (i.FilterDisk ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterDisk",
        e));

    s << *b;
  }

  // FilterDomain
  //
  for (Filters_t::FilterDomainConstIterator
       b (i.FilterDomain ().begin ()), n (i.FilterDomain ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterDomain",
        e));

    s << *b;
  }

  // FilterVariable
  //
  for (Filters_t::FilterVariableConstIterator
       b (i.FilterVariable ().begin ()), n (i.FilterVariable ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterVariable",
        e));

    s << *b;
  }

  // FilterFile
  //
  for (Filters_t::FilterFileConstIterator
       b (i.FilterFile ().begin ()), n (i.FilterFile ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterFile",
        e));

    s << *b;
  }

  // FilterIpRange
  //
  for (Filters_t::FilterIpRangeConstIterator
       b (i.FilterIpRange ().begin ()), n (i.FilterIpRange ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterIpRange",
        e));

    s << *b;
  }

  // FilterLanguage
  //
  for (Filters_t::FilterLanguageConstIterator
       b (i.FilterLanguage ().begin ()), n (i.FilterLanguage ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterLanguage",
        e));

    s << *b;
  }

  // FilterMacRange
  //
  for (Filters_t::FilterMacRangeConstIterator
       b (i.FilterMacRange ().begin ()), n (i.FilterMacRange ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterMacRange",
        e));

    s << *b;
  }

  // FilterMsi
  //
  for (Filters_t::FilterMsiConstIterator
       b (i.FilterMsi ().begin ()), n (i.FilterMsi ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterMsi",
        e));

    s << *b;
  }

  // FilterOs
  //
  for (Filters_t::FilterOsConstIterator
       b (i.FilterOs ().begin ()), n (i.FilterOs ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterOs",
        e));

    s << *b;
  }

  // FilterOrgUnit
  //
  for (Filters_t::FilterOrgUnitConstIterator
       b (i.FilterOrgUnit ().begin ()), n (i.FilterOrgUnit ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterOrgUnit",
        e));

    s << *b;
  }

  // FilterPcmcia
  //
  for (Filters_t::FilterPcmciaConstIterator
       b (i.FilterPcmcia ().begin ()), n (i.FilterPcmcia ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterPcmcia",
        e));

    s << *b;
  }

  // FilterPortable
  //
  for (Filters_t::FilterPortableConstIterator
       b (i.FilterPortable ().begin ()), n (i.FilterPortable ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterPortable",
        e));

    s << *b;
  }

  // FilterProcMode
  //
  for (Filters_t::FilterProcModeConstIterator
       b (i.FilterProcMode ().begin ()), n (i.FilterProcMode ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterProcMode",
        e));

    s << *b;
  }

  // FilterRam
  //
  for (Filters_t::FilterRamConstIterator
       b (i.FilterRam ().begin ()), n (i.FilterRam ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterRam",
        e));

    s << *b;
  }

  // FilterRegistry
  //
  for (Filters_t::FilterRegistryConstIterator
       b (i.FilterRegistry ().begin ()), n (i.FilterRegistry ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterRegistry",
        e));

    s << *b;
  }

  // FilterTerminal
  //
  for (Filters_t::FilterTerminalConstIterator
       b (i.FilterTerminal ().begin ()), n (i.FilterTerminal ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterTerminal",
        e));

    s << *b;
  }

  // FilterTime
  //
  for (Filters_t::FilterTimeConstIterator
       b (i.FilterTime ().begin ()), n (i.FilterTime ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterTime",
        e));

    s << *b;
  }

  // FilterUser
  //
  for (Filters_t::FilterUserConstIterator
       b (i.FilterUser ().begin ()), n (i.FilterUser ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterUser",
        e));

    s << *b;
  }

  // FilterWmi
  //
  for (Filters_t::FilterWmiConstIterator
       b (i.FilterWmi ().begin ()), n (i.FilterWmi ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterWmi",
        e));

    s << *b;
  }

  // FilterCollection
  //
  for (Filters_t::FilterCollectionConstIterator
       b (i.FilterCollection ().begin ()), n (i.FilterCollection ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterCollection",
        e));

    s << *b;
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Filters_t >
_xsd_Filters_t_type_serializer_init (
  "Filters_t",
  "");


void
Filters (::std::ostream& o,
         const ::Filters_t& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Filters (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Filters (::std::ostream& o,
         const ::Filters_t& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Filters (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Filters (::std::ostream& o,
         const ::Filters_t& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Filters (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Filters (::xercesc::XMLFormatTarget& t,
         const ::Filters_t& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Filters (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Filters (::xercesc::XMLFormatTarget& t,
         const ::Filters_t& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Filters (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Filters (::xercesc::XMLFormatTarget& t,
         const ::Filters_t& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Filters (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Filters (::xercesc::DOMDocument& d,
         const ::Filters_t& s,
         ::xml_schema::Flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::Filters_t) == typeid (s))
  {
    if (n.name () == "Filters" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Filters",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
      "Filters",
      "",
      e, n, s);
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
Filters (const ::Filters_t& s,
         const ::xml_schema::NamespaceInfomap& m,
         ::xml_schema::Flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::Filters_t) == typeid (s))
  {
    d = ::xsd::cxx::xml::dom::serialize< char > (
      "Filters",
      "",
      m, f);
  }
  else
  {
    d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
      "Filters",
      "",
      m, s, f);
  }

  ::Filters (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const FilterSite& i)
{
  e << static_cast< const ::IFilter& > (i);

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterGroup& i)
{
  e << static_cast< const ::IFilter& > (i);

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }

  // sid
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sid",
        e));

    a << i.sid ();
  }

  // userContext
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "userContext",
        e));

    a << i.userContext ();
  }

  // primaryGroup
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "primaryGroup",
        e));

    a << i.primaryGroup ();
  }

  // localGroup
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "localGroup",
        e));

    a << i.localGroup ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterRunOnce& i)
{
  e << static_cast< const ::IFilter& > (i);

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // userContext
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "userContext",
        e));

    a << i.userContext ();
  }

  // comments
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "comments",
        e));

    a << i.comments ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterLdap& i)
{
  e << static_cast< const ::IFilter& > (i);

  // searchFilter
  //
  if (i.searchFilter ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "searchFilter",
        e));

    a << *i.searchFilter ();
  }

  // binding
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "binding",
        e));

    a << i.binding ();
  }

  // variableName
  //
  if (i.variableName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "variableName",
        e));

    a << *i.variableName ();
  }

  // attribute
  //
  if (i.attribute ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "attribute",
        e));

    a << *i.attribute ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterBattery& i)
{
  e << static_cast< const ::IFilter& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FilterComputer& i)
{
  e << static_cast< const ::IFilter& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterCpu& i)
{
  e << static_cast< const ::IFilter& > (i);

  // speedMHz
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "speedMHz",
        e));

    a << i.speedMHz ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterDate& i)
{
  e << static_cast< const ::IFilter& > (i);

  // period
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "period",
        e));

    a << i.period ();
  }

  // dow
  //
  if (i.dow ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dow",
        e));

    a << *i.dow ();
  }

  // day
  //
  if (i.day ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "day",
        e));

    a << *i.day ();
  }

  // month
  //
  if (i.month ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "month",
        e));

    a << *i.month ();
  }

  // year
  //
  if (i.year ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "year",
        e));

    a << *i.year ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterDun& i)
{
  e << static_cast< const ::IFilter& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterDisk& i)
{
  e << static_cast< const ::IFilter& > (i);

  // freeSpace
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "freeSpace",
        e));

    a << i.freeSpace ();
  }

  // drive
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "drive",
        e));

    a << i.drive ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterDomain& i)
{
  e << static_cast< const ::IFilter& > (i);

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }

  // userContext
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "userContext",
        e));

    a << i.userContext ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterVariable& i)
{
  e << static_cast< const ::IFilter& > (i);

  // variableName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "variableName",
        e));

    a << i.variableName ();
  }

  // value
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "value",
        e));

    a << i.value ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterFile& i)
{
  e << static_cast< const ::IFilter& > (i);

  // gte
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "gte",
        e));

    a << i.gte ();
  }

  // lte
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "lte",
        e));

    a << i.lte ();
  }

  // min
  //
  if (i.min ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "min",
        e));

    a << *i.min ();
  }

  // max
  //
  if (i.max ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << *i.max ();
  }

  // path
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "path",
        e));

    a << i.path ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // folder
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "folder",
        e));

    a << i.folder ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterIpRange& i)
{
  e << static_cast< const ::IFilter& > (i);

  // min
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "min",
        e));

    a << i.min ();
  }

  // max
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << i.max ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterLanguage& i)
{
  e << static_cast< const ::IFilter& > (i);

  // default
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "default",
        e));

    a << i.default_ ();
  }

  // system
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "system",
        e));

    a << i.system ();
  }

  // native
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "native",
        e));

    a << i.native ();
  }

  // displayName
  //
  if (i.displayName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "displayName",
        e));

    a << *i.displayName ();
  }

  // language
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "language",
        e));

    a << i.language ();
  }

  // locale
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "locale",
        e));

    a << i.locale ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterMacRange& i)
{
  e << static_cast< const ::IFilter& > (i);

  // min
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "min",
        e));

    a << i.min ();
  }

  // max
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << i.max ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterMsi& i)
{
  e << static_cast< const ::IFilter& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // subtype
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "subtype",
        e));

    a << i.subtype ();
  }

  // code
  //
  if (i.code ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "code",
        e));

    a << *i.code ();
  }

  // item
  //
  if (i.item ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "item",
        e));

    a << *i.item ();
  }

  // value
  //
  if (i.value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "value",
        e));

    a << *i.value ();
  }

  // min
  //
  if (i.min ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "min",
        e));

    a << *i.min ();
  }

  // max
  //
  if (i.max ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << *i.max ();
  }

  // gte
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "gte",
        e));

    a << i.gte ();
  }

  // lte
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "lte",
        e));

    a << i.lte ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterOs& i)
{
  e << static_cast< const ::IFilter& > (i);

  // class
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "class",
        e));

    a << i.class_ ();
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "version",
        e));

    a << i.version ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // edition
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "edition",
        e));

    a << i.edition ();
  }

  // sp
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sp",
        e));

    a << i.sp ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterOrgUnit& i)
{
  e << static_cast< const ::IFilter& > (i);

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }

  // userContext
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "userContext",
        e));

    a << i.userContext ();
  }

  // directMember
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "directMember",
        e));

    a << i.directMember ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterPcmcia& i)
{
  e << static_cast< const ::IFilter& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FilterPortable& i)
{
  e << static_cast< const ::IFilter& > (i);

  // unknown
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "unknown",
        e));

    a << i.unknown ();
  }

  // docked
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "docked",
        e));

    a << i.docked ();
  }

  // undocked
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "undocked",
        e));

    a << i.undocked ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterProcMode& i)
{
  e << static_cast< const ::IFilter& > (i);

  // synchFore
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "synchFore",
        e));

    a << i.synchFore ();
  }

  // asynchFore
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "asynchFore",
        e));

    a << i.asynchFore ();
  }

  // backRefr
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "backRefr",
        e));

    a << i.backRefr ();
  }

  // forceRefr
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "forceRefr",
        e));

    a << i.forceRefr ();
  }

  // linkTrns
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "linkTrns",
        e));

    a << i.linkTrns ();
  }

  // noChg
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "noChg",
        e));

    a << i.noChg ();
  }

  // rsopTrns
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rsopTrns",
        e));

    a << i.rsopTrns ();
  }

  // safeBoot
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "safeBoot",
        e));

    a << i.safeBoot ();
  }

  // slowLink
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "slowLink",
        e));

    a << i.slowLink ();
  }

  // verbLog
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "verbLog",
        e));

    a << i.verbLog ();
  }

  // rsopEnbl
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rsopEnbl",
        e));

    a << i.rsopEnbl ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterRam& i)
{
  e << static_cast< const ::IFilter& > (i);

  // totalMB
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "totalMB",
        e));

    a << i.totalMB ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterRegistry& i)
{
  e << static_cast< const ::IFilter& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // subtype
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "subtype",
        e));

    a << i.subtype ();
  }

  // valueName
  //
  if (i.valueName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "valueName",
        e));

    a << *i.valueName ();
  }

  // valueType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "valueType",
        e));

    a << i.valueType ();
  }

  // valueData
  //
  if (i.valueData ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "valueData",
        e));

    a << *i.valueData ();
  }

  // variableName
  //
  if (i.variableName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "variableName",
        e));

    a << *i.variableName ();
  }

  // key
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "key",
        e));

    a << i.key ();
  }

  // hive
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hive",
        e));

    a << i.hive ();
  }

  // min
  //
  if (i.min ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "min",
        e));

    a << *i.min ();
  }

  // max
  //
  if (i.max ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << *i.max ();
  }

  // gte
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "gte",
        e));

    a << i.gte ();
  }

  // lte
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "lte",
        e));

    a << i.lte ();
  }

  // version
  //
  if (i.version ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "version",
        e));

    a << *i.version ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterTerminal& i)
{
  e << static_cast< const ::IFilter& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // option
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "option",
        e));

    a << i.option ();
  }

  // value
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "value",
        e));

    a << i.value ();
  }

  // min
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "min",
        e));

    a << i.min ();
  }

  // max
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << i.max ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterTime& i)
{
  e << static_cast< const ::IFilter& > (i);

  // begin
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "begin",
        e));

    a << i.begin ();
  }

  // end
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "end",
        e));

    a << i.end ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterUser& i)
{
  e << static_cast< const ::IFilter& > (i);

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // sid
  //
  if (i.sid ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sid",
        e));

    a << *i.sid ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterWmi& i)
{
  e << static_cast< const ::IFilter& > (i);

  // query
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "query",
        e));

    a << i.query ();
  }

  // nameSpace
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "nameSpace",
        e));

    a << i.nameSpace ();
  }

  // property
  //
  if (i.property ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "property",
        e));

    a << *i.property ();
  }

  // variableName
  //
  if (i.variableName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "variableName",
        e));

    a << *i.variableName ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FilterCollection& i)
{
  e << static_cast< const ::IFilter& > (i);

  // FilterSite
  //
  for (FilterCollection::FilterSiteConstIterator
       b (i.FilterSite ().begin ()), n (i.FilterSite ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterSite",
        e));

    s << *b;
  }

  // FilterGroup
  //
  for (FilterCollection::FilterGroupConstIterator
       b (i.FilterGroup ().begin ()), n (i.FilterGroup ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterGroup",
        e));

    s << *b;
  }

  // FilterRunOnce
  //
  for (FilterCollection::FilterRunOnceConstIterator
       b (i.FilterRunOnce ().begin ()), n (i.FilterRunOnce ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterRunOnce",
        e));

    s << *b;
  }

  // FilterLdap
  //
  for (FilterCollection::FilterLdapConstIterator
       b (i.FilterLdap ().begin ()), n (i.FilterLdap ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterLdap",
        e));

    s << *b;
  }

  // FilterBattery
  //
  for (FilterCollection::FilterBatteryConstIterator
       b (i.FilterBattery ().begin ()), n (i.FilterBattery ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterBattery",
        e));

    s << *b;
  }

  // FilterComputer
  //
  for (FilterCollection::FilterComputerConstIterator
       b (i.FilterComputer ().begin ()), n (i.FilterComputer ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterComputer",
        e));

    s << *b;
  }

  // FilterCpu
  //
  for (FilterCollection::FilterCpuConstIterator
       b (i.FilterCpu ().begin ()), n (i.FilterCpu ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterCpu",
        e));

    s << *b;
  }

  // FilterDate
  //
  for (FilterCollection::FilterDateConstIterator
       b (i.FilterDate ().begin ()), n (i.FilterDate ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterDate",
        e));

    s << *b;
  }

  // FilterDun
  //
  for (FilterCollection::FilterDunConstIterator
       b (i.FilterDun ().begin ()), n (i.FilterDun ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterDun",
        e));

    s << *b;
  }

  // FilterDisk
  //
  for (FilterCollection::FilterDiskConstIterator
       b (i.FilterDisk ().begin ()), n (i.FilterDisk ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterDisk",
        e));

    s << *b;
  }

  // FilterDomain
  //
  for (FilterCollection::FilterDomainConstIterator
       b (i.FilterDomain ().begin ()), n (i.FilterDomain ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterDomain",
        e));

    s << *b;
  }

  // FilterVariable
  //
  for (FilterCollection::FilterVariableConstIterator
       b (i.FilterVariable ().begin ()), n (i.FilterVariable ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterVariable",
        e));

    s << *b;
  }

  // FilterFile
  //
  for (FilterCollection::FilterFileConstIterator
       b (i.FilterFile ().begin ()), n (i.FilterFile ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterFile",
        e));

    s << *b;
  }

  // FilterIpRange
  //
  for (FilterCollection::FilterIpRangeConstIterator
       b (i.FilterIpRange ().begin ()), n (i.FilterIpRange ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterIpRange",
        e));

    s << *b;
  }

  // FilterLanguage
  //
  for (FilterCollection::FilterLanguageConstIterator
       b (i.FilterLanguage ().begin ()), n (i.FilterLanguage ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterLanguage",
        e));

    s << *b;
  }

  // FilterMacRange
  //
  for (FilterCollection::FilterMacRangeConstIterator
       b (i.FilterMacRange ().begin ()), n (i.FilterMacRange ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterMacRange",
        e));

    s << *b;
  }

  // FilterMsi
  //
  for (FilterCollection::FilterMsiConstIterator
       b (i.FilterMsi ().begin ()), n (i.FilterMsi ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterMsi",
        e));

    s << *b;
  }

  // FilterOs
  //
  for (FilterCollection::FilterOsConstIterator
       b (i.FilterOs ().begin ()), n (i.FilterOs ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterOs",
        e));

    s << *b;
  }

  // FilterOrgUnit
  //
  for (FilterCollection::FilterOrgUnitConstIterator
       b (i.FilterOrgUnit ().begin ()), n (i.FilterOrgUnit ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterOrgUnit",
        e));

    s << *b;
  }

  // FilterPcmcia
  //
  for (FilterCollection::FilterPcmciaConstIterator
       b (i.FilterPcmcia ().begin ()), n (i.FilterPcmcia ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterPcmcia",
        e));

    s << *b;
  }

  // FilterPortable
  //
  for (FilterCollection::FilterPortableConstIterator
       b (i.FilterPortable ().begin ()), n (i.FilterPortable ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterPortable",
        e));

    s << *b;
  }

  // FilterProcMode
  //
  for (FilterCollection::FilterProcModeConstIterator
       b (i.FilterProcMode ().begin ()), n (i.FilterProcMode ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterProcMode",
        e));

    s << *b;
  }

  // FilterRam
  //
  for (FilterCollection::FilterRamConstIterator
       b (i.FilterRam ().begin ()), n (i.FilterRam ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterRam",
        e));

    s << *b;
  }

  // FilterRegistry
  //
  for (FilterCollection::FilterRegistryConstIterator
       b (i.FilterRegistry ().begin ()), n (i.FilterRegistry ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterRegistry",
        e));

    s << *b;
  }

  // FilterTerminal
  //
  for (FilterCollection::FilterTerminalConstIterator
       b (i.FilterTerminal ().begin ()), n (i.FilterTerminal ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterTerminal",
        e));

    s << *b;
  }

  // FilterTime
  //
  for (FilterCollection::FilterTimeConstIterator
       b (i.FilterTime ().begin ()), n (i.FilterTime ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterTime",
        e));

    s << *b;
  }

  // FilterUser
  //
  for (FilterCollection::FilterUserConstIterator
       b (i.FilterUser ().begin ()), n (i.FilterUser ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterUser",
        e));

    s << *b;
  }

  // FilterWmi
  //
  for (FilterCollection::FilterWmiConstIterator
       b (i.FilterWmi ().begin ()), n (i.FilterWmi ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterWmi",
        e));

    s << *b;
  }

  // FilterCollection
  //
  for (FilterCollection::FilterCollection1ConstIterator
       b (i.FilterCollection1 ().begin ()), n (i.FilterCollection1 ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FilterCollection",
        e));

    s << *b;
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

